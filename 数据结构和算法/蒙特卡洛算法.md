---
title: 蒙特卡洛算法
date: 2019-10-09 19:52:42
tags:
---
### 蒙特卡洛介绍

&emsp;&emsp;蒙特卡罗方法(`Monte Carlo method`)也称`统计模拟方法`，是二十世纪四十年代中期由于科学技术的发展和电子计算机的发明，而被提出的一种以概率统计理论为指导的一类非常重要的数值计算方法。它是指使用随机数(或伪随机数)来解决很多计算问题的方法，与它对应的是确定性算法。蒙特卡罗方法在金融工程学、宏观经济学、计算物理学(如粒子输运计算、量子热力学计算、空气动力学计算)等领域应用广泛。
&emsp;&emsp;另外，拟蒙特卡洛算法在近几年也获得迅速发展。这种方法是用确定性的超均匀分布代替蒙特卡洛算法中的随机数序列，对于某些特定问题计算速度比普通的蒙特卡洛算法高几百倍。
&emsp;&emsp;由于产生随机数的随机性，当我们用`N`个随机点以蒙特卡罗方法来求解具体的问题时，其计算得到近似解的误差值有大有小，但是肯定有一个确定的平均值，即一些误差大于此值，而其余误差小于此值。鉴于此，显然肯定存在这样的`N`个点，使得误差的绝对值不大于平均值。如果我们能够构造这样的点集，就可以对原有的方法进行较大的改进。拟蒙特卡罗方法就是至于此而提出的，它致力于构造其误差比平均误差显著要好的那种点集，而其求解形式与蒙特卡罗方法一致，只不过所用的随机数不一样。用蒙特卡罗方法求解问题时，影响结果好坏的主要是随机数序列的均匀性。而拟蒙特卡罗方法中的具有低偏差的一致分布点集较伪随机数序列更为均匀，而且用拟蒙特卡罗方法求解得到的是真正的误差，避免了蒙特卡罗方法得到概率误差的缺陷。由此可见用拟蒙特卡罗方法求解问题的关键是如何找到一个均匀散布的点集。目前常用的点集有`GLP`点集(好格子点集，`good lattice point set`)、`GP`点集(好点集，`good point set`)、`Halton`点集及其变体、`Hammersley`点集等。
&emsp;&emsp;蒙特卡洛方法的理论基础是大数定律。大数定律是描述相当多次数重复试验的结果的定律，根据这个定律知道样本数量越多，其平均就越趋近于真实值。

### 蒙特卡洛的应用

#### 圆周率的计算

&emsp;&emsp;最经典的应用就是利用蒙特卡洛算法求圆周率。正方形内部有一个相切的圆，它们的面积之比是`π/4`。现在在这个正方形内部，随机产生`10000`个点(即`10000`个坐标对$(x, y)$)，计算它们与中心点的距离，从而判断是否落在圆的内部。

如果这些点均匀分布，那么圆内的点应该占到所有点的`π/4`，因此将这个比值乘以`4`，就是`π`的值。

``` cpp
#include <iostream>
#include <cmath>
#include <ctime>
​
#define COUNT 500000
​
using namespace std;
​
/* 是否在单位圆范围之内 */
bool InCircle(double  x, double  y) {
    if ((x * x + y * y) <= 1) {
        return true;
    }
​
    return false;
}
​
int main() {
    int num = 0;
    srand((unsigned)time(NULL));
​
    for (int i = 0; i < COUNT; i++) {
        double x, y;
        x = rand() * 1.0 / RAND_MAX;
        y = rand() * 1.0 / RAND_MAX;
​
        if (InCircle(x, y)) {
            num++;
        }
    }
​
    cout << "PI: " << (num * 4.0) / COUNT << endl;
    system("pause");
}
```

#### 积分的计算

&emsp;&emsp;将上面的方法加以推广，就可以计算任意一个积分的值。例如计算函数$y = x^2$在$[0, 1]$区间的积分，就是求出下图红色部分的面积：

这个函数在$(1, 1)$点的取值为`1`，所以整个红色区域在一个面积为`1`的正方形里面。在该正方形内部产生大量随机点，可以计算出有多少点落在红色区域(判断条件$y < x^2$)，这个比重就是所要求的积分值。
&emsp;&emsp;接下来用蒙特卡洛积分求自然常数`e`，其积分如下图：

假设满足上述条件的点有`m`个，而全部的点有`n`个，所以得到近似公式如下：

$$
S = \int_{1}^{2} \frac{1}{x} dx \approx \frac{m}{n} \ast (2 - 1) \ast (1 - 0)
$$

而依据牛顿莱布尼兹公式可以得到：

$$
S = \int_{1}^{2} \frac{1}{x} dx = ln2 - ln1 = ln2
$$

这两种方法结果应该是相等的，于是得到如下结论：

$$
ln2 = \frac{m}{n} \Rightarrow log_2e = \frac{n}{m} \Rightarrow e = 2^{\frac{n}{m}}
$$

``` cpp
#include <iostream>
#include <cmath>
#include <ctime>
​
#define MAX_ITERS 10000000
​
using namespace std;
​
struct Point {
    double x, y;
};
​
double Rand(double L, double R) {
    return L + (R - L) * rand() * 1.0 / RAND_MAX;
}
​
Point getPoint() {
    Point t;
    t.x = Rand(1.0, 2.0);
    t.y = Rand(0.0, 1.0);
    return t;
}
​
double getResult() {
    int m = 0;
    int n = MAX_ITERS;
    srand(time(NULL));
​
    for (int i = 0; i < n; i++) {
        Point t = getPoint();
        double res = t.x * t.y;
​
        if (res <= 1.0) {
            m++;
        }
    }
​
    return pow(2.0, 1.0 * n / m);
}
​
int main() {
    for (int i = 0; i < 20; i++) {
        cout << getResult() << endl;
    }
​
    system("pause");
    return 0;
}
```