---
title: 队列
date: 2019-02-09 10:27:47
tags:
---
### 静态数组队列

&emsp;&emsp;`queue.h`如下：

``` cpp
#ifndef QUEUE_H
#define QUEUE_H
​
#include "stdlib.h"
​
#define QUEUE_TYPE int /* 队列元素的类型 */
​
/*
* 创建一个队列，参数指定队列可以储存的元素的最大数量。
* 注意，这个函数只适用于使用动态分配数组的队列
*/
void create_queue ( size_t size );
​
/* 销毁一个队列。注意，这个函数只适用于链式和动态分配数组的队列 */
void destroy_queue ( void );
​
/* 向队列添加一个新元素，参数就是需要添加的元素 */
void insert ( QUEUE_TYPE value );
​
/* 从队列中移除一个元素并将其丢弃 */
void delete ( void );
​
/* 返回队列中的第一个元素的值，但不修改队列本身 */
QUEUE_TYPE first ( void );
​
/* 如果队列为空，返回TRUE */
int is_empty ( void );
​
/* 如果队列已满，返回TRUE，否则返回FALSE */
int is_full ( void );
​
#endif
```

&emsp;&emsp;`main.c`如下：

``` cpp
#include "queue.h"
#include "stdio.h"
#include "assert.h"
​
#define QUEUE_SIZE 5 /* 队列中元素的最大数量 */
#define ARRAY_SIZE (QUEUE_SIZE+1) /* 数组的长度 */
​
/* 用于存储队列元素的数组和指向队列头和尾的指针 */
static QUEUE_TYPE queue[QUEUE_SIZE];
static size_t front = 1;
static size_t rear = 0;
static size_t queue_size = 0; /* 队列中有效数据的数量 */
​
void insert ( QUEUE_TYPE value ) {
    assert ( !is_full() );
    rear = ( rear + 1 ) % ARRAY_SIZE;
    queue[rear] = value;
    queue_size++;
}
​
void delete ( void ) {
    assert ( !is_empty() );
    front = ( front + 1 ) % ARRAY_SIZE;
    queue_size--;
}
​
QUEUE_TYPE first ( void ) {
    assert ( !is_empty() );
    return queue[front];
}
​
int is_empty ( void ) {
    return ( rear + 1 ) % ARRAY_SIZE == front;
}
​
int is_full ( void ) {
    return ( rear + 2 ) % ARRAY_SIZE == front;
}
​
void print ( void ) {
    int index = 0;
​
    for ( ; index <= QUEUE_SIZE; index++ ) {
        printf ( "%d ", queue[index] );
    }
​
    printf ( "front is %d, rear is %d\n", front, rear );
​
    for ( index = 0; index < queue_size; index++ ) {
        printf ( "%d ", queue[ ( front + index ) % ARRAY_SIZE] );
    }
​
    printf ( "\n" );
}
​
int main ( void ) {
    insert ( 1 );
    insert ( 2 );
    insert ( 3 );
    insert ( 4 );
    print();
    delete();
    delete();
    print();
    insert ( 5 );
    insert ( 6 );
    insert ( 7 );
    print();
    return 0;
}
```

### 链式队列

&emsp;&emsp;`LinkQueue.h`如下：

``` cpp
/* 队列是一种先进先出线性表，队列是线性表的特化，也具有线性表的性质，分为顺序队列与链式队列。
   链式队列与线性表的单链表相似，只不过链式队列只允许从头部进行删除、尾部进行插入。
   需要为链式队列创建一个头结点，包括两个指针：指向队头的指针(front)与指向队尾的指针(rear)。
   当两个指针相等时，队列为空 */
#ifndef LINKQUEUE_H
#define LINKQUEUE_H
​
typedef int ElemType; /* 队列的数据类型 */
​
typedef struct node {
    ElemType data; /* 队列的数据类型 */
    struct node *next; /* 指向下一个结点 */
} QueNode, *QuePtr;
​
typedef struct {
    QuePtr front; /* 指向队头的指针 */
    QuePtr rear; /* 指向队尾的指针 */
} LinkQueue;
​
void InitQueue ( LinkQueue *q ); /* 初始化队列 */
void CreateQueue ( LinkQueue *q ); /* 创建队列 */
void EnQueue ( LinkQueue *q, ElemType e ); /* 进队操作，将元素e压入队列中 */
void DeQueue ( LinkQueue *q, ElemType *e ); /* 出队操作，将出队的元素存入“*e”中 */
int GetQueueLength ( LinkQueue *q ); /* 获取队列的长度 */
void Print ( LinkQueue *q ); /* 打印队列的元素 */
void Clear ( LinkQueue *q ); /* 清空队列 */
void TopQueue ( LinkQueue *q, ElemType *e ); /* 返回队头的元素 */
​
#endif
```

&emsp;&emsp;`LinkQueue.c`如下：

``` cpp
#include "LinkQueue.h"
#include <stdio.h>
#include <stdlib.h>
#include "stdbool.h"
​
void InitQueue ( LinkQueue *q ) { /* 初始化队列 */
    /* 初始化队头与队尾的指针指向头结点 */
    q->front = q->rear = ( QuePtr ) malloc ( sizeof ( QueNode ) );
    q->front->next = NULL;
}
​
void CreateQueue ( LinkQueue *q ) { /* 创建队列 */
    InitQueue ( q );
    printf ( "请输入要进队的元素，以CTRL+Z结尾\n" );
    int k;
​
    while ( ( scanf ( "%d", &k ) ) != EOF ) {
        EnQueue ( q, k );
    }
}
​
void EnQueue ( LinkQueue *q, ElemType e ) { /* 将元素e进队 */
    QuePtr temp = ( QuePtr ) malloc ( sizeof ( QueNode ) ); /* 创建新结点 */
​
    if ( temp ) { /* 如果内存分配成功 */
        temp->data = e; /* 初始化新结点的数据为e */
        temp->next = NULL; /* 队列只能从队尾插入所以下一个结点初始化为NULL */
        /* 将队尾结点的指针指向新结点，如果新结点为第一个结点，则q->rear->next相当于q->front->next */
        q->rear->next = temp;
        q->rear = temp; /* 将指向队尾的指针指向新结点 */
    }
}
​
/* 队头的结点出队，将出队的结点的元素存入"*e" */
void DeQueue ( LinkQueue *q, ElemType *e ) {
    if ( q->front == q->rear ) { /* 队列为空 */
        return;
    }
​
    QuePtr temp = q->front->next; /* 初始化temp为要出队的结点的指针 */
​
    /* 如果要出队的结点为最后一个结点，使q->rear指向头结点防止出现悬空的指针 */
    if ( q->front->next == q->rear ) {
         q->rear = q->front;
    }
​
    *e = temp->data; /* 将出队的数据元素存入*e */
    q->front->next = temp->next; /* 使下一个结点成为队头，如果没有下一个结点则为NULL */
    free ( temp ); /* 删除要出队的结点 */
}
​
bool IsEmpty ( LinkQueue *q ) { /* 判断队列是否为空 */
    if ( q->front == q->rear ) {
        return true;
    }
​
    return false;
}
​
int GetQueueLength ( LinkQueue *q ) { /* 返回队列的长度 */
    QuePtr temp = q->front;
    int i = 0;
​
    while ( temp != q->rear ) {
        ++i;
        temp = temp->next;
    }
​
    return i;
}
​
void Clear ( LinkQueue *q ) { /* 清空队列 */
    QuePtr temp = q->front->next;
​
    while ( temp ) {
        QuePtr tp = temp;
        temp = temp->next;
        free ( tp );
    }
​
    temp = q->front;
    q->front = q->rear = NULL;
    free ( temp );
}
​
void Print ( LinkQueue *q ) { /* 打印队列的元素 */
    if ( q->front == q->rear ) {
        return;
    }
​
    QuePtr temp = q->front->next;
​
    while ( temp != q->rear ) {
        printf ( "%d ", temp->data );
        temp = temp->next;
    }
​
    printf ( "%d", temp->data );
    printf ( "\n" );
}
​
void TopQueue ( LinkQueue *q, ElemType *e ) { /* 返回队头的结点元素存入“*e” */
    if ( q->front == q->rear ) {
        return;
    }
​
    *e = q->front->next->data;
}
```

&emsp;&emsp;`main.c`如下：

``` cpp
#include "LinkQueue.h"
#include <stdio.h>
​
int main() {
    LinkQueue q;
    CreateQueue ( &q );
    Print ( &q );
    int top;
    TopQueue ( &q, &top );
    printf ( "队头的元素为:%d\n", top );
    int len = GetQueueLength ( &q );
    int k;
    printf ( "将队列中的所有元素出队:\n" );
​
    for ( int i = 0; i < len; ++i ) {
        DeQueue ( &q, &k );
        printf ( "%d ", k );
    }
​
    printf ( "\n" );
    Clear ( &q );
    return 0;
}
```