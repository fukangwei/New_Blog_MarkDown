---
title: 字符串处理算法
date: 2019-02-09 12:47:19
categories: 数据结构和算法
---
### atoi函数

&emsp;&emsp;`atoi`函数是将字符串转换为相应的整型数。版本`1`如下：

``` cpp
int atoi ( char *str ) {
    int value = 0;

    while ( *str >= '0' && *str <= '9' ) {
        value *= 10;
        value += *str - '0';
        str++;
    }

    return value;
}
```

版本`2`如下：

``` cpp
#include <ctype.h>

int atoi ( char s[] ) {
    int i, n, sign;

    for ( i = 0; isspace ( s[i] ); i++ ) /* skip white space */
        ;

    sign = ( s[i] == '-' ) ? -1 : 1;

    if ( s[i] == '+' || s[i] == '-' ) { /* skip sign */
        i++;
    }

    for ( n = 0; isdigit ( s[i] ); i++ ) {
        n = 10 * n + ( s[i] - '0' );
    }

    return sign * n;
}
```

### squeeze函数

&emsp;&emsp;`squeeze`函数是从字符串`s`中删除`c`：

``` cpp
void squeeze ( char s[], int c ) {
    int i, j;

    for ( i = j = 0; s[i] != '\0'; i++ )
        if ( s[i] != c ) {
            s[j++] = s[i];
        }

    s[j] = '\0';
}
```

### strcat函数

&emsp;&emsp;`strcat`函数是将字符串`t`连接到字符串`s`的尾部，注意`s`必须有足够大的空间：

``` cpp
void strcat ( char s[], char t[] ) {
    int i, j;
    i = j = 0;

    while ( s[i] != '\0' ) { /* 判断是否为字符串s的尾部 */
        i++;
    }

    while ( ( s[i++] = t[j++] ) != '\0' ) /* 拷贝t */
        ;
}
```

### reverse函数

&emsp;&emsp;`reverse`函数是倒置字符串`s`中各个字符的位置：

``` cpp
#include <string.h>
​
void reverse ( char s[] ) {
    int c, i, j;

    for ( i = 0, j = strlen ( s ) - 1; i < j; i++, j-- ) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
```

### itoa函数

&emsp;&emsp;`itoa`函数是将数字转换为字符串并保存到`s`中：

``` cpp
void itoa ( int n, char s[] ) {
    int i, sign;

    if ( ( sign = n ) < 0 ) { /* record sign */
        n = -n; /* make n positive */
    }

    i = 0;

    do { /* generate digits in reverse order */
        s[i++] = n % 10 + '0'; /* get next digit */
    } while ( ( n /= 10 ) > 0 ); /* delete it */

    if ( sign < 0 ) {
        s[i++] = '-';
    }

    s[i] = '\0';
    reverse ( s );
}
```

### strlen函数

&emsp;&emsp;`strlen`函数返回字符串`s`的长度：

``` cpp
int strlen ( char *s ) {
    int n;

    for ( n = 0; *s != '\0', s++ ) {
        n++;
    }

    return n;
}
```

不使用额外变量的方式：

``` cpp
int mystrlen(char *s) {
    if (*s++) {
        return mystrlen(s) + 1;
    }
​
    return 0;
}
```

### strcpy函数

&emsp;&emsp;`strcpy`函数将指针`t`指向的字符串复制到指针`s`指向的位置：

``` cpp
void strcpy ( char *s, char *t ) {
    int i;
    i = 0;

    while ( ( s[i] = t[i] ) != '\0' ) {
        i++;
    }
}
```

### strcmp函数

&emsp;&emsp;`strcmp`函数如下：

``` cpp
int strcmp ( char *s, char *t ) {
    for ( ; *s == *t; s++, t++ )
        if ( *s == '\0' ) {
            return 0;
        }

    return *s - *t;
}
```

### trim函数

&emsp;&emsp;`trim`函数删除字符串尾部的空格符、制表符与换行符：

``` cpp
int trim ( char s[] ) {
    int n;

    for ( n = strlen ( s ) - 1; n >= 0; n-- )
        if ( s[n] != ' ' && s[n] != '\t' && s[n] != '\n' ) {
            break;
        }

    s[n + 1] = '\0';
    return n;
}
```

### atof函数

&emsp;&emsp;`atof`函数把字符串转换为相应的双精度浮点数：

``` cpp
#include <ctype.h>

double atof ( char s[] ) {
    double val, power;
    int i, sign;

    for ( i = 0; isspace ( s[i] ); i++ ) /* skip white space */
        ;

    sign = ( s[i] == '-' ) ? -1 : 1;

    if ( s[i] == '+' || s[i] == '-' ) {
        i++;
    }

    for ( val = 0.0; isdigit ( s[i] ); i++ ) {
        val = 10.0 * val + ( s[i] - '0' );
    }

    if ( s[i] == '.' ) {
        i++;
    }

    for ( power = 1.0; isdigit ( s[i] ); i++ ) {
        val = 10.0 * val + ( s[i] - '0' );
        power *= 10;
    }

    return sign * val / power;
}
```

### numcmp函数

&emsp;&emsp;`numcmp`函数按数值顺序比较字符串`s1`和`s2`：

``` cpp
int numcmp ( char *s1, char *s2 ) {
    double v1, v2;
    v1 = atof ( s1 );
    v2 = atof ( s2 );

    if ( v1 < v2 ) {
        return -1;
    } else if ( v1 > v2 ) {
        return 1;
    } else {
        return 0;
    }
}
```

### SubStr函数

&emsp;&emsp;在主串中截取给定位置和给定长度的子串：

``` cpp
/* 串T的第pos个字符长度为len的子串为S */
void SubStr ( char *S, char *T, int pos, int len ) {
    int i, j;
    j = strlen ( T );
​
    if ( pos < 1 || pos > j ) {
        printf ( "起始位置错误\n" );
        return ;
    }
​
    if ( len < 0 ) {
        printf ( "长度错误\n" );
    }
​
    T += ( pos - 1 );
​
    for ( i = 1; i <= len && *T != '\0'; i++ ) {
        *S++ = *T++;
    }
​
    *S = '\0';
}
```

### StrInsert函数

&emsp;&emsp;字符串中子串的插入操作：

``` cpp
void StrInsert ( char *S, int pos, char *T ) { /* 在串S的第pos个字符后插入串T */
    int i,lenT,lenS;
    lenT = strlen ( T );
    lenS = strlen ( S );
​
    for ( i = lenS; i >= pos - 1; i-- ) {
        /* 将主串S从pos位置开始的子串从最后的字符开始向前逐个后移，为插入T腾出位置 */
        * ( S + i + lenT )  = * ( S + i );
    }
​
    for ( i = pos ; i <= pos + lenT - 1; i++ ) {
        * ( S + i - 1 ) = *T++; /* 将串插入到S中空出位置 */
    }
​
    * ( S + lenS + lenT ) = '\0';
}
```

### StrDelete函数

&emsp;&emsp;子串的删除：

``` cpp
/* 从串S中删除第pos个字符串起长度为len的子串 */
void StrDelete ( char *S, int pos, int len ) {
    int i, lenS;
    lenS =  strlen ( S );
​
    /* 如果从删除位置开始删除的子串长度大于主串后面的长度，则只保留主串前面字符 */
    if ( pos + len > lenS ) {
        * ( S + pos - 1 ) = '\0';
    } else { /* 将串S从已删除的子串后面开始逐个前移到pos位置 */
        for ( i = pos + len - 1; i < lenS; i++ ) {
            * ( S + i - len ) = * ( S + i );
        }
​
        * ( S + lenS - len ) = '\0';
    }
}
```

### StrIndex函数

&emsp;&emsp;子串的定位：

``` cpp
/* 返回T在S中第pos个字符后出现的位置；否则函数返回0 */
int StrIndex ( char *S, char *T, int pos ) {
    int i = pos - 1, j = 0, lenS, lenT, b = 0;
    lenS = strlen ( S );
    lenT = strlen ( T );
​
    while ( i < lenS && j < lenT ) {
        /* 当前对应字符相同，继续比较后面的字符 */
        if ( * ( S + i ) == * ( T + j ) ) {
            i++;
            j++;
        } else { /* 重新进行新的一趟比较 */
            i = i - j + 1;
            j = 0;
        }
    }
​
    if ( j == lenT ) {
        return ( i - lenT + 1 );
    } else {
        return 0;
    }
}
```

### binary_ascii函数

&emsp;&emsp;输入一个整数(无符号)，把它转换为字符并打印，前导零被删除：

``` cpp
void binary_ascii ( unsigned int value ) {
    unsigned int quotient;
    quotient = value / 10;
​
    if ( quotient != 0 ) {
        binary_ascii ( quotient );
    }
​
    putchar ( value % 10 + '0' );
}
```

递归的思想实质上是数学归纳法。设数字仅由一位(`n = 1`)，则函数`f(n)`的功能是输出该数字；假设该数字有`k`位(`n = k`)，则`f(n)`的功能是输出前`k - 1`位，然后再输出最后一位，即`f(k) = f(k - 1) + f(1)`。由此得到递归式`f(n) = f(n - 1) + f(1)，(n - 1) = (n) / 10`。

### LoopMove函数

&emsp;&emsp;把字符串循环右移`n`位：

``` cpp
/* pStr是指向以“\0”结尾的字符串的指针，steps是要求移动的n位 */
void LoopMove ( char *pStr, int steps ) { /* 方法1 */
    int n = strlen ( pStr ) - steps;
    char tmp[MAX_LEN];
    strcpy ( tmp, pStr + n );
    strcpy ( tmp + steps, pStr );
    * ( tmp + strlen ( pStr ) ) = '\0';
    strcpy ( pStr, tmp );
}
​
void LoopMove ( char *pStr, int steps ) { /* 方法2 */
    int n = strlen ( pStr ) - steps;
    char tmp[MAX_LEN];
    memcpy ( tmp, pStr + n, steps );
    memcpy ( pStr + steps, pStr, n );
    memcpy ( pStr, tmp, steps );
}
```

### 判断回文字符串

&emsp;&emsp;判断一个字符串是否为回文字符串：

``` cpp
#include <stdio.h>
#include <string.h>
​
int main( void ) {
    char s[100]; /* 存放输入的字符串 */
    int i, j, n;
    printf ( "输入字符串: " );
    gets ( s );
    n = strlen ( s );
​
    for ( i = 0, j = n - 1; i < j; i++, j-- )
        if ( s[i] != s[j] ) {
            break;
        }
​
    if ( i >= j ) {
        printf ( "是回文串\n" );
    } else {
        printf ( "不是回文串\n" );
    }
}
```

### 语句翻转

&emsp;&emsp;将`tom is cat`进行翻转，即`cat is tom`：

``` cpp
#include <string.h>
#include <stdio.h>
​
int main ( void ) {
    int  j = 0, i = 0, begin = 0, end = 0;
    char str[] = "I am a student";
    char temp = 0;
    j = strlen ( str ) - 1;
    printf ( "string = %s\n", str );
​
    /* 第一步是进行全盘反转，将单词变成“tneduts a ma I” */
    while ( j > i ) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
        j--;
        i++;
    }
​
    printf ( "string = %s\n", str );
    i = 0;
​
    /* 第二步进行部分反转，如果不是空格则开始反转单词 */
    while ( str[i] ) {
        if ( str[i] != ' ' ) {
            begin = i;
​
            while ( str[i] && ( str[i] != ' ' ) ) {
                i++;
            }
​
            i = i - 1;
            end = i;
        }
​
        while ( end > begin ) {
            temp = str[begin];
            str[begin] = str[end];
            str[end] = temp;
            end--;
            begin++;
        }
​
        i++;
    }
​
    printf ( "string = %s\n", str );
    return 0;
}
```

### strrindex函数

&emsp;&emsp;返回字符串`t`在`s`中最右边出现的位置：

``` cpp
int strrindex ( char s[], char t[] ) {
    int i, j, k, rindex;
    rindex = -1;
​
    for ( i = 0; s[i] != '\0'; i++ ) {
        /* check if t starts at this index in s */
        for ( j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++ );
​
        if ( k > 0 && t[k] == '\0' ) /* if it does ...*/
            rindex = i; /* replace rindex with our find */
    }
​
    return rindex;
}
```

### 只出现一次的字符

&emsp;&emsp;在一个字符串中找到第一个只出现一次的字符，如输入`abaccdeff`，则输出`b`：

``` cpp
#include <iostream>
#include <stdlib.h>
​
using namespace std;
​
char firstSingle(char *str) {
    int a[255];
    memset(a, 0, 255 * sizeof(int));
    char *p = str;
​
    while (*p != '\0') {
        a[*p]++;
        p++;
    }
​
    p = str;
​
    while (*(p++) != 0) {
        if (a[*p] == 1) {
            return *p;
        }
    }
​
    return 'N'; /* N意思是“NO”，即没有 */
}
​
int main() {
    char str[20] = "aaccdeff";
    cout << firstSingle(str) << endl;
    system("pause");
    return 0;
}
```

### count_of_substr函数

&emsp;&emsp;返回子字符串的个数：

``` cpp
int count_of_substr(const char *str, const char *sub) {
    int count = 0;
    const char *p = str;
    int n = strlen(sub);
​
    while (*p != '\0') {
        if (strncmp(p, sub, n) == 0) {
            count++;
        }
​
        p++;
    }
​
    return count;
}
```