---
title: 选择排序
categories: 数据结构和算法
abbrlink: 43d00a99
date: 2018-12-30 12:30:11
---
&emsp;&emsp;选择排序(`Selection sort`)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。选择排序是先确定位置，然后再去寻找应该占有该位置的对象。
&emsp;&emsp;`n`个记录的文件的直接选择排序可经过`n - 1`趟直接选择排序得到有序结果：

- 初始状态：无序区为`R[1..n]`，有序区为空。
- 第`1`趟排序：在无序区`R[1..n]`中选出关键字最小的记录`R[k]`，将它与无序区的第`1`个记录`R[1]`交换，使`R[1..1]`和R`[2..n]`分别变为记录个数增加`1`个的新有序区和记录个数减少`1`个的新无序区。
- 第`i`趟排序：第`i`趟排序开始时，当前有序区和无序区分别为`R[1..i-1]`和`R[i..n]`。该趟排序从当前无序区中选出关键字最小的记录`R[k]`，将它与无序区的第`1`个记录`R`交换，使`R[1..i]`和`R`分别变为记录个数增加`1`个的新有序区和记录个数减少`1`个的新无序区。

``` cpp
#include <stdio.h>
#include "stdlib.h"
#include <math.h>
​
#define MAX_SIZE 101
#define SWAP(x, y, t)  ((t) = (x), (x) = (y), (y) = (t))
​
void sort ( int[], int );   /* selection sort */
​
int main ( void ) {
    int i, n;
    int list[MAX_SIZE];
    printf ( "Enter the number of numbers to generate: " );
    scanf ( "%d", &n );
​
    if ( n < 1 || n > MAX_SIZE ) {
        fprintf ( stderr, "Improper value of n\n" );
        exit ( 1 );
    }
​
    for ( i = 0; i < n; i++ ) { /* randomly generate numbers */
        list[i] = rand() % 100;
        printf ( "%d ", list[i] );
    }
​
    sort ( list, n );
    printf ( "\nSorted array:\n" );
​
    for ( i = 0; i < n; i++ ) { /* print out sorted numbers */
        printf ( "%d ", list[i] );
    }
​
    printf ( "\n" );
    return 0;
}
​
void sort ( int list[], int n ) {
    int i, j, min, temp;
​
    for ( i = 0; i < n - 1; i++ ) {
        min = i;
​
        for ( j = i + 1; j < n; j++ )
            if ( list[j] < list[min] ) {
                min = j;
            }
​
        SWAP ( list[i], list[min], temp );
    }
}
```