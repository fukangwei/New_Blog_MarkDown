---
title: 十种软件滤波算法
date: 2019-02-09 12:02:09
tags:
---
### 限幅滤波法

&emsp;&emsp;先根据经验判断，确定两次采样允许的最大偏差值，设为`A`。每次检测到新采样值时进行判断：

- 如果本次新采样值与上一次滤波效果之差`<= A`，则本次采样值有效，令本次滤波结果等于新采样值。
- 如果本次采样值与上次滤波结果之差`> A`，则本次采样值无效，放弃本次采样值，本次滤波结果等于上次滤波结果。

&emsp;&emsp;优点是能有效克服因偶然因素引起的脉冲干扰；缺点是无法抑制那种周期性的干扰，且平滑度差。

``` cpp
#define A 10 /* 两次采样的最大误差值，该值需要使用者根据实际情况设置 */
uchar Value; /* 上次采样有效值 */
​
uchar AmplitudeLimiterFilter() {
    uchar NewValue, /* 当前采样的值 */
          ReturnValue;
    NewValue = GetAD(); /* 本次采样值 */
​
    if ( ( ( NewValue - Value ) > A ) || ( ( Value - NewValue ) > A ) ) )
        ReturnValue = Value;
        else {
            ReturnValue = NewValue;
        }
​
    return ( ReturnValue ); /* 返回值，本次滤波结果 */
}
```

### 中位值滤波法

&emsp;&emsp;连续采样`N`次值，把采样值按大小排列，取中间值为本次有效值。
&emsp;&emsp;优点是能有效克服因偶然因素引起的波动干扰；对温度、液位等变化缓慢的被测参数有良好的滤波效果；缺点是对流量、速度等快速变化的参数不宜。

``` cpp
#define N 9 /* 数组长度 */
​
unchar MiddleValueFilter() {
    unchar i, j, k;
    uchar temp;
    uchar ArrDataBuffer[N]; /* 用来存放一次性采集的N组数据 */
​
    for ( i = 0; i < N; i++ ) { /* 一次采集N个数据放入数组中 */
        ArrDataBuffer[i] = GetAD(); /* 该用来取得当前值 */
        Delay(); /* 延时函数 */
    }
​
    for ( j = 0; j < N - 1; j++ ) { /* 采样值由小到大排列 */
        for ( k = 0; k < N - j - 1; k++ ) {
            if ( ArrDataBuffer[k] > ArrDataBuffer[k + 1] ) {
                temp = ArrDataBuffer[k];
                ArrDataBuffer[k] = ArrDataBuffer[k + 1];
                ArrDataBuffer[k + 1] = temp;
            }
        }
    }
​
    return ( ArrDataBuffer[ ( N - 1 ) / 2] ); /* 取中间值 */
}
```

### 算术平均滤波法

&emsp;&emsp;连续取`N`个值进行算术平均运算。`N`较大时，信号平滑度较高，但灵敏度较低；`N`较小时，信号平滑度低，但灵敏度较高。
&emsp;&emsp;优点是适用于对一般具有随机干扰的信号进行滤波。这种信号的特点是有一个平均值，信号在某一数值范围附近上下波动；缺点是对于测量速度较慢或要求数据计算较快的实时控制不适用。

``` cpp
#define N 12
​
uchar ArithmeticalAverageValueFilter() {
    uchar i;
    uchar Value;
    uchar sum;
    sum = 0;
​
    for ( i = 0; i < N; i++ ) {
        sum += GetAD();
        Delay();
    }
​
    Value = sum / N;
    return ( Value );
}
```

### 递推平均滤波法

&emsp;&emsp;把连续`N`个采集值看成一个队列，每次采集到的新数据放入队尾，并扔掉原来队首的数据。把队列中的N个数据进行平均计算，即可获得新的滤波结果。
&emsp;&emsp;优点是对周期性干扰有良好的抑制作用，平滑度高，适用于高频振荡的系统；缺点是灵敏度低，对偶然出现的脉冲性干扰的抑制作用较差，不适于脉冲干扰较严重的场合。

``` cpp
#define N 12
uchar Data[N];
​
uchar Gilde ( Data[] ) {
    ucahr i, Value, sum;
    sum = 0;
    Data[N] = GetAD();
​
    for ( i = 0; i < N; i++ ) {
        Data[i] = Data[i + 1]; /* 所有数据左移，低位仍掉 */
        sum += Data[i];
    }
​
    Value = sum / N;
    return ( Value );
}
```

### 中位值平均滤波法

&emsp;&emsp;中位值平均滤波法又称脉冲干扰平均滤波法，相当于`中位值滤波法`加上`算术平均滤波法`。连续采集`N`个数据，去掉一个最大和最小值，然后计算`N - 2`个数的平均值。
&emsp;&emsp;优点是融合了两种滤波的优点，对于偶然出现的脉冲性干扰，可消除有其引起的采样值偏差，对周期干扰有良好的抑制作用，平滑度高，适于高频振荡的系统；缺点是测量速度慢。

``` cpp
#define N 12
​
uchar Middle() {
    ucahr i, j, k, l;
    uchar temp;
    uchar ArrDataBuffer[N];
    uchar sum, Value;
​
    for ( i = 0; i < N; i++ ) { /* 一次采集N个数据，存入数组 */
        ArrDataBuffer[i] = GetAD();
        Delay();
    }
​
    for ( j = 0; j < N - 1; j++ ) { /* 采样值由小到大排列 */
        for ( k = 0; k < N - j - 1; k++ ) {
            if ( ArrDataBuffer[k] > ArrDataBuffer[k + 1] ) {
                temp = ArrDataBuffer[k];
                ArrDataBuffer[k] = ArrDataBuffer[k + 1];
                ArrDataBuffer[k + 1] = temp;
            }
        }
    }
​
    for ( l = 0; l < N - 1; l++ ) {
        sum = ArrDataBuffer[l];
    }
​
    Value = Sum / ( N - 2 );
    return ( Value );
}
```

### 递推中位值平均滤波法

&emsp;&emsp;相当于`中位值滤波法`加上`递推平均滤波法`。这种方法把连续`N`个值看成一个队列，每次采集到一个新数据放入队尾，并扔掉原来队首的值。把队列中的`N`个数据先去掉一个最大值和最小值，然后计算`N - 2`个数据的平均值。
&emsp;&emsp;优点是对于偶然出现的脉冲性干扰，可消除由其引起的采样值偏差，对周期性干扰有良好的抑制作用，平滑度高，适用于高频振荡的系统；缺点是测量速度慢。

``` cpp
char Filter() {
    char max, min;
    int sum;
    char i;
    QUEUE[0] = NewData;
    max = QUEUE[0];
    min = QUEUE[0];
    sum = QUEUE[0];
​
    for ( i = n - 1; i != 0; i-- ) {
        if ( QUEUE[i] > max ) {
            max = QUEUE[i];
        } else if ( QUEUE[i] < min ) {
            min = QUEUE[i];
        }
​
        sum += QUEUE[i];
        QUEUE[i] = QUEUE[i - 1];
    }
​
    i = n - 2;
    sum = sum - max - min + i / 2; /* 加入(n-2)/2目的为了四舍五入 */
    sum = sum / i;
    return ( sum );
}
```

### 限幅平均滤波法

&emsp;&emsp;相当于`限幅滤波法`加上`递推平均滤波法`。每次采样先进行限幅处理，再进行队列平均滤波处理。
&emsp;&emsp;优点是对于偶然出现的脉冲性干扰，可消除有其引起的采样值偏差。

``` cpp
#define A 10
#define N 12
​
uchar Data[N];
​
uchar Limit() {
    ucahr i, Value, sum;
    Data[N] = GetAD();
​
    if ( ( ( Data[N] - Data[N - 1] ) > A ) || ( ( Data[N - 1] - Data[N] ) > A ) ) )
        Data[N] = Data[N - 1];
        else {
            Data[N] = NewValue;
        }
​
    for ( i = 0; i < N; i++ ) {
    Data[i] = Data[i + 1];
        sum += Data[i];
    }
​
    Value = sum / N;
    return ( Value );
}
```

### 一阶滞后滤波法

&emsp;&emsp;算法一：`本次结果滤波结果 = a * 本次采样值 + (1 - a) * 上次结果`，其中`a`代表滤波系数，取值范围是`0`至`1`。

``` cpp
#define a 128
uchar Value;
​
ucahr OneFactorialFiler() {
    uchar NewValue;
    uchar ReturnValue;
    NewValue = GetAD();
    ReturnValue = ( 255 - a ) * NewValue + a * Value;
    ReturnValue /= 255;
    return ( ReturnValue );
}
```

&emsp;&emsp;算法二代码如下：

``` cpp
#define Thre_value 10 /* 比较门槛值 */
#define N 50 /* 数组长度 */
​
float Or_data[N]; /* 采集的数据 */
unsigned char Dr0_flag = 0, Dr1_flag = 0; /* 前一次比较与当前比较的方向位 */
​
float abs ( float first, float second ) {
    float abs;
​
    if ( first > second ) {
        abs = first - second;
        Dr1_flag = 0;
    } else {
        abs = second - first;
        Dr1_flag = 1;
    }
​
    return ( abs );
}
​
void filter ( void ) {
    uchar i = 0,
          F_count = 0, /* 滤波计数器 */
          coeff = 0; /* 滤波系数 */
    float Abs = 0.00;
​
    for ( i = 1; i < N; i++ ) { /* 确定一阶滤波系数 */
        Abs = abs ( Or_data[i - 1], Or_data[i] );
​
        if ( ! ( Dr1_flag ^ Dr0_flag ) ) { /* 前后数据变化方向一致 */
            F_count++;
​
            if ( Abs >= Thre_value ) {
                F_count++;
                F_count++;
            }
​
            if ( F_count >= 12 ) {
                F_count = 12;
            }
​
            coeff = 20 * F_count;
        } else { /* 去抖动 */
            coeff = 5;
        }
​
        /* 一阶滤波算法 */
        if ( Dr1_flag == 0 ) { /* 当前值小于前一个值 */
            Or_data[i] = Or_data[i - 1] - coeff * ( Or_data[i - 1] - Or_data[i] ) / 256;
        } else {
            Or_data[i] = Or_data[i - 1] + coeff * ( Or_data[i] - Or_data[i - 1] ) / 256;
        }
​
        F_count = 0; /* 滤波计数器清零 */
        Dr0_flag = Dr1_flag;
    }
}
```

### 加权递推平均滤波法

&emsp;&emsp;加权递推平均滤波法是对递推平均滤波法的改进，即不同时刻的数据加以不同的权。通常是越接近现时刻的数据，权取得越大。给予新采样值的权系数越大，则灵敏度越高，但信号的平滑度越低。

``` cpp
#define N 10
#define CoeSum 55
​
const Coefficient[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
uchar Data[N];
​
uchar AAGAFilter() {
    uchar i, Value, sum;
    sum = 0;
    Data[N] = GetAD();
​
    for ( i = 0; i < N; i++ ) {
        Data[i] = Data[i + 1];
        sum += Data[i] * Coefficient[i];
    }
​
    Value = sum / CoeSum;
    return ( Value );
}
```

### 消抖滤波法

&emsp;&emsp;将每次采样值与当前有效值比较，如果采样值等于当前有效值，则计数器清零，否则计数器加`1`。然后，判断计数器是否大于或等于上限`N`(溢出)。如果溢出，将本次值替换当前有效值，并清计数器。

``` cpp
#define N 20
uchar count;
uchar Value;
​
uchar Avoid() {
    uchar NewValue;
​
    if ( NewValue == Value ) {
        count = 0;
    } else {
        count++;
​
        if ( count > N ) {
            count = 0;
            Value = NewValue;
        }
    }
​
    return ( Value );
}
```

&emsp;&emsp;**补充说明**：滑动平均滤波算法(递推平均滤波法)的第二种写法：

``` cpp
int FilterI = 0;
​
/* ADNum为获得的AD数，n为数组value_buf[]的元素个数 */
int GlideFilterAD ( int value_buf[], int n, int ADNum ) {
    int sum = 0;
    int count = 0;
    value_buf[FilterI++] = ADNum;
​
    if ( FilterI == n ) {
        FilterI = 0; /* 先进先出，再求平均值 */
    }
​
    for ( count = 0; count < n; count++ ) {
        sum += value_buf[count];
    }
​
    return ( int ) ( sum / n );
}
```