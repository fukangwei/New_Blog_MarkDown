---
title: 汉诺塔问题
categories: 数据结构和算法
date: 2019-10-03 17:29:30
---
&emsp;&emsp;首先阐述一下自己对递归的理解，`对于我们编写的每个递归函数，都必须能够进行有效的归纳证明`，这是`算法：C语言实现`中让我恍然大悟的一句话。这句话的意思是：根据数学归纳的形式，总是能够倒推出完整的递归形式的。数学归纳法的形式非常清晰，其过程通常为先试验初始条件`n = 1`，验证某假设或公理是否成立，再设`n = k`，假设成立，由`n = k`推出`n = k + 1`的时候，该假设是否成立。具体分析汉诺塔问题，其最原始的思想是：从某根桩移动`N - 1`个盘子到后边桩上，接着以此类推，移动剩下的第`N`个盘到某一个桩，再将那`N - 1`个盘移动到第`N`个盘所在的桩。<!--more-->

``` cpp
#include <stdio.h>
#include <stdlib.h>

#define ALL 6

enum DIRECT {
    left = 1,
    mid = 2,
    right = 3
};

void hanoi ( int N, int pos, int dst );
void shift ( int N, int pos, int direct );

int main ( void ) {
    hanoi ( 4, left, mid );
    return 0;
}

void hanoi ( int N, int pos, int dst ) {
    if ( 0 == N ) {
        return ;
    }

    hanoi ( N - 1, pos, ALL - dst - pos );
    shift ( N, pos, dst );
    hanoi ( N - 1, ALL - dst - pos, dst );
}

void shift ( int N, int pos, int direct ) {
    printf ( "move %d from pillar %d to pillar %d\n", N, pos, direct );
}
```

众所周知，`递归程序总是可以转换成执行相同计算的非递归性程序`，递归到非递归的转换，由堆栈来实现，此处不再赘述。这里让`ALL`为`6`是为了满足互斥的条件，即三根汉诺塔的编号只能是`1`、`2`、`3`中的一个。

---

&emsp;&emsp;算法：当只有一个盘子的时候，只需要从将`A`塔上的一个盘子移到`C`塔上。
&emsp;&emsp;当`A`塔上有两个盘子时，先将`A`塔上的`1`号盘子(编号从上到下)移动到`B`塔上，再将`A`塔上的`2`号盘子移动的`C`塔上，最后将`B`塔上的小盘子移动到`C`塔上。
&emsp;&emsp;当`A`塔上有`3`个盘子时，先将`A`塔上编号`1`至`2`的盘子(共`2`个)移动到`B`塔上(需借助`C`塔)，然后将`A`塔上的`3`号最大的盘子移动到`C`塔，最后将`B`塔上的两个盘子借助`A`塔移动到`C`塔上。
&emsp;&emsp;当`A`塔上有`n`个盘子时，先将`A`塔上编号`1`至`n - 1`的盘子(共`n - 1`个)移动到`B`塔上(借助`C`塔)，然后将`A`塔上最大的`n`号盘子移动到`C`塔上，最后将`B`塔上的`n - 1`个盘子借助`A`塔移动到`C`塔上。
&emsp;&emsp;综上所述，除了只有一个盘子时不需要借助其他塔外，其余情况均一样(只是事件的复杂程度不一样)。

``` cpp
#include <stdio.h>

/* 第一个塔为初始塔，中间的塔为借用塔，最后一个塔为目标塔 */
int i = 1; /* 记录步数 */

void move ( int n, char from, char to ) { /* 将编号为n的盘子由from移动到to */
    printf ( "第%d步: 将%d号盘子%c --> %c\n", i++, n, from, to );
}

/* 将n个盘子由初始塔移动到目标塔(利用借用塔) */
void hanoi ( int n, char from, char denpend_on, char to ) {
    if ( n == 1 ) {
        move ( 1, from, to ); /* 只有一个盘子是直接将初塔上的盘子移动到目的地 */
    } else {
        /* 先将初始塔的前n-1个盘子借助目的塔移动到借用塔上 */
        hanoi ( n - 1, from, to, denpend_on );
        move ( n, from, to ); /* 将剩下的一个盘子移动到目的塔上 */
        /* 最后将借用塔上的n-1个盘子移动到目的塔上 */
        hanoi ( n - 1, denpend_on, from, to );
    }
}

int main ( void ) {
    printf ( "请输入盘子的个数: " );
    int n;
    scanf ( "%d", &n );
    char x = 'A', y = 'B', z = 'C';
    printf ( "盘子移动情况如下:\n" );
    hanoi ( n, x, y, z );
    return 0;
}
```

`Python`的实现如下：

``` python
def hanoi(n, x, y, z):
    if n == 1:
        print(x, "-->", z)  # 直接移到目的地
    else:
        hanoi(n - 1, x, z, y)  # 将前n-1个盘子从x移到y上
        print(x, "-->", z)  # 将最底下的最后一个盘子从x移到z上
        hanoi(n - 1, y, x, z)  # 将y上的n-1个盘子移到z上

n = int(input("请输入汉诺塔的层数："))
hanoi(n, "X", "Y", "Z")
```