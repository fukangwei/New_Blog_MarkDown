---
title: 希尔排序
date: 2019-02-09 00:50:40
categories: 数据结构和算法
---
&emsp;&emsp;希尔排序又称`缩小增量排序`，是`1959`年由`D.L.Shell`提出来的，算法描述为：首先取一个整数`gap < n`(`n`是待排序记录数)作为间隔，将全部记录分为`gap`个子序列，所有距离为`gap`的记录放在同一个子序列中；在每一个子序列中分别施行直接插入排序，然后缩小间隔`gap`，例如取`gap = gap / 2`；重复上述的子序列划分和排序工作，直到最后取`gap = 1`，将所有记录放在同一个序列中排序为止。
&emsp;&emsp;以`n = 10`的一个数组`[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]`为例，第一次`gap = 10 / 2 = 5`：

| 49   | 38   | 65   | 97   | 26   | 13   | 27   | 49   | 55   | 4    |
|------|------|------|------|------|------|------|------|------|------|
| `1A` |      |      |      |      | `1B` |      |      |      |      |
|      | `2A` |      |      |      |      | `2B` |      |      |      |
|      |      | `3A` |      |      |      |      | `3B` |      |      |
|      |      |      | `4A` |      |      |      |      | `4B` |      |
|      |      |      |      | `5A` |      |      |      |      | `5B` |

`[1A, 1B]`、`[2A, 2B]`等为分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素。一共分成了五组，即`(49, 13)`、`(38, 27)`、`(65, 49)`、`(97, 55)`和`(26, 4)`。每次对同一组的数据进行直接插入排序，这样每组排序后就变成了`(13, 49)`、`(27, 38)`、`(49, 65)`、`(55, 97)`和`(4, 26)`。
&emsp;&emsp;第二次`gap = 5/2 = 2`，排序后如下：

| 13   | 27   | 49   | 55   | 4    | 49   | 38   | 65   | 97   | 26   |
|------|------|------|------|------|------|------|------|------|------|
| `1A` |      | `1B` |      | `1C` |      | `1D` |      | `1E` |      |
|      | `2A` |      | `2B` |      | `2C` |      | `2D` |      | `2E` |

&emsp;&emsp;第三次`gap = 2/2 = 1`，排序后如下：

4    | 26   | 13   | 27   | 38   | 49   | 49   | 55   | 97   | 65
-----|------|------|------|------|------|------|------|------|---
`1A` | `1B` | `1C` | `1D` | `1E` | `1F` | `1G` | `1H` | `1I` | `1J`

&emsp;&emsp;第四次`gap = 1/2 = 0`，排序完成得到数组如下：

4  | 13 | 26 | 27 | 38 | 49 | 49 | 55 | 65 | 97
---|----|----|----|----|----|----|----|----|---

代码如下：

``` cpp
void shellsort ( int v[], int n ) {
    int gap, i, j, temp;
​
    for ( gap = n / 2; gap > 0; gap /= 2 )
        for ( i = gap; i < n; i++ )
            for ( j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap ) {
                temp = v[j];
                v[j] = v[j + gap];
                v[j + gap] = temp;
            }
}
```