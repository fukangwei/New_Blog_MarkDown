---
title: 单链表
categories: 数据结构和算法
abbrlink: 71c610d3
date: 2019-02-09 12:16:10
---
&emsp;&emsp;基本操作如下：

``` cpp
#include<stdio.h>
#include<stdlib.h>
​
#define ERROR 0
#define OK    1
​
typedef int status;
typedef int ElemType;
​
typedef struct Node {
    ElemType data;
    struct Node *next;
} LNode, *LinkList;
​
void Build ( LinkList L ) { /* 建立一个带头结点的单链表 */
    int n;
    LinkList p, q;
    p = L;
    printf ( "请输入n和n个数据元素:\n" );
    scanf ( "%d", &n );
​
    while ( n-- ) {
        q = ( LinkList ) malloc ( sizeof ( LNode ) );
        scanf ( "%d", &q->data );
        q->next = NULL;
        p->next = q;
        p = q;
    }
}
​
void Print ( LinkList L ) { /* 计算单链表的长度，然后输出单链表 */
    int num = 0;
    LinkList p;
    p = L->next;
​
    while ( p ) {
        num++;
        printf ( "%d ", p->data );
        p = p->next;
    }
​
    printf ( "\n长度为%d:\n", num );
}
​
void Tips() {
    printf ( "按数字键选择相应操作\n" );
    printf ( "<1> 输出单链表及其长度:\n" );
    printf ( "<2> 查找值为x的直接前驱结点:\n" );
    printf ( "<3> 删除值为x的结点:\n" );
    printf ( "<4> 将表中元素逆置:\n" );
    printf ( "<5> 删除表中所有值大于mink且小于maxk的元素:\n" );
    printf ( "<6> 删除表中所有值相同的多余元素:\n" );
    printf ( "<7> 分解成两个链表:\n" );
    printf ( "<8> 在升序链表插入值为X的结点，使仍然有序:\n" );
    printf ( "<9> 按升序排列:\n" );
    printf ( "<0> 退出:\n" );
}
​
void Find ( LinkList L, int x ) { /* 查找值为x的直接前驱结点q */
    LinkList p;
    p = L;
​
    while ( p->next && p->next->data != x ) {
        p = p->next;
    }
​
    if ( p->next ) {
        printf ( "%d的前驱结点为:%d\n\n", x, p->data );
    }
    else {
        printf ( "没找到!!\n\n" );
    }
}
​
void Delete ( LinkList L, int x ) { /* 删除值为x的结点 */
    LinkList p, q;
    p = L;
​
    while ( p->next && p->next->data != x ) {
        p = p->next;
    }
​
    if ( p->next ) {
        q = p->next;
        p->next = q->next;
        free ( q );
        printf ( "删除成功!!\n\n" );
    }
    else {
        printf ( "链表中没有%d\n\n", x );
    }
}
​
void NiZhi ( LinkList L ) { /* 把单向链表中元素逆置，类似于头插法建立链表 */
    LinkList p, s;
    p = s = L->next;
    L->next = NULL;
​
    while ( p ) {
        s = s->next;
        p->next = L->next;
        L->next = p;
        p = s;
    }
​
    printf ( "逆置成功!!!\n\n" );
}
​
void Delete1 ( LinkList L ) { /* 删除表中所有值大于mink且小于maxk的元素(有序表) */
    int maxk, mink;
    LinkList p, q, s;
    printf ( "请输入mink,maxk:\n" );
    scanf ( "%d %d", &mink, &maxk );
    p = L;
​
    while ( p->next && p->next->data <= mink ) {
        p = p->next;
    }
​
    s = p->next;
​
    while ( s && s->data < maxk ) {
        q = s;
        s = s->next;
        free ( q );
    }
​
    p->next = s;
    printf ( "删除成功\n\n" );
}
​
/* 删除表中所有值相同的多余元素(使得操作后的线性表中所有元素的值均不相同)(有序表) */
void Delete2 ( LinkList L ) {
    LinkList p, q, s;
    p = L;
    q = L->next;
​
    while ( q->next ) {
        if ( q->data == q->next->data ) {
            p->next = q->next;
            s = q;
            q = q->next;
            free ( s );
        }
        else {
            p = p->next;
            q = q->next;
        }
    }
​
    printf ( "删除成功!!!!\n" );
}
​
/* 利用(1)建立的链表，实现将其分解成两个链表，其中一个全部为奇数，另一个全部为偶数 */
void fenjie ( LinkList L ) {
    LinkList s, p, Lb, cur1, cur2;
    Lb = ( LinkList ) malloc ( sizeof ( LNode ) );
    Lb->next = NULL;
    s = L->next;
    L->next = NULL;
    cur1 = L;
    cur2 = Lb;
​
    while ( s ) {
        p = s;
        s = s->next;
        p->next = NULL;
​
        if ( p->data & 1 ) { /* 判断奇数还是偶数 */
            cur1->next = p;
            cur1 = cur1->next;
        }
        else {
            cur2->next = p;
            cur2 = cur2->next;
        }
    }
​
    cur1 = L->next;
    cur2 = Lb->next;
    printf ( "元素为奇数的链表:\n" );
​
    while ( cur1 ) {
        printf ( "%d ", cur1->data );
        cur1 = cur1->next;
    }
​
    printf ( "\n元素为偶数的链表:\n" );
​
    while ( cur2 ) {
        printf ( "%d ", cur2->data );
        cur2 = cur2->next;
    }
​
    printf ( "\n\n" );
}
​
/* 在升序链表插入值为X的结点，使仍然有序 */
void Insert ( LinkList L, LinkList p ) {
    LinkList s;
    s = L;
​
    while ( s->next && s->next->data < p->data ) {
        s = s->next;
    }
​
    p->next = s->next;
    s->next = p;
}
​
status Sort ( LinkList L ) { /* 按升序排列 */
    LinkList s, r;
    s = L->next;
    L->next = NULL;
​
    while ( s ) {
        r = s;
        s = s->next;
        r->next = NULL;
        Insert ( L, r );
    }
​
    return OK;
}
​
int main() {
    int op, x, flag;
    LinkList L, p;
    L = ( LinkList ) malloc ( sizeof ( LNode ) );
    L->next = NULL;
    L->data = -1;
    Build ( L );
    Tips();
    scanf ( "%d", &op );
​
    while ( op ) {
        switch ( op ) {
            case 1: Print ( L ); break;
            case 2:
                printf ( "请输入要查找的元素X:\n" );
                scanf ( "%d", &x );
                Find ( L, x );
                break;
            case 3:
                printf ( "请输入要查找的删除X:\n" );
                scanf ( "%d", &x );
                Delete ( L, x );
                break;
            case 4: NiZhi ( L ); break;
            case 5: Delete1 ( L ); break;
            case 6: Delete2 ( L ); break;
            case 7: fenjie ( L ); break;
            case 8:
                printf ( "请输入要插入的元素X:\n" );
                scanf ( "%d", &x );
                p = ( LinkList ) malloc ( sizeof ( LNode ) );
                p->data = x;
                Insert ( L, p );
                printf ( "插入成功!!!\n\n" );
                break;
            case 9:
                flag = Sort ( L );
​
                if ( flag ) {
                    printf ( "排序成功!!\n" );
                }
​
                break;
        }
​
        Tips();
        scanf ( "%d", &op );
    }
​
    return 0;
}
```

&emsp;&emsp;反转链表的递归方法：

``` cpp
typedef struct node LinkNode;
​
struct node {
    int data;
    LinkNode *next;
};
​
LinkNode *reverse_link_recursive ( LinkNode *head ) {
    if ( head == NULL ) {
        return NULL;
    }
​
    LinkNode *curr, *reverse_head, *temp;
​
    if ( head->next == NULL ) { /* 链表中只有一个节点，逆转后的头指针不变 */
        return head;
    } else {
        curr = head;
        temp = head->next; /* temp为(a2,...,an)的头指针 */
        /* 逆转链表(a2,...,an)，并返回逆转后的头指针 */
        reverse_head = reverse_link_recursive ( temp );
        temp->next = curr; /* 将a1链接在a2之后 */
        curr->next = NULL;
    }
​
    return reverse_head; /* (a2,...,an)逆转链表的头指针即为(a1,a2,...,an)逆转链表的头指针 */
}
```

&emsp;&emsp;输入一个单向链表，输出该链表中倒数第`k`个结点，链表的倒数第`0`个结点为链表的尾指针：

``` cpp
struct ListNode {
    int m_nKey;
    ListNode *m_pNext;
};
​
Node *lastK ( Node *head, int k ) {
    if ( k < 0 ) {
        error ( "k < 0" );
    }
​
    Node *p = head, *pk = head;
​
    for ( ; k > 0; k-- ) {
        if ( pk->next != NULL ) {
            pk = pk->next;
        } else {
            return NULL;
        }
    }
​
    while ( pk->next != NULL ) {
        p = p->next, pk = pk->next;
    }
​
    return p;
}
```

&emsp;&emsp;从一个链表中删除在另一个链表中的元素：

``` cpp
#include <iostream>
​
using namespace std;
​
struct Node {
    char data;
    Node *next;
};
​
Node *create() {
    Node *head = NULL;
    Node *rear = head;
    Node *p; /* The pointer points to new created node */
    char tmp;
​
    do {
        cout << "Please input integer or char '#':";
        cin >> tmp;
​
        if (tmp != '#') {
            p = new Node;
            p->data = tmp;
            p->next = NULL;
​
            if (head == NULL) {
                head = p;
            }
            else {
                rear->next = p;
            }
​
            rear = p;
        }
    } while (tmp != '#');
​
    return head;
}
​
void print(Node *head) {
    Node *p = head;
​
    if (head != NULL) {
        do {
            cout << p->data << ' ';
            p = p->next;
        } while (p != NULL);
    }
​
    cout << endl;
}
​
Node *del(Node *l1, Node *l2) {
    if (!l1 || !l2) {
        return NULL;
    }
​
    Node *p = new Node;
    p->next = l1;
    Node *pL1 = l1, *pL2 = l2, *head = p;
​
    while (pL1 && pL2) {
        if (pL1->data < pL2->data) {
            pL1 = pL1->next;
            p = p->next;
        }
        else if (pL1->data > pL2->data) {
            pL2 = pL2->next;
        }
        else {
            pL1 = pL1->next;
            p->next = pL1;
        }
    }
​
    l1 = head->next;
    return l1;
}
​
int main() {
    cout << "Please input the first list:" << endl;
    Node *l1 = create();
    cout << endl << "Please input the second list:" << endl;
    Node *l2 = create();
    cout << endl << "--------------------------" << endl;
    cout << "The first list is: ";
    print(l1);
    cout << "The second list is: ";
    print(l2);
    Node *l = del(l1, l2);
    cout << endl << "The result list is: ";
    print(l);
    system("pause");
    return 0;
}
```

&emsp;&emsp;从尾到头输出链表：

``` cpp
#include <stdio.h>
#include <stdlib.h>
​
typedef int ElemType;
​
typedef struct Node {
    ElemType data;
    struct Node *next;
} Node, *pNode;
​
/* 递归从尾到头打印单链表 */
void PrintListReverse(pNode pHead) {
    if (pHead == NULL) {
        return;
    }
​
    if (pHead->next != NULL) {
        PrintListReverse(pHead->next);
    }
​
    printf("%d ", pHead->data);
}
​
pNode CreateList() {
    ElemType val;
    pNode pHead = NULL;
    pNode pCur = NULL;
​
    do {
        scanf_s("%d", &val);
​
        if (val != -1) {
            pNode pNew = (pNode)malloc(sizeof(Node));
​
            if (pNew == NULL) {
                exit(EXIT_FAILURE);
            }
​
            pNew->data = val;
            pNew->next = NULL;
​
            if (pHead == NULL) {
                pHead = pNew;
                pCur = pHead;
            }
            else {
                pCur->next = pNew;
                pCur = pCur->next;
            }
        }
    } while (val != -1);
​
    return pHead;
}
​
void DestroyList(pNode pHead) {
    if (pHead == NULL) {
        return;
    }
​
    pNode p = NULL;
​
    while (pHead != NULL) {
        p = pHead->next;
        free(pHead);
        pHead = p;
    }
}
​
int main() {
    pNode pHead = CreateList();
    PrintListReverse(pHead);
    DestroyList(pHead);
    system("pause");
    return 0;
}
```