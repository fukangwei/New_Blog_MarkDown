---
title: C语言内存对齐
categories: C语言语法详解
date: 2018-12-09 19:55:55
---
### 对齐原因

&emsp;&emsp;内存对齐原因主要有以下`2`个：<!--more-->

1. 移植：不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据，否则会抛出硬件异常。
2. 性能：数据结构(尤其是`栈`)应该尽可能地在自然边界上对齐。为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅需要作一次访问。

### 代码实例

&emsp;&emsp;有如下代码：

``` cpp
#include <stdio.h>

struct A {
    char a;
    int b;
    short c;
};

struct B {
    short c;
    char a;
    int b;
};

int main() {
    printf ( "sizeof(A) is %ld\n", sizeof ( A ) );
    printf ( "sizeof(B) is %ld\n", sizeof ( B ) );
    return 0;
}
```

结构体`A`和`B`成员变量类型相同，但是占用的内存空间大小却不一样：

``` cpp
sizeof(A) is 12
sizeof(B) is 8
```

### 对齐规则

&emsp;&emsp;内存对齐的`3`大规则如下：

1. 对于结构体的各个成员，第一个成员的偏移量是`0`，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍。
2. 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。
3. 如果程序中有`#pragma pack(n)`预编译指令，则所有成员对齐以`n`字节为准，即偏移量是`n`的整数倍，不再考虑当前类型以及最大结构体内类型。

&emsp;&emsp;以结构体`A`为例：

- 成员`a`是`char`型，占用`1`个字节，偏移量为`0`。
- 成员`b`是`int`型，占用`4`个字节。按照规则`1`，`b`的偏移量必须是`int`型的整数倍，所以编译器会在`a`后面插入`3`字节空白。
- 成员`c`为`short`型，此时`c`的偏移量正好是`4 + 4 = 8`个字节，已经是`short`型的整数倍，所以`b`与`c`之间不用填充缓冲字节。
- 结构体`A`的大小理应为`8 + 2 = 10`个字节，但按照规则`2`，`A`的大小必须是其最大成员类型`int`的整数倍，所以再填充`2`个字节，即结构体`A`大小为`12`字节。

### 包含union类型

&emsp;&emsp;代码如下：

``` cpp
struct BU {
    int number; /* 占4字节空间 */
    union UBffer {
        char buffer[13]; /* 填充3字节，该成员占16字节空间 */
        int number;
    } ubuf;
    int aa; /* 占4字节空间，当前偏移量已补齐为20 */
    double dou; /* 占8字节空间 */
} bu;
```

结构体`BU`的大小为`4 + 13 + 3(补齐) + 4 + 8 = 32`。
&emsp;&emsp;计算`union`成员的偏移量时，需要根据`union`内部最大成员类型来进行缓冲补齐。

### \#pragma pack(1)

&emsp;&emsp;`#pragma pack(1)`使结构体按`1`字节方式对齐：

``` cpp
struct sample {
    char a;
    double b;
};
```

结构体大小是所有成员的类型大小的和，即结构体`sample`的大小为`9`。