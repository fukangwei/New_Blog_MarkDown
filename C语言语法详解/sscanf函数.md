---
title: sscanf函数
date: 2018-12-15 18:11:10
categories: C语言语法详解
---
### sscanf函数

&emsp;&emsp;`sscanf`的作用是从一个字符串中读进与指定格式相符的数据：

``` cpp
int sscanf ( string str, string fmt, mixed var1, mixed var2 ... );
```

fmt可以是一个或多个`{ %[*] [width] [{h | l | I64 | L}]type | ' ' | '\t' | '\n' | 非%符号 }`。注意以下几点：

- `*`亦可用于格式中，例如`%*d`和`%*s`，加了星号表示跳过此数据不读入(也就是不把此数据读入参数中)。
- `{a | b | c}`表示`a`、`b`、`c`中选一，`[d]`表示可以有`d`也可以没有`d`。
- width表示读取宽度。
- `{h | I | I64 | L}`：参数的`size`，通常`h`表示单字节`size`，`I`表示`2`字节`size`，`L`表示`4`字节`size`(`double`例外)，`I64`表示`8`字节`size`。
- `type`：这就很多了，就是`%s`、`%d`之类的。
- 特别的，`%*[width] [{h | l | I64 | L}]type`表示满足该条件的被过滤掉，不会向目标参数中写入值。
- 空字符集`%[]`是违反规定的，可导致不可预知的结果。`%[^]`也是违反规定的。

`sscanf`支持集合操作：

- `%[a-z]`：表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)。
- `%[aB']`：匹配`a`、`B`、`'`中的一员，贪婪性。
- `%[^a]`：匹配非`a`的任意字符，贪婪性。

&emsp;&emsp;1. 常见用法：

``` cpp
char buf[512] = {0};
sscanf ( "123456 ", "%s", buf );
printf ( "%s\n", buf ); /* 输出“123456” */
```

&emsp;&emsp;2. 取指定长度的字符串。下例取最大长度为`4`字节的字符串：

``` cpp
sscanf ( "123456 ", "%4s", buf );
printf ( "%s\n", buf ); /* 输出“1234” */
```

&emsp;&emsp;3. 取到指定字符为止的字符串。下例取遇到空格为止的字符串：

``` cpp
sscanf ( "123456 abcdedf", "%[^ ]", buf );
printf ( "%s\n", buf ); /* 输出“123456” */
```

&emsp;&emsp;4. 取仅包含指定字符集的字符串。下例取仅包含`1`到`9`和小写字母的字符串：

``` cpp
sscanf ( "123456abcdedfBCDEF", "%[1-9a-z]", buf );
printf ( "%s\n", buf ); /* 输出“123456abcdedf” */
```

&emsp;&emsp;5. 取到指定字符集为止的字符串。下例取遇到大写字母为止的字符串：

``` cpp
sscanf ( "123456abcdedfBCDEF", "%[^A-Z]", buf );
printf ( "%s\n", buf ); /* 输出“123456abcdedf” */
```

&emsp;&emsp;6. 给定一个字符串`iios/12DDWDFF@122`，获取`/`和`@`之间的字符串，先将`iios/`过滤掉，再将非`@`的一串内容送到buf中：

``` cpp
sscanf ( "iios/12DDWDFF@122", "%*[^/]/%[^@]", buf );
printf ( "%s\n", buf ); /* 输出“12DDWDFF” */
```

&emsp;&emsp;7. 给定一个字符串`hello, world`，仅保留`world`(注意`,`之后有一空格，`%s`遇空格停止，加上`*`则忽略第一个读到的字符串)：

``` cpp
sscanf ( "hello, world", "%*s%s", buf );
printf ( "%s\n", buf ); /* 输出“world” */
```

`%*s`表示第一个匹配到的`%s`被过滤掉，即`hello,`被过滤了。如果没有空格，则结果为`NULL`。
&emsp;&emsp;`sscanf`的功能很类似于正则表达式，但却没有正则表达式强大。所以如果对于比较复杂的字符串处理，建议使用正则表达式。
&emsp;&emsp;以前用它来分隔类似这样的字符串`2006:03:18`：

``` cpp
int a, b, c;
sscanf ( "2006:03:18", "%d:%d:%d", a, b, c );
```

以及`2006:03:18 - 2006:04:18`：

``` cpp
char sztime1[16] = "", sztime2[16] = "";
sscanf ( "2006:03:18 - 2006:04:18", "%s - %s", sztime1, sztime2 );
```

但是后来需要处理`2006:03:18-2006:04:18`，仅仅是取消了`-`两边的空格，却打破了`%s`对字符串的界定。`format-type`中有`%[]`这样的`type field`，如果读取的字符串不是以空格来分隔的话，就可以使用`%[]`：

``` cpp
sscanf ( "2006:03:18 - 2006:04:18", "%[0-9,:] - %[0-9,:]", sztime1, sztime2 ); /* 逗号表示“0-9”和“:” */
```

&emsp;&emsp;在`sscanf ( stringBuf.c_str(), "%20[^#]#%20[^ ]", ... );`语句中，`%20[^#]`表示读取`20`个字节的字符串，出现`#`号时结束。所以，`%20[^#]#%20[^ ]`的意义就是，读取两个`20`字节大小的字符串，第一个字符串可以用`#`结束，第二个字符串可以用`回车符`(或`空格`)结束。