---
title: C89和C99标准比较
categories: C语言语法详解
date: 2018-12-10 11:53:22
---
&emsp;&emsp;`GCC`支持`C99`，通过`--std=c99`命令行参数开启：<!--more-->

``` bash
gcc --std=c99 test.c
```

&emsp;&emsp;`C99`是在`C89`的基础上发展起来的，增加了基本数据类型、关键字和一些系统函数等。`C99`有一部分是对于大字符集的优化(很多资料上写的是`ANSI`标准化)，还加入了一些数据库函数。`C99`包括的特性有：

- 对编译器限制增加了，比如源程序每行要求至少支持到`4095`字节，变量名函数名的要求支持到`63`字节(`extern`要求支持到`31`)。
- 预处理增强了，例如宏支持取参数`#define Macro(...) __VA_ARGS__`。使用宏的时候，参数如果不写，宏里用`#`、`##`这样的东西会扩展成空串(以前会出错的)。
- 支持`//`行注释(这个特性实际上在`C89`的很多编译器上已经被支持了)。
- 增加了新关键字`restrict`、`inline`、`_Complex`、`_Imaginary`、`_Bool`；支持`long long`、`long double _Complex`、`float _Complex`这样的类型。
- 支持了不定长的数组。数组的长度就可以用变量了。声明类型的时候呢，就用`int a[*]`这样的写法。不过考虑到效率和实现，这个并不是一个新类型，所以就不能用在全局里，或者`struct`、`union`里面。如果你用了这样的东西，`goto`语句就受限制了。
- 变量声明不必放在语句块的开头，`for`语句提倡这么写：`for ( int i = 0; i < 100; ++i )`。就是说，`int i`的声明放在里面，`i`只在`for`里面有效。
- 当一个类似结构的东西需要临时构造的时候，可以用`(type_name){ .numberN=valueN, .numberK=valueK, ...}`，这有点像`C++`的构造函数。初始化结构的时候现在可以这样写：

``` cpp
struct {
    int a[3], b;
} hehe[] = { [0].a = {1}, [1].a = 2 };

struct {
    int a, b, c, d; /* 3、4是对“.c”、“.d”赋值的 */
} hehe = { .a = 1, .c = 3, 4, .b = 5};
```

- 字符串里面，`\u`支持`unicode`的字符。
- `printf`、`scanf`的格式化支持了`ll/LL`对应新的`long long`类型。
- 浮点数的内部数据描述支持了新标准，这个可以用`#pragma`编译器指定。
- 除了已经有的`__LINE__`、`__FILE__`以外，又支持了一个`__FUNC__`，可以得到当前的函数名。
- 对于非常数的表达式，也允许编译器做化简。修改了对于`/`、`%`处理负数上的定义，比如老的标准里`-22 / 7 = -3`、`-22 % 7 = -1`，而现在`-22 / 7 = -4`、`-22 % 7 = 6`。
- 取消了不写函数返回类型默认就是`int`的规定。
- 允许`struct`定义的最后一个数组写做`[]`，不指定其长度描述。
- `const const int i;`将被当作`const int i;`处理。
- 增加和修改了一些标准头文件，比如定义`bool`的、定义一些标准长度的`int`的、定义复数的、定义宽字符的、有点泛型味道的、数学函数跟浮点数有关的；多了一个`va_copy`可以复制`...`的参数；多了个`struct tmx`，对`struct tm`做了扩展。
- 输入输出对宽字符还有长整数等做了相应的支持。

### 增加restrict指针

&emsp;&emsp;`C99`中增加了适用于指针的`restrict`类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助`restrict`指针表达式才能访问对象。`restrict`指针主要用做函数变元，或者指向由`malloc`函数所分配的内存变量。`restrict`数据类型不改变程序的语义。如果某个函数定义了两个`restrict`指针变元，编译程序就假定它们指向两个不同的对象，`memcpy`函数就是`restrict`指针的一个典型应用示例。`C89`中`memcpy`函数原型如下：

``` cpp
void* memcpy ( void* s1, const void* s2, size_t size );
```

如果`s1`和`s2`所指向的对象重叠，其操作就是未定义的，`memcpy`函数只能用于不重叠的对象。`C99`中`memcpy`函数原型如下：

``` cpp
void* memcpy ( void* restrict s1, const void* restrict s2, size_t size );
```

通过使用`restrict`修饰`s1`和`s2`变元，可确保它们在该原型中指向不同的对象。

### inline(内联)关键字

&emsp;&emsp;内联函数除了保持结构化和函数式的定义方式外，还能使程序员写出高效率的代码。函数的每次调用与返回都会消耗相当大的系统资源，尤其是当函数调用发生在重复次数很多的循环语句中时。一般情况下，当发生一次函数调用时，变元需要进栈，各种寄存器内存需要保存。当函数返回时，寄存器的内容需要恢复。如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作不会再发生，而且函数调用的执行速度也会大大加快。函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数。

### 新增数据类型

- `_Bool`：值是`0`或`1`。`C99`中增加了用来定义`bool`、`true`以及`false`宏的头文件夹`stdbool.h`，以便程序员能够编写同时兼容于`C`与`C++`的应用程序。在编写新的应用程序时，应该使用`stdbool.h`头文件中的`bool`宏。
- `_Complex`和`_Imaginary`：`C99`标准中定义的复数类型如下：`float_Complex`、`float_Imaginary`、`double_Complex`、`double_Imaginary`、`long double_Complex`、`long double_Imaginary`。`complex.h`头文件中定义了`complex`和`imaginary`宏，并将它们扩展为`_Complex`和`_Imaginary`，因此在编写新的应用程序时，应该使用`stdbool.h`头文件中的`complex`和`imaginary`宏。
- `long long int`：`C99`标准中引进了`long long int`(`-(2^63 - 1)`至`2^63 - 1`)和`unsigned long long int`(`0`至`2^64 - 1`)。`long long int`能够支持的整数长度为`64`位。

### 对数组的增强

&emsp;&emsp;`可变长数组`：`C99`中，程序员声明数组时，数组的维数可以由任一有效的整型表达式确定，包括只在运行时才能确定其值的表达式，这类数组就叫做`可变长数组`，但是只有局部数组才可以是变长的。可变长数组的维数在数组生存期内是不变的，也就是说，可变长数组不是动态的，可以变化的只是数组的大小。可以使用`*`来定义不确定长的可变长数组。
&emsp;&emsp;数组声明中的类型修饰符：在`C99`中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用`static`关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用`restrict`、`volatile`、`const`关键字，但只用于函数变元。如果使用`restrict`，指针是初始访问该对象的惟一途径。如果使用`const`，指针始终指向同一个数组，使用`volatile`没有任何意义。

### 预处理程序的修改

&emsp;&emsp;`元列表`：宏可以带变元，在宏定义中用省略号表示。内部预处理标识符`__VA_ARGS__`决定变元将在何处得到替换。例如`#define MySum(...) sum(__VA_ARGS__)`，语句`MySum(k, m, n);`将被转换成`sum(k, m, n);`。变元还可以包含变元，例如`#define compare(compf, ...) compf(__VA_ARGS__)`，其中的`compare(strcmp, "small", "large");`将替换成`strcmp("small", "large");`。
&emsp;&emsp;`_Pragma运算符`：它是`C99`引入的在程序中定义编译指令的另外一种方法。格式如下：

``` cpp
_Pragma ( "directive" )
```

其中`directive`是要满打满算的编译指令。`_Pragma`运算符允许编译指令参与宏替换。
&emsp;&emsp;`内部编译指令`：`STDCFP_CONTRACT ON/OFF/DEFAULT`若为`ON`，浮点表达式被当做基于硬件方式处理的独立单元，默认值是定义的工具；`STDCFEVN_ACCESS ON/OFF/DEFAULT`告诉编译程序可以访问浮点环境，默认值是定义的工具；`STDC CX_LIMITED_RANGE ON/OFF/DEFAULT`若值为`ON`，相当于告诉编译程序某程序某些含有复数的公式是可靠的，默认是`OFF`。
&emsp;&emsp;新增的内部宏：

- `__STDC_HOSTED__`：若操作系统存在，则为`1`。
- `__STDC_VERSION__`：`199991L`或更高，代表`C`的版本。
- `__STDC_IEC_599__`：若支持`IEC 60559`浮点运算，则为`1`。
- `__STDC_IEC_599_COMPLEX__`：若支持`IEC 60599`复数运算，则为`1`。
- `__STDC_ISO_10646__`：由编译程序支持，用于说明`ISO/IEC 10646`标准的年和月格式`yyymmmL`。

### for语句内的变量声明

&emsp;&emsp;`C99`中，程序员可以在`for`语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本`for`语句所控制的循环体内。比如下面的代码：

``` cpp
for ( int i = 0; i < 10; i++ ) {
    /* do someting */
}
```

### 复合赋值

&emsp;&emsp;`C99`的复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。
&emsp;&emsp;例如`double *fp = (double[]) {1.1, 2.2, 3.3};`，该语句用于建立一个指向`double`的指针`fp`，且该指针指向这个`3`元素数组的第一个元素。在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。

### 柔性数组结构成员

&emsp;&emsp;`C99`中，结构中的最后一个元素允许是未知大小的数组，这就叫做`柔性数组成员`，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。`sizeof`返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用`malloc`函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

### 指定的初始化符

&emsp;&emsp;`C99`中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：`[index] = vol;`，其中`index`表示数组的下标，`vol`表示本数组元素的初始化值。例如`int x[10] = {[0] = 10, [5] = 30};`，其中只有`x[0]`和`x[5]`得到了初始化。用于结构或联合的格式如下：

``` cpp
member-name(成员名称)
```

对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。例如`struct example{ int k, m, n; } object = {m = 10, n = 200};`，其中没有初始化`k`。对结构成员进行初始化的顺序没有限制。

### printf和scanf函数系列的增强

&emsp;&emsp;`C99`中`printf`和`scanf`函数系列引进了处理`long long int`和`unsigned long long int`数据类型的特性。`long long int`类型的格式修饰符是`ll`。在`printf`和`scanf`函数中，`ll`适用于`d`、`i`、`o`、`u`和`x`格式说明符。另外，`C99`还引进了`hh`修饰符。当使用`d`、`i`、`o`、`u`和`x`格式说明符时，`hh`用于指定`char`型变元。`ll`和`hh`修饰符均可以用于`n`说明符。
&emsp;&emsp;格式修饰符`a`和`A`用在`printf`函数中时，结果将会输出十六进制的浮点数，格式为`[-]0xh, hhhhp + d`。使用`A`格式修饰符时，`x`和`p`必须是大写。`A`和`a`格式修饰符也可以用在`scanf`函数中，用于读取浮点数。调用`printf`函数时，允许在`%f`说明符前加上`l`修饰符，即`%lf`，但不起作用。

### C99新增的库

&emsp;&emsp;C89中标准的头文件：

- `assert.h`：定义宏`assert`。
- `ctype.h`：字符处理。
- `errno.h`：错误报告。
- `float.h`：定义与实现相关的浮点值勤。
- `limits.h`：定义与实现相关的各种极限值。
- `locale.h`：支持函数`setlocale`。
- `math.h`：数学函数库使用的各种定义。
- `setjmp.h`：支持非局部跳转。
- `signal.h`：定义信号值。
- `stdarg.h`：支持可变长度的变元列表。
- `stddef.h`：定义常用常数。
- `stdio.h`：支持文件输入和输出。
- `stdlib.h`：其他各种声明。
- `string.h`：支持串函数。
- `time.h`：支持系统时间函数。

&emsp;&emsp;`C99`新增的头文件和库：

- `complex.h`：支持复数算法。
- `fenv.h`：给出对浮点状态标记和浮点环境的其他方面的访问。
- `inttypes.h`：定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数。
- `iso646.h`：用于定义对应各种运算符的宏。
- `stdbool.h`：支持布尔数据类型类型。定义宏`bool`，以便兼容于`C++`。
- `stdint.h`：定义标准的、可移植的整型类型集合。该文件包含在`inttypes.h`中。
- `tgmath.h`：定义一般类型的浮点宏。
- `wchar.h`：用于支持多字节和宽字节函数。
- `wctype.h`：用于支持多字节和宽字节分类函数。

### 其它特性的改动

&emsp;&emsp;放宽的转换限制：

限制                     | C89标准 | C99标准
-------------------------|---------|--------
数据块的嵌套层数          | `15`    | `127`
条件语句的嵌套层数        | `8`     | `63`
内部标识符中的有效字符个数 | `31`    | `63`
外部标识符中的有效字符个数 | `6`     | `31`
结构或联合中的成员个数     | `127`   | `1023`
函数调用中的参数个数       | `31`    | `127`

不再支持隐含式的`int`规则；删除了隐含式函数声明；对返回值的约束：`C99`中，非空类型函数必须使用带返回值的`return`语句。

### 扩展的整数类型

扩展类型        | 含义
----------------|----------
`int16_t`       | 整数长度为精确`16`位
`int_least16_t` | 整数长度为至少`16`位
`int_fast32_t`  | 最稳固的整数类型，其长度为至少`32`位
`intmax_t`      | 最大整数类型
`uintmax_t`     | 最大无符号整数类型

&emsp;&emsp;对整数类型提升规则的改进：`C89`中，表达式中类型为`char`、`short int`或`int`的值可以提升为`int`或`unsigned int`类型；`C99`中，每种整数类型都有一个级别，例如`long long int`的级别高于`int`，`int`的级别高于`char`等。在表达式中，其级别低于`int`或`unsigned int`的任何整数类型均可被替换成`int`或`unsigned int`类型。