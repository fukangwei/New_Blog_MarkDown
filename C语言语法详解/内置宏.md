---
title: 内置宏
categories: C语言语法详解
date: 2018-12-12 07:29:58
---
&emsp;&emsp;`ANSI`标准`C`还定义了如下几个宏：<!--more-->

- `_LINE_`：表示正在编译的文件的行号。
- `_FILE_`：表示正在编译的文件的名字。
- `_DATE_`：表示编译时刻的日期字符串，例如`25 Dec 2007`。
- `_TIME_`：表示编译时刻的时间字符串，例如`12:30:55`。
- `_STDC_`：判断该文件是不是定义成标准`C`程序。

&emsp;&emsp;产品线区分及调试代码应用：

``` cpp
#include <stdio.h>

#ifdef DEBUG
#define LOG(s) printf( "[%s:%d] %s\n", __FILE__, __LINE__, s )
#else
#define LOG(s) NULL
#endif

#ifdef HIGH
void f() {
    printf ( "This is the high level product!\n" );
}
#else
void f() {
}
#endif

int main ( void ) {
    LOG ( "Enter main() ..." );
    f();
    printf ( "1. Query Information.\n" );
    printf ( "2. Record Information.\n" );
    printf ( "3. Delete Information.\n" );
#ifdef HIGH
    printf ( "4. High Level Query.\n" );
    printf ( "5. Mannul Service.\n" );
    printf ( "6. Exit.\n" );
#else
    printf ( "4. Exit.\n" );
#endif
    LOG ( "Exit main() ..." );
    return 0;
}
```

&emsp;&emsp;如果需要编译`mini`版，则使用命令`gcc -DDEBUG test.c`；如果需要编译高级版，命令为`gcc -DHIGH test.c`；如果需要高级版中的`debug`版，命令为`gcc -DDEBUG -DHIGH test.c`。这样有利于我们调试程序，分析问题。

### #error预处理

&emsp;&emsp;`#error`预处理指令的作用是：编译程序时，只要遇到`#error`，就会生成一个编译错误提示消息并停止编译，其语法格式为：

``` cpp
#error error-message
```

注意，宏串`error-message`不用双引号包围。遇到`#error`指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。示例如下：

``` cpp
#include "stdio.h"

int main ( int argc, char* argv[] ) {
#define CONST_NAME1 "CONST_NAME1"
    printf ( "%s\n", CONST_NAME1 );
#undef CONST_NAME1

#ifndef CONST_NAME1
#error No defined Constant Symbol CONST_NAME1
#endif

#define CONST_NAME2 "CONST_NAME2"
    printf ( "%s\n", CONST_NAME2 );
    printf ( "%s\n", CONST_NAME2 );
    return 0;
}
```

在编译的时候输出如下编译信息：

``` bash
fatal error C1189: #error : No defined Constant Symbol CONST_NAME1
```

上面的代码会引发一个`#error`错误。综上所述，对含有复杂逻辑的宏代码使用`#error`是一个很好用的技巧。它确保了程序在关键点上确实按照程序员的想法被预处理，否则便无法编译通过。而且重要的是，编译期行为不会引起任何运行期的资源开销。

### #line预处理

&emsp;&emsp;`#line`的作用是改变当前行数和文件名称，它们是在编译程序中预先定义的标识符。该命令的基本形式如下：

``` cpp
#line number["filename"]
```

其中`[]`内的文件名可以省略。例如：

``` cpp
#line 30 a.h
```

其中文件名`a.h`可以省略不写。这条指令可以改变当前的行号和文件名，例如上面的这条预处理指令就可以改变当前的行号为`30`，文件名是`a.h`。初看起来似乎没有什么用，不过它还是有点用的，那就是用在编译器的编写中。我们知道编译器对`C`源码编译过程中会产生一些中间文件，通过这条指令，可以保证文件名是固定的，不会被这些中间文件代替，有利于进行分析。

``` cpp
#include <stdio.h>

int main ( void ) {
    printf ( "%s:%d\n", __FILE__, __LINE__ );
#line 100 "bbb.c"
    printf ( "%s:%d\n", __FILE__, __LINE__ );
    printf ( "%s:%d\n", __FILE__, __LINE__ );
    return 0;
}
```

### #pragma预处理

&emsp;&emsp;在所有的预处理指令中，`#pragma`指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。`#pragma`指令对每个编译器给出了一个方法，在保持与`C`和`C++`语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。其格式一般为：

``` cpp
#pragma para
```

其中`para`为参数，下面来看一些常用的参数。
&emsp;&emsp;1. `#pragma message`
&emsp;&emsp;`message`参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：

``` cpp
#pragma message( "消息文本" )
```

当编译器遇到这条指令时，就在编译输出窗口中将消息文本打印出来。当我们在程序中定义了许多宏来控制源代码版本的时候，有可能会忘记有没有正确地设置这些宏，此时可以用这条指令在编译的时候进行检查。假设我们希望判断自己有没有在源代码的某个地方定义了`_X86`这个宏，可以用下面的方法：

``` cpp
#ifdef _X86
#Pragma message( "_X86 macro activated!" )
#endif
```

当我们定义了`_X86`这个宏以后，应用程序在编译时就会在编译输出窗口里显示`_X86 macro activated!`。
&emsp;&emsp;2. `#pragma code_seg`
&emsp;&emsp;另一个使用得比较多的参数是`code_seg`：

``` cpp
#pragma code_seg( ["section-name" [, "section-class"]] )
```

它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。
&emsp;&emsp;3. `#pragma once`
&emsp;&emsp;只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在`Visual C++ 6.0`中就已经有了，但是考虑到兼容性并没有太多地使用它。
&emsp;&emsp;4. `#pragma hdrstop`
&emsp;&emsp;`#pragma hdrstop`表示预编译头文件到此为止，后面的头文件不进行预编译。`BCB`可以预编译头文件以加快链接的速度，但如果所有头文件都进行预编译又可能占太多磁盘空间，所以使用这个选项排除一些头文件。有时单元之间有依赖关系，比如单元`A`依赖单元`B`，所以单元`B`要先于单元`A`编译。你可以用`#pragma startup`指定编译优先级，如果使用了`#pragma package(smart_init)`，`BCB`就会根据优先级的大小先后编译。
&emsp;&emsp;5. `#pragma resource`
&emsp;&emsp;`#pragma resource "*.dfm"`表示把`*.dfm`文件中的资源加入工程，`*.dfm`中包括窗体外观的定义。
&emsp;&emsp;6. `#pragma warning`
&emsp;&emsp;`#pragma warning( disable : 4507 34; once : 4385; error : 164 )`等价于：

``` cpp
#pragma warning( disable : 4507 34 ) /* 不显示4507和34号警告信息 */
#pragma warning( once : 4385 ) /* 4385号警告信息仅报告一次 */
#pragma warning( error : 164 ) /* 把164号警告信息作为一个错误 */
```

同时`#pragma warning`也支持如下格式：

``` cpp
#pragma warning( push [, n] )
#pragma warning( pop )
```

这里`n`代表一个警告等级(`1`至`4`)。

``` cpp
#pragma warning( push ) /* 保存所有警告信息的现有的警告状态 */
#pragma warning( push, n) /* 保存所有警告信息的现有的警告状态，并且把全局警告等级设定为n */
#pragma warning( pop ) /* 向栈中弹出最后一个警告信息，在入栈和出栈之间所作的一切改动取消 */
```

使用示例如下：

``` cpp
#pragma warning( push )
#pragma warning( disable : 4705 )

#pragma warning( disable : 4706 )
#pragma warning( disable : 4707 )
//...
#pragma warning( pop )
```

在这段代码的最后，重新保存所有的警告信息(包括`4705`、`4706`和`4707`)。
&emsp;&emsp;7. `#pragma comment`
&emsp;&emsp;该指令将一个注释记录放入一个对象文件或可执行文件中。常用的`lib`关键字，可以帮我们连入一个库文件：

``` cpp
#pragma comment( lib, "user32.lib" )
```

该指令用来将`user32.lib`库文件加入到本工程中。
&emsp;&emsp;`linker`将一个链接选项放入目标文件中，你可以使用这个指令来代替由命令行传入的或者在开发环境中设置的链接选项，也可以指定`/include`选项来强制包含某个对象：

``` cpp
#pragma comment( linker, "/include:__mySymbol" )
```

&emsp;&emsp;8. `#pragma pack`
&emsp;&emsp;内存对齐的问题和`#pragma pack`有关。