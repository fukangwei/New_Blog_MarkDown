---
title: 结构体的自引用和相互引用
categories: C语言语法详解
date: 2018-12-12 05:06:47
---
&emsp;&emsp;结构体的自引用(`self reference`)就是在结构体内部，包含指向自身类型结构体的指针；结构体的相互引用(`mutual reference`)，就是说在多个结构体中，都包含指向其他结构体的指针。<!--more-->

### 自引用结构体

&emsp;&emsp;不使用`typedef`时，错误的方式为：

``` cpp
struct tag_1 {
    struct tag_1 A; /* 结构体 */
    int value;
};
```

这种声明是错误的，因为这种声明实际上是一个无限循环。成员`b`是一个结构体，`b`的内部还会有成员是结构体，依次下去，无线循环。在分配内存的时候，由于无限嵌套，也无法确定这个结构体的长度，所以这种方式是非法的。正确的方式为：

``` cpp
struct tag_1 {
    struct tag_1* A; /* 指针 */
    int value;
};
```

由于指针的长度是确定的(在`32`位机器上指针长度为`4`)，所以编译器能够确定该结构体的长度。
&emsp;&emsp;使用`typedef`时，错误的方式为：

``` cpp
typedef struct {
    int value;
    NODE* link; /* 虽然也使用指针，但这里的问题是：NODE尚未被定义 */
} NODE;
```

这里的目的是使用`typedef`为结构体创建一个别名`NODEP`。但是这里是错误的，因为类型名的作用域是从语句的结尾开始，而在结构体内部是不能使用的，因为还没定义。正确的方式为：

``` cpp
/* 方法一 */
typedef struct tag_1 {
    int value;
    struct tag_1* link;
} NODE;

/* 方法二 */
struct tag_2;
typedef struct tag_2 NODE;

struct tag_2 {
    int value;
    NODE* link;
};

/* 方法三 */
struct tag_3 {
    int value;
    struct tag* link;
};

typedef struct tag_3 NODE;
```

### 相互引用结构体

&emsp;&emsp;错误的方式为：

``` cpp
typedef struct tag_a {
    int value;
    B* bp; /* 类型B还没有被定义 */
} A;

typedef struct tag_b {
    int value;
    A* ap;
} B;
```

错误的原因和上面一样，这里类型`B`在定义之前就被使用。正确的方式为：

``` cpp
/* 方法一 */
struct tag_a {
    struct tag_b* bp; /* 这里“struct tag_b”还没有定义，但编译器可以接受 */
    int value;
};

struct tag_b {
    struct tag_a* ap;
    int value;
};

typedef struct tag_a A;
typedef struct tag_b B;

/* 方法二 */
struct tag_a; /* 使用结构体的不完整声明(incomplete declaration) */
struct tag_b;

typedef struct tag_a A;
typedef struct tag_b B;

struct tag_a {
    struct tag_b* bp;
    /* 这里“struct tag_b”还没有定义，但编译器可以接受 */
    int value;
};

struct tag_b {
    struct tag_a* ap;
    int value;
};
```