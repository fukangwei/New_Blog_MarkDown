---
title: 字长和数据类型
categories: C语言语法详解
date: 2018-12-08 23:17:41
---
&emsp;&emsp;处理器通用寄存器的大小和它的字长是相同的。一般情况下，对于一个的体系结构来说，它各个部件的宽度(比如说内存总线)，最少要和它的字长一样大；而地址空间的大小也等于字长，至少`Linux`支持的体系结构中都是这样的(不过实际上可寻址的内存空间也可能会比字长小一些，比如一个`64`位的体系结构虽然可能会提供`64`位的指针，但可能只会用`48`位来寻址。此外，如果支持`Intel`的`PAE`，那么实际的物理内存也有比字长还大的可能)。`C`语言定义的`long`类型总对等于机器的字长，而`int`类型有时会比字长小。例如`Alpha`是`64`位机，所以它的寄存器、指针和`long`类型都是`64`位长度的，而`int`类型是`32`位的。`Alpha`机每一次可以访问和操作一个`64`位长的数据。<!--more-->

### 字、双字的含义

&emsp;&emsp;有些操作系统和处理器不把它们的标准字长称作字，相反出于历史原因和某种主观的命名习惯，它们用字来代表一些固定长度的数据类型。例如一些系统根据长度把数据划分为字节(`byte`，`8`位)、字(`word`，`16`位)、双字(`double words`，`32`位)和四字(`quad words`，`64`位)，而实际上该机是`32`位的。
&emsp;&emsp;对于支持的每一种体系结构，`Linux`都要将`asm/types.h`中的`BITS_PER_LONG`定义为`C`语言`long`类型的长度，也就是系统的字长。下表是`Linux`支持的体系结构和它们的字长的对照表：

体系结构   | 描述                | 字长
----------|---------------------|-----
`arm`     | `Arm and StrongArm` | `32`位
`i386`    | `Intel x86`         | `32`位
`mips`    | `MIPS`              | `32`位
`mips64`  | `64`位`MIPS`        | `64`位
`ppc`     | `PowerPC`           | `32`位
`ppc64`   | `POWER`             | `64`位
`x86_64`  | `x86-64`            | `64`位

&emsp;&emsp;`C`语言虽然规定了变量的最小长度，但是没有规定变量具体的标准长度，它们可以根据实现变化(唯一的例外是`char`，它的长度总是`8`位)。`C`语言的标准数据类型长度随体系结构变化这一特性不断引起争议。好的一面是标准数据类型可以充分利用不同体系结构变化的字长而无需明确定义长度。`C`语言中`long`类型的长度就被确保为机器的字长。不好的一面是在编程时不能对标准的`C`数据类型进行大小的假定，没有什么能够保障`int`一定和`long`的长度是相同的(事实上对于`Linux`支持的`64`位体系结构来说，`long`和`int`长度是不同的，`int`是`32`位的，而`long`是`64`位的。但对于我们所熟悉的`32`位体系结构而言，两种数据类型都是`32`位的)。
&emsp;&emsp;情况其实还会更加复杂，因为用户空间使用的数据类型和内核空间的数据类型不一定要相互关联。`sparc64`体系结构就提供了`32`位的用户空间，其中`指针`、`int`和`long`的长度都是`32`位。而在内核空间，它的`int`长度是`32`位，指针和`long`的长度却是`64`。
&emsp;&emsp;牢记以下准则：

- `ANSI C`标准规定，一个`char`的长度一定是`8`位。
- 尽管没有规定`int`类型的长度是`32`位，但在`Linux`当前所有支持的体系结构中，它都是`32`位的。
- `short`类型也类似，在当前所有支持的体系结构中，虽然没有明文规定，但是它都是`16`位的(`although no rule explicitly decrees that`)。
- 决不应该假定指针和`long`的长度，在`Linux`当前支持的体系结构中，它们就可以在`32`位和`64`位中变化。
- 由于不同的体系结构`long`的长度不同，绝对不应该假设`sizeof(int) == sizeof(long)`。类似地，也不要假设指针和`int`长度相等。

### 不透明类型

&emsp;&emsp;不透明数据类型隐藏了它们内部格式或结构，支持它们的语言不是很多。作为替代，开发者们利用`typedef`声明一个类型，把它叫做`不透明类型`，希望其他人别去把它重新转化回对应的那个标准`C`类型。通常开发者们在定义一套特别的接口时才会用到它们。例如用来保存进程标识符的`pid_t`类型，该类型的实际长度被隐藏起来了，尽管任何人都可以偷偷撩开它的面纱，发现它就是一个`int`。如果所有代码都不显式地利用它的长度(显式地利用长度这里指直接使用`int`类型的长度，比如说在编程时使用`sizeof(int)`而不是`sizeof(pid_t)`)，那么改变时就不会引起什么争议，这种改变确实可能会出现：在老版本的`Unix`系统中，`pid_t`的定义是`short`类型。
&emsp;&emsp;另外一个不透明数据类型的例子是`atomic_t`，它放置的是一个可以进行原子操作的整型值。尽管这种类型就是一个`int`，但利用不透明类型可以帮助确保这些数据只在特殊的有关原子操作的函数中才会被使用。不透明类型还帮助我们隐藏了类型的长度，但是该类型也并不总是完整的`32`位，比如在`32`位`SPARC`体系下长度被限制。
&emsp;&emsp;内核还用到了其他一些不透明类型，包括`dev_t`、`gid_t`和`uid_t`等。处理不透明类型时的原则是：

- 不要假设该类型的长度。
- 不要将该类型转化回其对应的`C`标准类型使用。
- 编程时要保证在该类型实际存储空间和格式发生变化时代码不受影响。

### 指定数据类型

&emsp;&emsp;内核中还有一些数据虽然无需用不透明的类型表示，但它们被定义成了指定的数据类型。`jiffy`数目和在中断控制时用到的`flags`参数就是两个例子，它们都应该被存放在`unsigned long`类型中。
&emsp;&emsp;当存放和处理这些特别的数据时，一定要搞清楚它们对应的类型后再使用。把它们存放在其他如`unsigned int`等类型中是一种常见错误。在`32`位机上这没什么问题，可是`64`位机上就会捅娄子了。

### 长度明确的类型

&emsp;&emsp;作为一个程序员，你往往需要在程序中使用长度明确的数据。像操作硬件设备、进行网络通信和操作二进制文件时，通常都必须满足它们明确的内部要求。例如一块声卡可能用的是`32`位寄存器，一个网络包有一个`16`位字段，一个可执行文件有`8`位的`cookie`。在这些情况下，数据对应的类型应该长度明确。
&emsp;&emsp;内核在`asm/typs.h`中定义了这些长度明确的类型，而该文件又被包含在文件`linux/types.h`中。长度明确的数据类型如下：

类型  | 描述             | 类型  | 描述
------|-----------------|-------|-----
`s8`  | 带符号字节       | `u8`  | 无符号字节
`s16` | 带符号`16`位整数 | `u16` | 无符号`16`位整数
`s32` | 带符号`32`位整数 | `u32` | 无符号`32`位整数
`s64` | 带符号`64`位整数 | `u64` | 无符号`64`位整数

这些长度明确的类型大部分都是通过`typedef`对标准的`C`类型进行映射得到的。在一个`64`位机上，它们看起来像：

``` cpp
typedef signed char    s8;
typedef unsigned char  u8;
typedef signed short   s16;
typedef unsigned short u16;
typedef signed int     s32;
typedef unsigned int   u32;
typedef signed long    s64;
typedef unsigned long  u64;
```

而在`32`位机上，它们可能定义成：

``` cpp
typedef signed char        s8;
typedef unsigned char      u8;
typedef signed short       s16;
typedef unsigned short     u16;
typedef signed int         s32;
typedef unsigned int       u32;
typedef signed long long   s64;
typedef unsigned long long u64;
```

上述的这些类型只能在内核内使用，不可以在用户空间出现(比如在头文件中的某个用户可见结构中出现)，这个限制是为了保护命名空间。不过内核对应这些不可见变量同时也定义了对应的用户可见的变量类型，这些类型与上面类型所不同的是增加了两个下画线前缀。例如无符号`32`位整形对应的用户空间可见类型就是`__u32`，该类型除了名字有区别外，与`u32`相同。在内核中你可以任意使用这两个名字，但是如果是用户可见的类型，那你必须使用下画线前缀的版本名，防止污染用户空间的命名空间。

### char型的符号问题

&emsp;&emsp;`C`标准表示`char`类型可以带符号也可以不带符号，由具体的编译器、处理器或由它们两者共同决定到底`char`是带符号合适还是不带符号合适。大部分体系结构上，`char`默认是带符号的，它可以自`-128`到`127`之间取值。而也有一些例外，比如`ARM`体系结构上，`char`就是不带符号的，它的取值范围是`0`至`255`。
&emsp;&emsp;举例来说，如果默认的`char`不带符号，那么如下代码会把`255`而不是`-1`赋予`i`：

``` cpp
char i = -1;
```

而在另一种机器上，假设默认`char`带符号，就会确切地把`-1`赋予`i`。如果程序员本意是把`-1`保存在`i`中，那么前面的代码就该修改成：

``` cpp
signed char i = -1;
```

另外，如果程序员确实希望存储`255`，那么代码应该如下：

``` cpp
unsigned char i = 255;
```

如果你在自己的代码中使用了`char`类型，那么要保证在带符号和不带符号的情况下代码都没问题。如果你能明确要用的是哪一个，那么就直接声明它。