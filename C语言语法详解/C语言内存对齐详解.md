---
title: C语言内存对齐详解
date: 2018-12-09 19:55:55
categories: C语言语法详解
---
&emsp;&emsp;`C`语言对结构的存储的特殊处理确实提高`CPU`存储变量的速度，但是有时候也带来了一些麻烦，我们也屏蔽掉变量默认的对齐方式，自己可以设定变量的对齐方式。`VC`中提供了`#pragma pack(n)`来设定变量以`n`字节对齐方式。`n`字节对齐就是说变量存放的起始地址的偏移量有两种情况：

- 如果`n`大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式。
- 如果`n`小于该变量的类型所占用的字节数，那么偏移量为`n`的倍数，不用满足默认的对齐方式。

&emsp;&emsp;结构的总大小也有个约束条件，分下面两种情况：如果`n`大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为`n`的倍数。下面举例说明其用法：

``` cpp
#pragma pack(push) /* 保存对齐状态 */
#pragma pack(4) /* 设定为4字节对齐 */​

struct test {
    char m1;
    double m4;
    int m3;
};
​
#pragma pack(pop) /* 恢复对齐状态 */
```

以上结构的大小为`16`。下面分析其存储情况，首先为`m1`分配空间，其偏移量为`0`，满足我们自己设定的对齐方式(`4`字节对齐)，`m1`占用`1`个字节。接着开始为`m4`分配空间，这时其偏移量为`1`，需要补足`3`个字节，这样使偏移量满足为`n = 4`的倍数(因为`sizeof(double)`大于`n`)，`m4`占用`8`个字节。接着为`m3`分配空间，这时其偏移量为`12`，满足为`4`的倍数，`m3`占用`4`个字节。这时已经为所有成员变量分配了空间，共分配了`4 + 8 + 4 = 16`个字节，满足为`n`的倍数。如果把上面的`#pragma pack(4)`改为`#pragma pack(16)`，那么结构的大小为`24`。再看下面这个例子：

``` cpp
#pragma pack(8)

struct S1 {
    char a;
    long b;
};

struct S2 {
    char c;
    struct S1 d;
    long long e;
};

#pragma pack()
```

成员对齐有一个重要的条件，即每个成员分别对齐，即每个成员按自己的方式对齐。
&emsp;&emsp;也就是说上面虽然指定了按`8`字节对齐，但并不是所有的成员都是以`8`字节对齐。其对齐的规则是，每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是`8`字节)中较小的一个对齐。并且结构的长度必须为所用过的所有对齐参数的整数倍，不够就补空字节。
&emsp;&emsp;`S1`中，成员`a`是`1`字节默认按`1`字节对齐，指定对齐参数为`8`，这两个值中取`1`，`a`按`1`字节对齐；成员`b`是`4`个字节，默认是按`4`字节对齐，这时就按`4`字节对齐，所以`sizeof(S1)`应该为`8`。
&emsp;&emsp;`S2`中，`c`和`S1`中的`a`一样，按`1`字节对齐，而`d`是个结构，它是`8`个字节，它按什么对齐呢？对于结构来说，默认对齐方式就是它的所有成员使用的对齐参数中最大的一个，`S1`的就是`4`。所以，成员`d`就是按`4`字节对齐。成员`e`是`8`个字节，它是默认按`8`字节对齐，和指定的一样，所以它对到`8`字节的边界上，这时已经使用了`12`个字节了，所以又添加了`4`个字节的空，从第`16`个字节开始放置成员`e`。这时长度为`24`，已经可以被`8`(成员`e`按`8`字节对齐)整除，这样`sizeof(S2)`为`24`个字节。
&emsp;&emsp;这里有三点很重要：

- 每个成员分别按自己的方式对齐，并能最小化长度。
- 复杂类型(例如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度。
- 对齐后的长度必须是成员中最大的对齐参数的整数倍，这样在处理数组时可以保证每一项都边界对齐。

&emsp;&emsp;在`minix`的`stdarg.h`文件中，定义了如下一个宏：

``` cpp
/* Amount of space required in an argument list for an arg of type TYPE.
   TYPE may alternatively be an expression whose type is used. */
#define __va_rounded_size(TYPE) ( ( ( sizeof ( TYPE ) + sizeof ( int ) - 1 ) / sizeof ( int ) ) * sizeof ( int ) )
```

从注释以及宏的名字可以看出是有关内存对齐方面的作用。根据`C`语言内存对齐方面的理论可知，`n`字节对齐就是说变量存放的起始地址的偏移量有两种情况：

- 如果`n`大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式(各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数)。
- 如果`n`小于该变量的类型所占用的字节数，那么偏移量为`n`的倍数，不用满足默认的对齐方式。

&emsp;&emsp;假设此时`n = 4`，对于`sizeof(TYPE)`一定为自然数，`sizeof(int) - 1 = 3`。`sizeof(TYPE)`只可能出现如下两种情况：

- 当`sizeof(TYPE) >= 4`，偏移量为`(sizeof(TYPE) / 4) * 4`。
- 当`sizeof(TYPE) < 4`，偏移量为`4`，此时`sizeof(TYPE) = 1 or 2 or 3`，而`((sizeof(TYPE) + 3) / 4) * 4 = 4`。

为了将上述两种情况统一，偏移量为`((sizeof(TYPE) + 3) / 4) * 4`。
&emsp;&emsp;在有的源代码中，将内存对齐宏`__va_rounded_size`通过位操作来实现，代码如下：

``` cpp
#define __va_rounded_size(TYPE) ( ( sizeof ( TYPE ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) )
```

由于`~(sizeof(int) - 1) = ~(4 - 1) = ~(00000011B) = 11111100B`，`(sizeof(TYPE) + sizeof(int) - 1)`就是将大于`4m`但小于等于`4(m + 1)`的数提高到大于等于`4(m + 1)`但小于`4(m + 2)`，这样再`&~(sizeof(int) - 1)`后就正好将原长度补齐到`4`的倍数了。

---

### "#pragma pack(1)"的意义

&emsp;&emsp;`#pragma pack(1)`使结构体按`1`字节方式对齐：

``` cpp
struct sample {
    char a;
    double b;
};
```

&emsp;&emsp;若不用`#pragma pack(1)`，则`sample`按编译器默认方式对齐(成员中`size`最大的那个)，即按`8`字节(`double`)对齐，则`sizeof(sample)`为`16`，成员`char a`占了`8`个字节(其中`7`个是空字节)。
&emsp;&emsp;若用`#pragma pack(1)`，则`sample`按`1`字节方式对齐，即`sizeof(sample)`为`9`(无空字节)。这种做法比较节省空间，有些场合还可使结构体更易于控制。