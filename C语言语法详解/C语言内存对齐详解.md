---
title: C语言内存对齐详解
date: 2018-12-09 19:55:55
categories: C语言语法详解
---
&emsp;&emsp;该博客主要来源于[C语言内存对齐详解](https://blog.csdn.net/wanglang1000/article/details/17711863)，内容经过测试和修改，感谢原作者。
&emsp;&emsp;C语言对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也屏蔽掉变量默认的对齐方式，自己可以设定变量的对齐方式。VC中提供了`#pragma pack(n)`来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：

- 如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式。
- 如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。

&emsp;&emsp;结构的总大小也有个约束条件，分下面两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。下面举例说明其用法：

``` c
#pragma pack(push) /* 保存对齐状态 */
#pragma pack(4) /* 设定为4字节对齐 */​

struct test {
    char m1;
    double m4;
    int m3;
};
​
#pragma pack(pop) /* 恢复对齐状态 */
```

以上结构的大小为16。下面分析其存储情况，首先为m1分配空间，其偏移量为0，满足我们自己设定的对齐方式(4字节对齐)，m1占用1个字节。接着开始为m4分配空间，这时其偏移量为1，需要补足3个字节，这样使偏移量满足为`n = 4`的倍数(因为`sizeof(double)`大于n)，m4占用8个字节。接着为m3分配空间，这时其偏移量为12，满足为4的倍数，m3占用4个字节。这时已经为所有成员变量分配了空间，共分配了`4 + 8 + 4 = 16`个字节，满足为n的倍数。如果把上面的`#pragma pack(4)`改为`#pragma pack(16)`，那么结构的大小为24。再看下面这个例子：

``` c
#pragma pack(8)

struct S1 {
    char a;
    long b;
};

struct S2 {
    char c;
    struct S1 d;
    long long e;
};

#pragma pack()
```

成员对齐有一个重要的条件，即每个成员分别对齐，即每个成员按自己的方式对齐。
&emsp;&emsp;也就是说上面虽然指定了按8字节对齐，但并不是所有的成员都是以8字节对齐。其对齐的规则是，每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐。并且结构的长度必须为所用过的所有对齐参数的整数倍，不够就补空字节。
&emsp;&emsp;S1中，成员a是1字节默认按1字节对齐，指定对齐参数为8，这两个值中取1，a按1字节对齐；成员b是4个字节，默认是按4字节对齐，这时就按4字节对齐，所以`sizeof(S1)`应该为8。
&emsp;&emsp;S2中，c和S1中的a一样，按1字节对齐，而d是个结构，它是8个字节，它按什么对齐呢？对于结构来说，默认对齐方式就是它的所有成员使用的对齐参数中最大的一个，S1的就是4。所以，成员d就是按4字节对齐。成员e是8个字节，它是默认按8字节对齐，和指定的一样，所以它对到8字节的边界上，这时已经使用了12个字节了，所以又添加了4个字节的空，从第16个字节开始放置成员e。这时长度为24，已经可以被8(成员e按8字节对齐)整除，这样`sizeof(S2)`为24个字节。
&emsp;&emsp;这里有三点很重要：

- 每个成员分别按自己的方式对齐，并能最小化长度。
- 复杂类型(例如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度。
- 对齐后的长度必须是成员中最大的对齐参数的整数倍，这样在处理数组时可以保证每一项都边界对齐。

&emsp;&emsp;在minix的`stdarg.h`文件中，定义了如下一个宏：

``` c
/* Amount of space required in an argument list for an arg of type TYPE.
   TYPE may alternatively be an expression whose type is used. */
#define __va_rounded_size(TYPE) ( ( ( sizeof ( TYPE ) + sizeof ( int ) - 1 ) / sizeof ( int ) ) * sizeof ( int ) )
```

从注释以及宏的名字可以看出是有关内存对齐方面的作用。根据C语言内存对齐方面的理论可知，n字节对齐就是说变量存放的起始地址的偏移量有两种情况：

- 如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式(各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数)。
- 如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。

&emsp;&emsp;假设此时`n = 4`，对于`sizeof(TYPE)`一定为自然数，`sizeof(int) - 1 = 3`。`sizeof(TYPE)`只可能出现如下两种情况：

- 当`sizeof(TYPE) >= 4`，偏移量为`(sizeof(TYPE) / 4) * 4`。
- 当`sizeof(TYPE) < 4`，偏移量为4，此时`sizeof(TYPE) = 1 or 2 or 3`，而`((sizeof(TYPE) + 3) / 4) * 4 = 4`。

为了将上述两种情况统一，偏移量为`((sizeof(TYPE) + 3) / 4) * 4`。
&emsp;&emsp;在有的源代码中，将内存对齐宏`__va_rounded_size`通过位操作来实现，代码如下：

``` c
#define __va_rounded_size(TYPE) ( ( sizeof ( TYPE ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) )
```

由于`~(sizeof(int) - 1) = ~(4 - 1) = ~(00000011B) = 11111100B`，`(sizeof(TYPE) + sizeof(int) - 1)`就是将大于`4m`但小于等于`4(m + 1)`的数提高到大于等于`4(m + 1)`但小于`4(m + 2)`，这样再`&~(sizeof(int) - 1)`后就正好将原长度补齐到4的倍数了。

---

### "#pragma pack(1)"的意义

&emsp;&emsp;`#pragma pack(1)`使结构体按1字节方式对齐。例如：

``` c
struct sample {
    char a;
    double b;
};
```

&emsp;&emsp;若不用`#pragma pack(1)`，则sample按编译器默认方式对齐(成员中size最大的那个)，即按8字节(double)对齐，则`sizeof(sample)`为16，成员`char a`占了8个字节(其中7个是空字节)。
&emsp;&emsp;若用`#pragma pack(1)`，则sample按1字节方式对齐，即`sizeof(sample)`为9(无空字节)。这种做法比较节省空间，有些场合还可使结构体更易于控制。