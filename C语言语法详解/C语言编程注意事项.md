---
title: C语言编程注意事项
categories: C语言语法详解
abbrlink: e704dc05
date: 2018-12-06 12:33:00
---
1. 连续写两个常量字符串，等于连接起来(具体来说，如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体)。这个方法可以解决字符串换行问题。
2. 函数名与对函数名进行取地址是一样的，都表示函数的地址。
3. 当需要输入`double`类型的数据时，使用`scanf("%lf", &变量);`进行输入操作。
4. 在`C/S`模式下，客户端发给服务器端的字符串尽量要加上换行符和回车符(服务器接收字符串时也要加上回车换行符)，否则服务器端可能无法`printf`字符串。
5. 在网络编程中，网速也是一个需要考虑的因素。如果网速不尽人意的话，可以在计算机上进行环回测试。
6. 在`C`语言编程中，要考虑所有可能出现的情况，例如客户端可能发来空字符。
7. 对于`HTTP`请求数据报和应答数据报的发送，可以采取先发送头部信息，再发送报体内容的策略。其中，报体内容可以分批次进行发送，而报文头部的`Content-Length`的大小一定为数据报内容的字节数。
8. 在打印`unsigned long`数据类型时，使用的格式为`%ld`；打印`unsigned long long`时，使用的格式是`%lld`。
9. 对于`Makefile`，目标文件`target`就是后面带着依赖文件的标志，例如`all:...`，要使用`make`命令执行；对于伪目标，就是后面没有依赖文件的标志，例如`.PHONY:(换行)clean:`，使用命令`make clean`；变量的后面往往带着`=`标志，例如`object = ...`，使用`$(object)`进行访问。
10. `typedef`用来定义一个变量类型的别名；`static`不是变量类型，它定义存放方式。因此，`typedef static u8 STATIC`是错误的，编译器会报错`more than one storage class specified`。
11. `C`语言标准并没有明确定义应该使用哪种类型的右移。对于无符号数据，右移必须是逻辑的(即右移空出的部分填`0`)；对于有符号数据，算术右移(即右移空出的部分填最高位)和逻辑右移都可以。实际上，几乎所有的编译器/机器组合都对有符号数据使用算术右移。
12. 关键字`long`的大小(`sizeof`)表示机器的字节长度，如`32`位机器为`4`个字节，`64`位机器为`8`个字节。
13. `C`语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有机器都是这么做的。
14. 在进行除法运算时，一定要注意结果的正确性！例如，`-7/2`的结果为`-3`，而不是`-4`。对于除于`2`的幂，无符号和补码分别使用逻辑移位和算术移位来达到目的。
15. 使用`sprintf`或`printf`格式化数据时，格式化字符串的形式要和格式化的变量一一对应，例如使用`%d`对`char`型变量进行格式会造成误差，解决方法是将`char`型变量强制转换为`int`型。
16. 在代码中最好声明变量的类型是`signed`型还是`unsigned`型，尤其是当`signed`型变量的位数扩充时(例如从`8`位强制转换为`32`位)，如果变量为负数，则扩充的位全为`1`。
17. 尽量使用`snprintf`函数代替`sprintf`函数，其他类似的函数也尽量替换掉，这样可以最大限度避免编程错误。
18. 把`C`语言代码放在多个文件中的编译速度要比只放在一个文件上要快。
19. 位操作不能用于浮点型、空值或其他复杂类型。
20. 运行代码有时候不能立即出现结果，其原因有可能是算法的效率很低，需要对算法进行改进。
21. 对于无定义的特性，要么应该将其从程序中消去，要么应该利用断言验证其不会被用到。根据`ANSI`标准，请求`malloc`分配长度为零的内存块时，其结果无定义。
22. 暴露代码错误的关键是消除错误发生的随机性。查看应用中的子系统，以确定其引起随机错误的设计之处。一旦发现了这些地方，就要通过改变设计的方法把它们排除。
23. 关心局部效率是不值得的，如果你很注重效率的话，请集中于全局效率和算法的效率上，这样你才会看到努力的效果。
24. 可以使用`sizeof`来查看数据类型的大小，例如`sizeof(int)`，这为代码在不同硬件上的移植是很有帮助的。
25. 在多重循环中，应将最忙的循环放在最内层，这样可以减少`CPU`切入循环层的次数，提高运行效率。
26. 尽量用乘法或其它方法代替除法，特别是浮点运算中的除法，因为浮点运算除法要占用较多`CPU`资源。
27. `if`语句尽量加上`else`分支，对没有`else`分支的语句要小心对待；`switch`语句必须有`default`分支，要考虑代码运行时可能会出现的所有情况。
28. 时刻注意表达式是否会上溢或下溢，例如这样的代码`for(char i = 7;i >= 0; i--)`。
29. `C`语言比较字符串时要使用`strcmp`函数，而`C++`则采用`==`符号；`C`语言复制拷贝字符串要使用`strcpy`函数，而`C++`则采用`=`符号。
30. 在编译器中设置全局宏定义要比在代码配置文件中设置好用的多，参考`Contiki`中`uip6`的配置。
31. `程序必须为阅读它的人而编写，只是顺便用于机器执行`，来自`Harold Abelson`和`Gerald Jay Sussman`。
32. 一个函数应该仅完成一个功能，实现多个功能将会给开发、使用以及维护都带来很大困难。`realloc`是一个典型的不良设计，在代码中少用甚至不用类似的函数。
33. 求余操作符`%`的运算量只能是整数，一定要注意。
34. 对于`~0`，这和`0`的数据类型有关：对`char`类型，`0 = 0x00`，`~0 = 0xFF`；对`short`类型，`0 = 0x0000`，`~0 = 0xFFFF`，对`32`位`int`类型，`0 = 0x00000000`，`~0 = 0xFFFFFFFF`。
35. `argv`数组的最后一个元素为`NULL`，因此可以用`NULL`来判断是否读到最后一个元素。
36. 使用`free`或`delete`释放内存后，必须要将该指针设置为`NULL`，避免产生野指针。
37. 可以利用传递结构体指针的方式来编写有多个返回值的`C`语言函数。
38. 使用`strcpy`函数将一个字符串复制到一个数组后，不要忘记将数组中字符串的后面加上`\0`，否则会在程序中埋下栈溢出的隐患。
39. 如果两个指针指向同一个数组，它们就可以相减，其结果为两个指针之间的元素数目(这个结果可以和整形数据进行运算)。指针的减法运算在处理字符串时十分有用。
40. `strncpy`在复制含有转义字符`\"`的字符串时，有可能会出现错误，最好使用`strcpy`函数。
41. 对于`C`语言的科学计数法，`12.3E12`表示`12.3 * 10^12`，注意`E`和左右两边的数字之间不要有间隔。
42. 对于使用过`strcat`填充的字符串，下一次填充时，需要用`memset`函数进行清空，否则后续的字符串会在原来的字符串后面填充。
43. `C`语言也可以返回枚举类型的数值，这对返回有限结果的函数是非常有用的。
44. `volatile const`这种类型是允许的，它表示其后面定义的变量是只读的，比如用它来定义一个只读的状态寄存器。定义为`volatile`是因为它的值可能会被硬件意想不到地改变，而定义为`const`是因为程序不应该试图去修改它的值。
45. 输入输出流有`缓冲流`和`非缓冲流`之分，对于`非缓冲流`，一旦数据送到缓冲区，立即处理；对于缓冲流，仅当缓冲区满或当前送入的数据为新的一行字符时，系统才对流中的数据进行处理(称为`刷新`)。通常使用缓冲流，仅在特殊场合，才使用非缓冲流。
46. 对于向`main`函数传参数的代码，如果没有传入正确个数或者格式的参数，代码也会报出段错误。
47. `fclose`函数隐含执行了一次`fflush`操作，所以不必在调用`fclose`之前调用`fflush`。
48. 含有`double`成员的结构体对齐的问题：`GCC`编译时加`-malign-double`选项，则`double`按`8`字节对齐；编译时不加`-malign-double`，则`double`按`4`字节对齐。
49. 在使用指针前，一定要考虑该指针是否指向了合适的内存空间。
50. 使用`const`定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像`#define`一样给出的是立即数。所以`const`定义的常量在程序运行过程中只有一份拷贝，而`#define`定义的常量在内存中有若干个拷贝。
51. 注意，可执行文件一定不要和目录使用同一个名字。
52. 即便函数没有参数，最好也要加上`void`关键字，否则编译器会报出`function declaration isn't a prototype`的警告。
53. 注意`C`语言字符串的初始化方法，例如`char str[] = "hello";`。