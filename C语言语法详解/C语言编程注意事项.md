---
title: C语言编程注意事项
date: 2018-12-06 12:33:00
categories: C语言语法详解
---
1. 连续写两个常量字符串，等于连接起来(具体来说，如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体)。这个方法可以解决字符串换行问题。
2. 函数名与对函数名进行取地址是一样的，都表示函数的地址。
3. 当需要输入double类型的数据时，使用`scanf("%lf", &变量);`进行输入操作。
4. 在`C/S`模式下，客户端发给服务器端的字符串尽量要加上换行符和回车符(服务器接收字符串时也要加上回车换行符)，否则服务器端可能无法printf字符串。
5. 在网络编程中，网速也是一个需要考虑的因素。如果网速不尽人意的话，可以在计算机上进行环回测试。
6. 在C语言编程中，要考虑所有可能出现的情况，例如客户端可能发来空字符。
7. 对于HTTP请求数据报和应答数据报的发送，可以采取先发送头部信息，再发送报体内容的策略。其中，报体内容可以分批次进行发送，而报文头部的`Content-Length`的大小一定为数据报内容的字节数。
8. 在打印`unsigned long`数据类型时，使用的格式为`%ld`；打印`unsigned long long`时，使用的格式是`%lld`。
9. 对于Makefile，目标文件target就是后面带着依赖文件的标志，例如`all:……`，要使用`make`命令执行；对于伪目标，就是后面没有依赖文件的标志，例如`.PHONY:(换行)clean:`，使用命令`make clean`；变量的后面往往带着`=`标志，例如`object = ……`，使用`$(object)`进行访问。
10. typedef用来定义一个变量类型的别名；static不是变量类型，它定义存放方式。因此，`typedef static u8 STATIC`是错误的，编译器会报错`more than one storage class specified`。
11. C语言标准并没有明确定义应该使用哪种类型的右移。对于无符号数据，右移必须是逻辑的(即右移空出的部分填0)；对于有符号数据，算术右移(即右移空出的部分填最高位)和逻辑右移都可以。实际上，几乎所有的编译器/机器组合都对有符号数据使用算术右移。
12. 关键字long的大小(sizeof)表示机器的字节长度，如32位机器为4个字节，64位机器为8个字节。
13. C语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有机器都是这么做的。
14. 在进行除法运算时，一定要注意结果的正确性！例如，`-7/2`的结果为`-3`，而不是`-4`。对于除于2的幂，无符号和补码分别使用逻辑移位和算术移位来达到目的。
15. 使用sprintf或printf格式化数据时，格式化字符串的形式要和格式化的变量一一对应，例如使用`%d`对char型变量进行格式会造成误差，解决方法是将char型变量强制转换为int型。
16. 在代码中最好声明变量的类型是`signed`型还是`unsigned`型，尤其是当`signed`型变量的位数扩充时(例如从8位强制转换为32位)，如果变量为负数，则扩充的位全为1。
17. 尽量使用snprintf函数代替sprintf函数，其他类似的函数也尽量替换掉，这样可以最大限度避免编程错误。
18. 把C语言代码放在多个文件中的编译速度要比只放在一个文件上要快。
19. 位操作不能用于浮点型、空值或其他复杂类型。
20. 运行代码有时候不能立即出现结果，其原因有可能是算法的效率很低，需要对算法进行改进。
21. 对于无定义的特性，要么应该将其从程序中消去，要么应该利用断言验证其不会被用到。根据ANSI标准，请求malloc分配长度为零的内存块时，其结果无定义。
22. 暴露代码错误的关键是消除错误发生的随机性。查看应用中的子系统，以确定其引起随机错误的设计之处。一旦发现了这些地方，就要通过改变设计的方法把它们排除。
23. 关心局部效率是不值得的，如果你很注重效率的话，请集中于全局效率和算法的效率上，这样你才会看到努力的效果。
24. 可以使用sizeof来查看数据类型的大小，例如`sizeof(int)`，这为代码在不同硬件上的移植是很有帮助的。
25. 在多重循环中，应将最忙的循环放在最内层，这样可以减少CPU切入循环层的次数，提高运行效率。
26. 尽量用乘法或其它方法代替除法，特别是浮点运算中的除法，因为浮点运算除法要占用较多CPU资源。
27. if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支，要考虑代码运行时可能会出现的所有情况。
28. 时刻注意表达式是否会上溢或下溢，例如这样的代码`for(char i = 7;i >= 0; i--)`。
29. C语言比较字符串时要使用strcmp函数，而C++则采用`==`符号；C语言复制拷贝字符串要使用strcpy函数，而C++则采用`=`符号。
30. 在编译器中设置全局宏定义要比在代码配置文件中设置好用的多，参考Contiki中uip6的配置。
31. `程序必须为阅读它的人而编写，只是顺便用于机器执行`，来自`Harold Abelson`和`Gerald Jay Sussman`。
32. 一个函数应该仅完成一个功能，实现多个功能将会给开发、使用以及维护都带来很大困难。realloc是一个典型的不良设计，在代码中少用甚至不用类似的函数。
33. 求余操作符`%`的运算量只能是整数，一定要注意。
34. 对于`~0`，这和0的数据类型有关：对char类型，`0 = 0x00`，`~0 = 0xFF`；对short类型，`0 = 0x0000`，`~0 = 0xFFFF`，对32位int类型，`0 = 0x00000000`，`~0 = 0xFFFFFFFF`。
35. argv数组的最后一个元素为NULL，因此可以用NULL来判断是否读到最后一个元素。
36. 使用free或delete释放内存后，必须要将该指针设置为NULL，避免产生野指针。
37. 可以利用传递结构体指针的方式来编写有多个返回值的C语言函数。
38. 使用strcpy函数将一个字符串复制到一个数组后，不要忘记将数组中字符串的后面加上`\0`，否则会在程序中埋下栈溢出的隐患。
39. 如果两个指针指向同一个数组，它们就可以相减，其结果为两个指针之间的元素数目(这个结果可以和整形数据进行运算)。指针的减法运算在处理字符串时十分有用。
40. strncpy在复制含有转义字符`\"`的字符串时，有可能会出现错误，最好使用strcpy函数。
41. 对于C语言的科学计数法，`12.3E12`表示`12.3 * 10^12`，注意`E`和左右两边的数字之间不要有间隔。
42. 对于使用过strcat填充的字符串，下一次填充时，需要用memset函数进行清空，否则后续的字符串会在原来的字符串后面填充。
43. C语言也可以返回枚举类型的数值，这对返回有限结果的函数是非常有用的。
44. `volatile const`这种类型是允许的，它表示其后面定义的变量是只读的，比如用它来定义一个只读的状态寄存器。定义为volatile是因为它的值可能会被硬件意想不到地改变，而定义为const是因为程序不应该试图去修改它的值。
45. 输入输出流有缓冲流和非缓冲流之分，对于非缓冲流，一旦数据送到缓冲区，立即处理；对于缓冲流，仅当缓冲区满或当前送入的数据为新的一行字符时，系统才对流中的数据进行处理(称为刷新)。通常使用缓冲流，仅在特殊场合，才使用非缓冲流。
46. 对于向main函数传参数的代码，如果没有传入正确个数或者格式的参数，代码也会报出段错误。
47. fclose函数隐含执行了一次fflush操作，所以不必在调用fclose之前调用fflush。
48. 含有double成员的结构体对齐的问题：GCC编译时加`-malign-double`选项，则double按8字节对齐；编译时不加`-malign-double`，则double按4字节对齐。
49. 在使用指针前，一定要考虑该指针是否指向了合适的内存空间。
50. 使用const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像`#define`一样给出的是立即数。所以const定义的常量在程序运行过程中只有一份拷贝，而`#define`定义的常量在内存中有若干个拷贝。
51. 注意，可执行文件一定不要和目录使用同一个名字。
52. 即便函数没有参数，最好也要加上void关键字，否则编译器会报出`function declaration isn't a prototype`的警告。
53. 注意C语言字符串的初始化方法，例如`char str[] = "hello";`。