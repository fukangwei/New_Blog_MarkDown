---
title: '宏与单井号和双井号'
date: 2018-12-08 11:06:47
categories: C语言语法详解
---
&emsp;&emsp;在`C`语言的宏中，`#`的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。比如下面代码中的宏：

``` cpp
#define WARN_IF(EXP) \
    do { \
        if ( EXP ) \
            fprintf ( stderr, "Warning: " #EXP "\n"); \
    } while ( 0 );
```

那么实际使用中会出现下面所示的替换过程：

``` cpp
WARN_IF ( divider == 0 );
```

被替换为：

``` cpp
do {
    if ( divider == 0 )
        fprintf ( stderr, "Warning" "divider == 0" "\n" );
} while ( 0 );
```

这样，每次`divider`(除数)为`0`的时候便会在标准错误流上输出一个提示信息。
&emsp;&emsp;而`##`被称为连接符(`concatenator`)，用来将两个`Token`连接为一个`Token`。注意这里连接的对象是`Token`就行，而不一定是宏的变量。比如你要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数名和菜单项命令名之间有直观的、名字上的关系，那么下面的代码就非常实用：

``` cpp
struct command {
    char* name;
    void ( *function ) ( void );
};
​
#define COMMAND(NAME) { NAME, NAME##_command }
```

然后你就用一些预先定义好的命令来方便的初始化一个`command`结构的数组了：

``` cpp
struct command commands[] = {
    COMMAND ( quit ),
    COMMAND ( help ),
}
```

`COMMAND`宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码密度，也可以减少不留心所造成的错误。我们还可以用`n`个`##`符号连接`n + 1`个`Token`，这个特性也是`#`符号所不具备的：

``` cpp
#define LINK_MULTIPLE(a,b,c,d) a##_##b##_##c##_##d
typedef struct _record_type LINK_MULTIPLE ( name, company, position, salary );
```

这个语句将展开为：

``` cpp
typedef struct _record_type name_company_position_salary;
```

---

&emsp;&emsp;`##`连接符号由两个井号组成，其功能是在带参数的宏定义中将两个子串(`token`)联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。所谓的子串，就是指编译器能够识别的最小语法单元。`#`符是把传递过来的参数当成字符串进行替代。下面来看看它们是怎样工作的，这是`MSDN`上的一个例子。假设程序中已经定义了这样一个带参数的宏：

``` cpp
#define paster( n ) printf( "token" #n " = %d", token##n )
```

同时又定义了一个整形变量`int token9 = 9;`，现在在主程序中以下面的方式调用这个宏：

``` cpp
paster( 9 );
```

那么在编译时，上面的这句话被扩展为：

``` cpp
printf ( "token" "9" " = %d", token9 );
```

注意到在这个例子中，`paster(9);`中的这个`9`被原封不动的当成了一个字符串，与`token`连接在了一起，从而成为了`token9`。而`#n`也被`9`所替代。可想而知，上面程序运行的结果就是在屏幕上打印出`token9 = 9`。