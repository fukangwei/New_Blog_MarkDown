---
title: 柔性数组
categories: C语言语法详解
abbrlink: '43093537'
date: 2018-12-08 12:58:58
---
&emsp;&emsp;在标准`C/C++`中，零长度的数组如`charArray[0]`是不允许使用的，因为这从语义逻辑上看是完全没有意义的。但是`GUN`中却允许使用，而且很多时候应用在了变长结构体中：<!--more-->

``` cpp
struct Packet {
    int state;
    int len;
    char cData[0];
};
```

&emsp;&emsp;首先对零长度数组做一个解释：长度为零的数组的主要用途是为了满足需要变动长度的结构体，在一个结构体的最后声明一个长度为`0`的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为`0`的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量，数组名这个符号本身代表了一个不可修改的地址常量(注意，数组名永远都不会是指针)，但对于这个数组的大小，我们可以进行动态分配。
&emsp;&emsp;对于零长度数组的这个特点，很容易构造出变长结构体，如缓冲区、数据包等：

``` cpp
struct Buffer {
    int len;
    char cData[0];
};
```

这样的变长数组常用于网络通信中构造不定长数据包，不会浪费空间和网络流量。例如我要发送`1024`字节的数据，如果使用定长数据包，假设定长数据包的长度为`2048`，就会浪费`1024`个字节的空间，造成不必要的流量浪费：

``` cpp
struct packet {
    char data[2048];
};
​
packet p;
memcpy ( p.data, "1024 datas.........", 1024 )
send ( socket, ( char* ) &p, sizeof ( p ) );
```

由于考虑到数据的溢出，变长数据包中的`data`数组长度一般会设置得足够长足以容纳最大的数据，因此`packet`中的`data`数组很多情况下都没有填满数据，因此造成了浪费。而如果我们用变长数组来进行封包的话，就不会造成浪费(最多会造成`4`个字节的浪费，包头的`int`型的`len`不属于数据，因此算是浪费)。例如前面的`Buffer`结构体，假如要发送`1024`个字节，该如何构造这个数据包呢？

``` cpp
char* tmp = ( char* ) malloc ( sizeof ( Buffer ) + 1024 );
```

这句代码的作用是申请一块连续的内存空间，这块内存空间的长度是`Buffer`的大小加上`1024`数据的大小。如果仔细观察的话，会发现这种申请方法比第一种多了一段`sizeof(Buffer)`大小的空间，原因何在？

``` cpp
Buffer *p = ( Buffer * ) tmp;
p->len = 1024;
memcpy ( p.cData, "1024 datas............", 1024 );
```

上面的三行代码首先做一个强制类型转换，`Buffer`类型的指针指向内存的起始位置。这段内存要分为两部分使用，前部分`4`个字节`p->len`作为包头(就是多出来的那部分)，这个包头是用来描述紧接着包头后面的数据部分的长度，这里是`1024`，所以前四个字节赋值为`1024`(既然我们要构造不定长数据包，那么这个包到底有多长呢？因此我们就必须通过一个变量来表明这个数据包的长度，这就是`len`的作用)，而紧接其后的内存是真正的数据部分，通过`p->cData`定位到该部分的起始地址，最后进行一个`memcpy`内存拷贝，把要发送的数据填入到这段内存当中。最后使用如下命令发送数据：

``` cpp
send ( socket, p, sizeof ( Buffer ) + 1024 );
```

&emsp;&emsp;柔性数组的具体用法如下：

``` cpp
#include <stdio.h>
#include <malloc.h>

typedef struct _soft_array {
    int len;
    int array[];
} SoftArray;

int main() {
    int i = 0;
    SoftArray* sa = ( SoftArray* ) malloc ( sizeof ( SoftArray ) + sizeof ( int ) * 10 );
    sa->len = 10;

    for ( i = 0; i < sa->len; i++ ) {
        sa->array[i] = i + 1;
    }

    for ( i = 0; i < sa->len; i++ ) {
        printf ( "%d\n", sa->array[i] );
    }

    free ( sa );
    return 0;
}
```

&emsp;&emsp;使用柔性数组计算裴波那契数字：

``` cpp
#include <stdio.h>
#include <malloc.h>

typedef struct _soft_array {
    int len;
    int array[];
} SoftArray;

SoftArray* create_soft_array ( int size ) {
    SoftArray* ret = NULL;

    if ( size > 0 ) {
        ret = ( SoftArray* ) malloc ( sizeof ( *ret ) + sizeof ( * ( ret->array ) ) * size );
        ret->len = size;
    }

    return ret;
}

void fac ( SoftArray* sa ) {
    int i = 0;

    if ( NULL != sa ) {
        if ( 1 == sa->len ) {
            sa->array[0] = 1;
        } else {
            sa->array[0] = 1;
            sa->array[1] = 1;

            for ( i = 2; i < sa->len; i++ ) {
                sa->array[i] = sa->array[i - 1] + sa->array[i - 2];
            }
        }
    }
}

void delete_soft_array ( SoftArray* sa ) {
    free ( sa );
}

int main() {
    int i = 0;
    SoftArray* sa = create_soft_array ( 10 );
    fac ( sa );

    for ( i = 0; i < sa->len; i++ ) {
        printf ( "%d\n", sa->array[i] );
    }

    delete_soft_array ( sa );
    return 0;
}
```