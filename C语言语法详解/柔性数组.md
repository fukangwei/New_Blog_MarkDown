---
title: 柔性数组
categories: C语言语法详解
date: 2018-12-08 12:58:58
---
&emsp;&emsp;在标准`C89`中，零长度的数组如`charArray[0]`是不允许使用的，但是`GUN`中却允许：<!--more-->

``` cpp
struct Packet {
    int state;
    int len;
    char cData[0];
};
```

&emsp;&emsp;零长度的数组主要用途是为了满足需要变动长度的结构体，在一个结构体的最后声明一个长度为`0`的数组，就可以使得这个结构体是可变长的。
&emsp;&emsp;对于编译器来说，此时长度为`0`的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量。对于这个数组的大小，我们可以进行动态分配。
&emsp;&emsp;零长度数组常用于网络通信中构造不定长的数据包，且不会浪费空间和网络流量：

``` cpp
struct Buffer {
    int len;
    char cData[0];
};
```

例如要发送`1024`字节的数据，如果使用定长数据包，假设定长数据包的长度为`2048`，那么就会浪费`1024`个字节的空间，造成不必要的流量浪费：

``` cpp
struct packet {
    char data[2048];
};

packet p;
memcpy ( p.data, "1024 datas.........", 1024 )
send ( socket, ( char* ) &p, sizeof ( p ) );
```

如果我们用变长数组来进行封包的话，就不会造成浪费(最多会造成`4`个字节的浪费，包头的`int`型的`len`不属于数据，因此算是浪费)。例如前面的`Buffer`结构体，假如要发送`1024`个字节，该如何构造这个数据包呢？

``` cpp
char* tmp = ( char* ) malloc ( sizeof ( Buffer ) + 1024 );
```

这句代码的作用是申请一块连续的内存空间，这块内存空间的长度是`Buffer`的大小加上`1024`数据的大小。如果仔细观察的话，会发现这种申请方法比第一种多了一段`sizeof(Buffer)`大小的空间，原因何在？

``` cpp
Buffer *p = ( Buffer * ) tmp;
p->len = 1024;
memcpy ( p.cData, "1024 datas............", 1024 );
```

上面的三行代码首先做一个强制类型转换，`Buffer`类型的指针指向内存的起始位置。这段内存要分为两部分使用，前部分`4`个字节`p->len`作为包头(就是多出来的那部分)，这个包头是用来描述紧接着包头后面的数据部分的长度，这里是`1024`，所以前四个字节赋值为`1024`(既然我们要构造不定长数据包，那么这个包到底有多长呢？因此我们就必须通过一个变量来表明这个数据包的长度，这就是`len`的作用)，而紧接其后的内存是真正的数据部分，通过`p->cData`定位到该部分的起始地址，最后进行一个`memcpy`内存拷贝，把要发送的数据填入到这段内存当中。最后使用如下命令发送数据：

``` cpp
send ( socket, p, sizeof ( Buffer ) + 1024 );
```

&emsp;&emsp;柔性数组的具体用法如下：

``` cpp
#include <stdio.h>
#include <malloc.h>

typedef struct _soft_array {
    int len;
    int array[];
} SoftArray;

int main() {
    int i = 0;
    SoftArray* sa = ( SoftArray* ) malloc ( sizeof ( SoftArray ) + sizeof ( int ) * 10 );
    sa->len = 10;

    for ( i = 0; i < sa->len; i++ ) {
        sa->array[i] = i + 1;
    }

    for ( i = 0; i < sa->len; i++ ) {
        printf ( "%d ", sa->array[i] );
    }

    free ( sa );
    printf ( "\n" );
    return 0;
}
```