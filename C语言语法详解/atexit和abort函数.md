---
title: atexit和abort函数
categories: C语言语法详解
abbrlink: 56c152af
date: 2018-12-10 21:39:36
---
### atexit函数

&emsp;&emsp;按照`ISO C`的规定，一个进程可以登记多达`32`个函数，这些函数将由`exit`自动调用，通常这`32`个函数被称为`终止处理程序`，并调用`atexit`函数来登记这些函数。<!--more-->
&emsp;&emsp;我们通常认为`C`语言的起始函数是`main`函数，实质上一个程序的启动函数并不一定是`main`函数，这个可以使用链接器来设置，但是`gcc`中默认`main`函数就是`C`语言的入口函数。在`main`函数启动之前，内核会调用一个特殊的启动例程，这个启动例程从内核中取得命令行参数值和环境变量值，为调用`main`函数做好准备。因此对程序而言，`main`函数并不是起始，但是对应`C`语言而言，`main`函数就是入口地址。实际上`main`函数的执行是使用了`exec`函数，这是一个函数族，这也是内核执行一个程序的唯一方法。
&emsp;&emsp;记得在面试题中有一道关于在`main`函数退出之后，是否还可以执行程序的问题，这时候就要使用到前面提到的`atexit`函数：

``` c
int atexit ( void ( *func ) ( void ) );
```

其中`atexit`的参数是一个函数地址，当调用此函数时无须传递任何参数，该函数也不能返回值。`atexit`函数称为`终止处理程序注册程序`，注册完成以后，当函数终止时，`exit`函数会主动地调用前面注册的各个函数。但是`exit`函数调用这些函数的顺序于这些函数登记的顺序是相反的，实际上是参数压栈造成的，参数由于压栈顺序而先入后出。同时如果一个函数被多次登记，那么该函数也将多次的执行。
&emsp;&emsp;我们知道`exit`是在`main`函数调用结束以后调用，因此这些函数的执行肯定在`main`函数之后，这也是上面面试题的解决方法，采用`atexit`函数登记相关的执行函数即可。
&emsp;&emsp;`exit`、`_exit`以及`_Exit`函数的本质区别是是否立即进入内核。`_exit`和`_Exit`函数都是在调用后立即进入内核，而不会执行一些清理处理，但是`exit`则会执行一些清理处理，这也是为什么会存在`atexit`函数的原因，因为`exit`函数需要执行清理处理，需要执行一系列的操作，这些终止处理函数实际上就是完成各种所谓的清除操作的实际执行体。`atexit`函数的定义也给了程序员一种运用`exit`执行一些清除操作的方法，比如有一些程序需要额外的操作，具体的清除操作可以采用这种方法对特殊操作进行清除等。

``` cpp
#include <stdio.h>
#include <stdlib.h>

void func1 ( void ) {
    printf ( "in func1\n" );
}

void func2 ( void ) {
    printf ( "in func2\n" );
}

void func3 ( void ) {
    printf ( "in func3\n" );
}

int main() {
    atexit ( func3 );
    atexit ( func2 );
    atexit ( func1 );
    printf ( "In main\n" );
    return 0;
}
```

执行结果：

``` bash
In main
in func1
in func2
in func3
```

&emsp;&emsp;根据`exit`的执行过程可知，`exit`首先会调用各个终止处理程序，然后按需多次调用`fclose`，关闭所有打开流。也就是说`exit`函数会执行一个标准`I/O`库的清理关闭操作：对所有打开的流调用`fclose`，这样就会造成所有缓冲的输出数据都被冲洗即写入文件中。
&emsp;&emsp;进程自愿终止的唯一方法是显式或者隐式地调用(通过`exit`函数)`_exit`或者`_Exit`函数，因此`exit`函数中实质是对`_exit`或者`_Exit`函数的封装。`exit`会先执行自定义的终止处理函数，然后执行`I/O`库函数清理函数`fclose`，这也是为什么可以在终止处理函数中可以继续运用`printf`之类函数的原因，因为`I/O`库函数的流对象还没有被清除，当然可以继续运用。执行完了所有的`fclose`以后，可以执行真正意义上的终止函数`_exit`或者`_Exit`函数。

---

### abort函数

&emsp;&emsp;`abort`函数用于非正常地终止一个正在执行的程序，其函数原型如下：

``` c
void abort( void );
```

这个函数将引发`SIGABRT`信号，你可以在程序中为这个信号设置一个信号处理函数，在程序终止(或干脆不终止)之前采取任何你想采取的动作，甚至可以不终止程序。
&emsp;&emsp;`abort`函数类似于`exit`函数，但调用它会导致异常的程序终止，`atexit`函数注册的退出函数不会被调用。根据具体的实现，它可能不会清理包含未输出数据的输出缓冲区，不会关闭打开的流，也不会删除临时文件。`abort`函数返回一个由实现定义的状态码来指出`不成功的终止`。
&emsp;&emsp;调用`abort`函数时，实际上会产生`SIGABRT`信号。如果没有处理`SIGABRT`信号的函数，那么程序会如前所述那样异常终止；如果为`SIGABRT`安装了信号处理函数，那么就会调用处理函数，处理函数返回后，程序会异常终止。但是如果处理函数不返回，例如它调用了`longjmp`函数，那么程序就不会终止。