---
title: 可重入和不可重入函数
date: 2018-12-08 13:38:20
categories: C语言语法详解
---
&emsp;&emsp;不可重入函数不可以在它还没有返回就再次被调用，例如`printf`、`malloc`、`free`等都是不可重入函数。因为中断可能在任何时候发生，例如在`printf`执行过程中，因此不能在中断处理函数里调用`printf`，否则`printf`将会被重入。
&emsp;&emsp;不可重入函数指的是该函数在被调用还没有结束以前，再次被调用可能会产生错误。可重入函数不存在这样的问题。
&emsp;&emsp;函数不可重入大多数是因为在函数中引用了全局变量。例如`printf`会引用全局变量`stdout`，`malloc`、`free`会引用全局的内存分配表。常见的不可重入函数有：

- `printf`：引用全局变量`stdout`。
- `malloc`：全局内存分配表。
- `free`：全局内存分配表。

&emsp;&emsp;在`unix`里面通常都有加上`_r`后缀的同名可重入函数版本。如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁等同步机制。下面引用一段别人的解释：
&emsp;&emsp;这主要在多任务环境中使用，一个可重入的函数简单来说，就是`可以被中断的函数`。你可以在这个函数执行的任何时候中断它的运行，在`OS`的调度下去执行另外一段代码而不会出现什么错误。而不可重入的函数由于使用了一些系统资源，比如全局变量区、中断向量表等，所以它如果被中断，可能出现问题，所以这类函数是不能运行在多任务环境下的。
&emsp;&emsp;把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的。

- 不要使用全局变量，因为别的代码很可能覆盖这些变量值。
- 在和硬件发生交互的时候，切记执行类似`disinterrupt`之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做`进入/退出核心`，或者用`OS_ENTER_KERNAL`和`OS_EXIT_KERNAL`来描述。
- 不能调用任何不可重入的函数。
- 谨慎使用堆栈，最好先在使用前先`OS_ENTER_KERNAL`。

&emsp;&emsp;可重入函数的示例：

``` cpp
void strcpy ( char* lpszDest, char* lpszSrc ) {
    while ( *lpszDest++ = *lpszSrc++ );
    ​*dest = 0;
}
```

&emsp;&emsp;非可重入函数`示例1`：

``` cpp
char cTemp; /* 全局变量 */

void SwapChar1 ( char* lpcX, char* lpcY ) {
    cTemp = *lpcX;
    *lpcX = *lpcY;
    lpcY = cTemp; /* 访问了全局变量，在分享内存的多个线程中可能造成问题 */
}
```

&emsp;&emsp;非可重入函数`示例2`：

``` cpp
void SwapChar2 ( char* lpcX, char* lpcY ) {
    static char cTemp; /* 静态局部变量 */
    cTemp = *lpcX;
    *lpcX = *lpcY;
    lpcY = cTemp; /* 使用了静态局部变量，在分享内存的多个线程中可能造成问题 */
}
```

&emsp;&emsp;如何写出可重入的函数？在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。