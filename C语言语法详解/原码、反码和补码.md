---
title: 原码、反码和补码
categories: C语言语法详解
date: 2018-12-09 00:40:15
mathjax: true
---
&emsp;&emsp;示例代码如下：<!--more-->

``` cpp
void main() {
    char* p;
    *p = -130;
    printf ( "%d", *p );
}
```

&emsp;&emsp;我们抛开程序的正确性不谈(没有给指针分配空间怎么能对指针进行解引用呢？)，仅仅分析一下程序的输出结果。首先我们需要分析一下`-130`在内存中的二进制存储方式。这就引出了有符号整数在内存中的存储方式：有符号整数在内存中是以补码形式存储的。
&emsp;&emsp;这里给出原码、反码和补码的定义：原码即有符号整数所对应的二进制数；正数的反码和本身一样，负数的反码是对应的原码除符号位以外，其它的数位依次取反；正数的补码和本身一样，负数的补码是对应的反码在末位加`1`。计算机中存储方式为补码的原因是为了使减法可以当做加法来算。其实，如果不采用补码的形式存储，内存中会出现`+0`和`-0`，这一现象可以在下面的例子中看到。举个简单的例子，如果计算机以`8`位的方式存储有符号整数，则：

数字 | 原码        | 反码         | 补码
-----|-------------|-------------|---------
 `1` | `0000_0001` | `0000_0001` | `0000_0001`
`-1` | `1000_0001` | `1111_1110` | `1111_1111`
 `0` | `0000_0000` | `0000_0000` | `0000_0000`

&emsp;&emsp;如果是反码存储的话，`-1 + 1 = 1111_1111`，`1111_1111`是`1000_0000`的反码，也就是`-0`。
&emsp;&emsp;接着来分析这个程序：`-130`在内存中以补码形式存储，在我的系统中，`int`类型占`4`个字节。那么`-130`的原码为`1000_0000_0000_0000_0000_0000_1000_0010`，反码为`1111_1111_1111_1111_1111_1111_0111_1101`，补码为`1111_1111_1111_1111_1111_1111_0111_1110`。
&emsp;&emsp;由于`*p`的数据类型是`char`，将`-130`赋值给`*p`会将数据从低位截断，结果是`0111_1110`。那么输出`*p`的时候，系统会将数据自动补上`0`，也就输出`0000_0000_0000_0000_0000_0000_0111_1110`，即`126`。

---

### 机器数和真值

&emsp;&emsp;在学习原码、反码和补码之前，需要先了解机器数和真值的概念。

#### 机器数

&emsp;&emsp;一个数在计算机中的二进制表示形式叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为`0`，负数为`1`。比如十进制中的数`+3`，假设计算机字长为`8`位，转换成二进制就是`0000_0011`；如果是`-3`，就是`1000_0011`。那么这里的`0000_0011`和`1000_0011`就是机器数。

#### 真值

&emsp;&emsp;因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数`1000_0011`，其最高位`1`代表负，其真正数值是`-3`而不是形式值`131`(`1000_0011`转换成十进制等于`131`)。所以为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例如`0000_0001`的真值为`+000_0001 = +1`，`1000_0001`的真值为`-000_0001 = -1`。

### 原码、反码和补码的基础概念和计算方法

&emsp;&emsp;在探求为何机器要使用补码之前，先了解原码、反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码、反码和补码是机器存储一个具体数字的编码方式。

#### 原码

&emsp;&emsp;原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是`8`位二进制：

``` bash
[+1]原 = 0000_0001
[-1]原 = 1000_0001
```

第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围是`[1111_1111, 0111_1111]`，即`[-127, 127]`。原码是人脑最容易理解和计算的表示方式。

#### 反码

&emsp;&emsp;反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反：

``` bash
[+1] = [0000_0001]原 = [0000_0001]反
[-1] = [1000_0001]原 = [1111_1110]反
```

如果一个反码表示的是负数，人脑无法直观地看出来它的数值，通常要将其转换成原码再计算。

#### 补码

&emsp;&emsp;补码的表示方法是：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后`+1`，即在反码的基础上`+1`。

``` bash
[+1] = [0000_0001]原 = [0000_0001]反 = [0000_0001]补
[-1] = [1000_0001]原 = [1111_1110]反 = [1111_1111]补
```

对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。

### 为何要使用原码、反码和补码

&emsp;&emsp;现在我们知道了计算机有三种编码方式表示一个数。对于正数，三种编码方式的结果都相同：

``` bash
[+1] = [0000_0001]原 = [0000_0001]反 = [0000_0001]补
```

对于负数：

``` bash
[-1] = [1000_0001]原 = [1111_1110]反 = [1111_1111]补
```

可见原码、反码和补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？
&emsp;&emsp;首先因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计得尽量简单。计算机辨别`符号位`显然会让它的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即`1 - 1 = 1 + (-1) = 0`，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。于是人们开始探索将符号位参与运算，并且只保留加法的方法。
&emsp;&emsp;首先来看原码，计算十进制的表达式`1 - 1 = 0`：

``` bash
1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [1000_0010]原 = -2
```

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。
&emsp;&emsp;为了解决原码做减法的问题，出现了反码：

``` bash
1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [0000_0001]反 + [1111_1110]反 = [1111_1111]反 = [1000_0000]原 = -0
```

发现用反码计算减法，结果的真值部分是正确的，而唯一的问题其实就出现在`0`这个特殊的数值上。虽然在人们的理解上`+0`和`-0`是一样的，但是`0`带符号是没有任何意义的，而且会有`[0000_0000]原`和`[1000_0000]原`两个编码表示`0`。补码的出现，解决了`0`的符号以及两个编码的问题：

``` bash
1 - 1 = 1 + (-1) = [0000_0001]原 + [1000_0001]原 = [0000_0001]补 + [1111_1111]补 = [0000_0000]补 = [0000_0000]原
```

这样`0`用`[0000_0000]`表示，而以前出现问题的`-0`则不存在了，而且可以用`[1000_0000]`表示`-128`：

``` bash
(-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补
```

`-1 - 127`的结果应该是`-128`，在用补码运算的结果中，`[1000_0000]补`就是`-128`。但是注意因为实际上是使用以前的`-0`的补码来表示`-128`，所以`-128`并没有原码和反码表示。对`-128`的补码表示`[1000_0000]补`算出来的原码是`[0000_0000]原`，这是不正确的。
&emsp;&emsp;使用补码不仅仅修复了`0`的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么`8`位二进制使用原码或反码表示的范围为`[-127, +127]`，而使用补码表示的范围为`[-128, 127]`。因为机器使用补码，所以对于编程中常用到的`32`位`int`类型，可以表示范围是`[-2^31, 2^31 - 1]`，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

### 原码、反码和补码深入理解

&emsp;&emsp;计算机巧妙地把符号位参与运算，并且将减法变成了加法，背后蕴含了怎样的数学原理呢？将钟表想象成是一个`1`位的`12`进制数，如果当前时间是`6`点，我希望将时间设置成`4`点，需要怎么做呢？我们可以：

- 往回拨`2`个小时，即`6 - 2 = 4`。
- 往前拨`10`个小时，即`(6 + 10) mod 12 = 4`。
- 往前拨`10 + 12 = 22`个小时，即`(6 + 22) mod 12 = 4`。

后两种方法中的`mod`是取模操作，`16 mod 12 = 4`即用`16`除以`12`后的余数是`4`，所以钟表往回拨(减法)的结果可以用往前拨(加法)替代。
&emsp;&emsp;现在的焦点就落在了如何用一个正数来替代一个负数，首先介绍`同余`的数学概念：两个整数`a`、`b`，若它们除以整数`m`所得的余数相等，则称`a`和`b`对于模`m`同余，记作`a ≡ b (mod m)`，读作`a`与`b`关于模`m`同余。举例说明，`4 mod 12 = 4`、`16 mod 12 = 4`、`28 mod 12 = 4`，所以`4`、`16`和`28`关于模`12`同余。
&emsp;&emsp;正数进行`mod`运算是很简单的，但是负数呢？下面是关于`mod`运算的数学定义：

\begin{align}
x \bmod y = x - y * \lfloor x/y \rfloor \notag
\end{align}

&emsp;&emsp;上面公式的意思是：`x mod y`等于`x`减去`y`乘上`x`与`y`的商的下界。以`-3 mod 2`举例：

``` bash
-3 mod 2
= -3 - 2 * floor(-3/2)
= -3 - 2 * floor(-1.5)
= -3 - 2 * (-2)
= -3 + 4 = 1
```

同理如下：

``` bash
(-2) mod 12 = 12 - 2 = 10
(-4) mod 12 = 12 - 4 = 8
(-5) mod 12 = 12 - 5 = 7
```

结合同余的概念，实际上：

``` bash
(-2) mod 12 = 10
10 mod 12 = 10
```

即`-2`与`10`是同余的。要实现用正数替代负数，只需要运用同余数的两个定理：

- 反身性：`a ≡ a (mod m)`。
- 线性运算定理：如果`a ≡ b (mod m)`，`c ≡ d (mod m)`，那么`a ± c ≡ b ± d (mod m)`，`a * c ≡ b * d (mod m)`。

如下所示：

``` bash
7 ≡ 7 (mod 12)
(-2) ≡ 10 (mod 12)
7 - 2 ≡ 7 + 10 (mod 12)
```

现在为一个负数找到了它的正数同余数，但是并不是`7 - 2 = 7 + 10`，而是`7 - 2 ≡ 7 + 10 (mod 12)`，即计算结果的余数相等。
&emsp;&emsp;接下来回到二进制的问题上，看一下`2 - 1 = 1`的问题：

``` bash
2 - 1 = 2 + (-1) = [0000_0010]原 + [1000_0001]原 = [0000_0010]反 + [1111_1110]反
```

先到这一步，`-1`的反码表示是`1111_1110`，如果这里将`1111_1110`认为是原码，则`[1111 1110]原`为`-126`，这里将符号位除去，即认为是`126`。发现有如下规律：

``` bash
(-1) mod 127 = 126
126 mod 127 = 126
```

即：

``` bash
(-1) ≡ 126 (mod 127)
2 - 1 ≡ 2 + 126 (mod 127)
```

`2 - 1`与`2 + 126`的余数结果是相同的！而这个余数，正式我们的期望的计算结果`2 - 1 = 1`。
&emsp;&emsp;所以说一个数的反码，实际上是这个数对于一个模的同余数，而这个模并不是我们的二进制，而是所能表示的最大值。这就和钟表一样，转了一圈后总能找到在可表示范围内的一个正确的数值。而`2 + 126`很显然相当于钟表转过了一轮，而因为符号位是参与计算的，正好和溢出的最高位形成正确的运算结果。
&emsp;&emsp;既然反码可以将减法变成加法，那么现在计算机使用的补码呢？演示如下：

``` bash
2 - 1 = 2 + (-1) = [0000_0010]原 + [1000_0001]原 = [0000_0010]补 + [1111_1111]补
```

如果把`[1111_1111]`当成原码，去除符号位，则`[0111_1111]原`为`127`。其实，在反码的基础上`+1`，只是相当于增加了模的值：

``` bash
(-1) mod 128 = 127
127 mod 128 = 127
2 - 1 ≡ 2 + 127 (mod 128)
```

此时表盘相当于每`128`个刻度转一轮，所以用补码表示的运算结果最小值和最大值应该是`[-128, 128]`。但由于`0`的特殊情况，没有办法表示`128`，所以补码的取值范围是`[-128, 127]`。