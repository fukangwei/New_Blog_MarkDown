---
title: 浮点型与零值比较
date: 2018-12-09 12:23:30
categories: C语言语法详解
---
&emsp;&emsp;该博客从网上整理了浮点型与零值比较有关的内容，感谢分享资料的人们！
&emsp;&emsp;如下的判断方法是错误的：

``` c
const float EPSINON = 0.00001;

if ( ( x >= - EPSINON ) && ( x <= EPSINON ) ) {
}
```

&emsp;&emsp;浮点数在内存中的存储机制和整型数是不同的，有舍入误差，在计算机中用近似的方式表示任意浮点数。具体的说，这个实数由一个整数或定点数(即尾数)乘以某个基数(计算机中通常是2)的整数次幂得到，类似于基数为10的科学记数法。所以浮点数在运算中通常伴随着因为无法精确表示而进行的近似或舍入。但是这种设计的好处是可以在固定的长度上存储更大范围的数。
&emsp;&emsp;例如，一个指数范围为`±4`的4位十进制浮点数可以用来表示`43210`、`4.321`或`0.0004321`，但是没有足够的精度来表示`432.123`和`43212.3`(必须近似为`432.1`和`43210`)。当然，实际使用的位数通常远大于4。所以浮点数不能够判断相等，像`if(x == 0)`的这样的编码不总是正确的。在判断浮点数相等时，推荐用范围来确定，若x在某一范围内，我们就认为相等。
&emsp;&emsp;`if ( (x >= - EPSINON) && (x <= EPSINON) )`这样判断是可取的，至于为什么取`0.00001`，可以自己按实际情况定义。再看下面CSDN上的回答：浮点数是不可以直接比较大小的，因为是非精确存储，只能设置一个精度，然后在允许误差内的就认为是相等的；对浮点型数比较的时候用`==`是不对的。

``` c
#define EPSIMON 0.000001
fabs ( ( ( a + b ) + c ) - ( ( b + a ) + c ) ) < EPSIMON
```

&emsp;&emsp;C/C++语言中，浮点数常量默认就是`double`。可以使用`f`，来明确指定为`float`型，例如`0.5f`。浮点数不是不能精确地表示，比如`0.5`、`0.25`、`0.125`等。对于可以精确表示的浮点数来说，`==`符号也是有意义的。考虑到精度问题，两个实际不等的数值，比如`10000000.00000001`和`10000000`在PC当中被表示成为相同的数字了。对于可以确切表示的两个浮点数，`a + b`和`b + a`永远是相等的，但`(a + b) + c`和`(a + c) + b`就不一定了。
&emsp;&emsp;对double类型的数据进行比较也要使用上述方法。例如判断一个数是否在0至100的范围内：

``` c
#define EPSIMON 1e-10

double value = xxx;

if ( ( value - 0 >= -EPSIMON ) && ( value <= 100 + EPSIMON ) ) {
    /* user code */
}
```