---
title: Shell脚本的特殊符号
categories: Shell编程
abbrlink: 7ad3cd74
date: 2019-01-21 16:37:52
---
### 井号

&emsp;&emsp;除了第一行`#!/bin/bash`，井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。如果被用在指令中，被引号、双引号括住或者在倒斜线的后面，那么它就变成一般符号，不具上述的特殊功能。

### 帐户的home目录

&emsp;&emsp;它算是个常见的符号，代表使用者的`home`目录，如`cd ~`；也可以直接在符号后加上某帐户的名称，如`cd ~user`；或者当成是路径的一部份，如`~/bin`。
&emsp;&emsp;`~+当前的工作目录`这个符号代表当前的工作目录，它和内建指令`pwd`的作用是相同的：

``` bash
# echo ~+/var/log
```

`~-上次的工作目录`这个符号代表上次的工作目录：

``` bash
# echo ~-/etc/httpd/logs
```

### 分号

&emsp;&emsp;在`shell`中，担任连续指令功能的符号就是分号，例如`cd ~/backup ; mkdir startup`。

### 连续分号

&emsp;&emsp;专用在`case`的选项，担任`Terminator`的角色：

``` bash
case \"$fop\" inhelp)
    echo \"Usage: Command -help -version filename\";;version)
    echo \"version 0.1\"
    ;;
esac
```

### 逗号

&emsp;&emsp;在`shell`中，一个`dot`代表当前目录，两个`dot`代表上层目录。如果档案名称以`dot`开头，该档案就属特殊档案，用`ls`指令必须加上`-a`选项才会显示。除此之外，在`regularexpression`中，一个`dot`代表匹配一个字元。

### 单引号

&emsp;&emsp;被单引号用括住的内容将被视为单一字串。在引号内的代表变数的`$`符号没有作用，也就是说它被视为一般符号处理，防止任何变量替换：

``` bash
heyyou=home
echo '$heyyou'  # We get $heyyou
```

### 双引号

&emsp;&emsp;被双引号用括住的内容将被视为单一字串。它防止通配符扩展，但允许变量扩展，这点与单引数的处理方式不同：

``` bash
heyyou=home
echo \"$heyyou\"  # We get home
```

### 反引号

&emsp;&emsp;在前面的单双引号括住的是字串，但如果该字串是一列命令会怎样？答案是不会执行。要处理这种情况，需要用反引号来做：

``` bash
fdv=`date +%F`
echo \"Today $fdv\"
```

在反引号内的`date +%F`会被视为指令，执行的结果会带入`fdv`变数中。命令替换也可以使用语法`$(shell_command)`。

### 逗点

&emsp;&emsp;这个符号常运用在运算当中当做间隔用途：

``` bash
#!/bin/bash
let \"t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\"
echo \"t1= $t1, a = $a, b = $b\"
```

### 斜线

&emsp;&emsp;在路径表示时，代表目录；通常单一的`/`代表`root`根目录；在四则运算中，代表除法的符号。

``` bash
let \"num1 = ((a = 10 / 2, b = 25 / 5))\"
```

### 管道

&emsp;&emsp;`pipeline`连接上个指令的标准输出，做为下个指令的标准输入：

``` bash
who | wc -l
```

### 惊叹号

&emsp;&emsp;通常代表反逻辑的作用，例如用`!=`代表不等于：

``` bash
if [ \"$?\" != 0 ]
then
    echo \"Executes error\"
    exit 1
fi
```

在规则表达式中，它担任反逻辑的角色：

``` bash
ls a[!0-9]
```

上例代表显示除`a0`、`a1`、`...`、`a9`这几个文件的其他文件。

### 冒号

&emsp;&emsp;在bash中，这是一个内建指令，表示什么事都不干，但返回状态值`0`。

``` bash
:
echo $?  # 输出为0
```

也有如下用法：

``` bash
: > f.$$
```

上面这一行相当于`cat /dev/null >f.$$`，不仅写法简短了，而且执行效率也好许多。有时也会出现以下这类的用法：

``` bash
: ${HOSTNAME?} ${USER?} ${MAIL?}
```

这行的作用是检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似`test`或`if`这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。

### 问号

&emsp;&emsp;在文件名扩展上扮演的角色是匹配一个任意的字元，但不包含`null`字元。

``` bash
ls a?a1
```

善用这个特点，可以做比较精确的档名匹配。

### 星号

&emsp;&emsp;在文件名扩展上，它用来代表任何字元，包含`null`字元。

``` bash
ls a*a a1 access_log
```

在运算时，它则代表乘法。

``` bash
let \"fmult=2*3\"
```

除了内建指令`let`，还有一个关于运算的指令`expr`，星号在这里也担任乘法的角色。不过在使用上需要小心，它的前面必须加上`escape`字元。

### 次方运算

&emsp;&emsp;两个星号`**`在运算时代表次方的意思：

``` bash
let \"sus=2**3\"
echo \"sus = $sus\"  # 输出“sus = 8”
```

### 钱号

&emsp;&emsp;变量替换的代表符号：

``` bash
vrs=123
echo \"vrs = $vrs\"  # 输出“vrs = 123”
```

另外，在`Regular Expressions`里被定义为`行`的最末端(`end-of-line`)。这个常用在`grep`、`sed`、`awk`以及`vim`当中。

### &#36;*

&emsp;&emsp;`$*`引用`script`的执行引用变量，引用参数的算法与一般指令相同，指令本身为`0`，其后为`1`，然后依此类推。引用变量的代表方式如下：

``` bash
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}...
```

个位数的，可直接使用数字；但两位数以上，则必须使用`{}`符号来括住。
&emsp;&emsp;`$*`则是代表所有引用变量的符号，使用时需要视情况加上双引号：

``` bash
echo \"$*\"
```

### &#36;@

&emsp;&emsp;`$@`与`$*`具有相同作用的符号，不过它们两者有一个不同点。`$*`将所有的引用变量视为一个整体，但`$@`则仍旧保留每个引用变量的区段观念。

<h3> &#36;# </h3>

&emsp;&emsp;这也是与引用变量相关的符号，它的作用是告诉你，引用变量的总数量是多少。

``` bash
echo \"$#\"
```

### &#36;?状态值

&emsp;&emsp;一般来说，`UNIX`系统的进程以执行系统调用`exit`来结束的。这个函数的回传值就是`status`值，回传给父进程，用来检查子进程的执行状态。一般指令程序倘若执行成功，其回传值为`0`，失败则为`1`。

``` bash
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho\"$?\"$$
```

由于进程的`ID`是唯一的，所以在同一个时间不可能有重复性的`PID`。有时，`script`会需要产生临时文件，用来存放必要的资料，而此`script`亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠，唯有产生动态文件名，才能符合需要。符号`$$`或许可以符合这种需求，它代表当前`shell`的`PID`。

``` bash
echo \"$HOSTNAME, $USER, $MAIL\" > ftmp.$$
```

使用它来作为文件名的一部份，可以避免在同一时间产生相同文件名的覆盖现象。
&emsp;&emsp;基本上，系统会回收执行完毕的`PID`，然后再次依需要分配使用。所以`script`即使临时文件是使用动态档名的写法，如果`script`执行完毕后仍不加以清除，会产生其他问题。

### \(\)指令群组

&emsp;&emsp;用括号将一串连续指令括起来，这种用法称为指令群组：

``` bash
(cd ~ ; vcgh=`pwd` ; echo $vcgh)
```

指令群组有一个特性，`shell`会以产生`subshell`来执行这组指令。因此在其中所定义的变数，仅作用于指令群组本身。
&emsp;&emsp;除了上述的指令群组，括号也用在`array`变数的定义上；另外也应用在其他可能需要加上`escape`字元才能使用的场合，如运算式。

### (())

&emsp;&emsp;这组符号的作用与`let`指令相似，用在算数运算上，它是`bash`的内建功能。所以在执行效率上会比使用`let`指令要好许多。

### 大括号

&emsp;&emsp;有时`script`当中会出现大括号中会夹着一段或几段以`分号`做结尾的指令或变数设定。这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的`shell`执行，不会产生`subshell`。
&emsp;&emsp;大括号也被运用在函数的功能上，广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写`script`也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简`script`的复杂度。此外，大括号还有另一种用法：

``` bash
{xx, yy, zz, ...}
```

这种大括号的组合，常用在字串的组合上：

``` bash
mkdir {userA, userB, userC}-{home, bin, data}
```

我们得到`userA-home`、`userA-bin`、`userA-data`、`userB-home`、`userB-bin`、`userB-data`、`userC-home`、`userC-bin`、`userC-data`这几个目录。这组符号在适用性上相当广泛，能加以善用的话，回报是精简与效率。

### 中括号

&emsp;&emsp;常出现在流程控制中，扮演括住判断式的作用：

``` bash
if [ \"$?\" != 0 ]
then
    echo \"Executes error\"
    exit 1
fi
```

这个符号在正则表达式中担任类似`范围`或`集合`的角色：

``` bash
rm -r 200[1234]
```

上例代表删除`2001`、`2002`、`2003`、`2004`等目录的意思。

### [[]]

&emsp;&emsp;这组符号与先前的`[]`符号，基本上作用相同，但它允许在其中直接使用`||`与`&&`逻辑等符号。

``` bash
#!/bin/bash
read ak
​
if [[ $ak > 5 || $ak< 9 ]]
then
    echo $ak
fi
```

### \|\|逻辑符号

&emsp;&emsp;代表`or`逻辑的符号。

### &&逻辑符号

&emsp;&emsp;代表`and`逻辑的符号：

``` bash
command1 && command2 [&& command3 ...]
```

`&&`左边的命令(命令`1`)返回真后，其右边的命令(命令`2`)才能够被执行。

### 后台工作

&emsp;&emsp;单一个`&`符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。