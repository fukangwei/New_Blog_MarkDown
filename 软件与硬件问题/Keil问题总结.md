---
title: Keil问题总结
categories: 软件与硬件问题
date: 2019-02-14 18:12:20
---
### transfer of control bypasses initialization of

&emsp;&emsp;Example:<!--more-->

``` cpp
int main ( void ) {
    int choice = 1;
    int z = 1;

    switch ( choice ) {
        case 1:
            int y = 1;
            z = y + z;
            break;
        case 2:
            break;
    }

    return 0;
}
```

&emsp;&emsp;Here, `y` is an initialized variable that is in scope (范围) (but unused) in the other cases. The `C++ Standard` says in section `6.7`: It is possible to transfer (转移) into a block, but not in a way that bypasses (绕过) declarations with initialization. A program that jumps from a point where a local variable with automatic storage duration is not in scope to a point where it is in scope is `ill-formed` (病态的) unless the variable has `POD` type and is declared without an initializer.
&emsp;&emsp;The transfer from the condition of a switch statement to a case label is considered a jump in this respect. The usual way to fix this is to enclose (把...围起来) the case that declares `y` in braces (括弧):

``` cpp
case 1: {
    int y = 1;
    z = y + z;
}

break;
```

`y` is a `POD` (Plain Old Data) type, so an alternative (替代的) would be to not use initialization：

``` cpp
case 1:
    int y;
    y = 1;
    z = y + z;
    break;
```

### warning: \#1293-D: assignment in condition

&emsp;&emsp;出现这样的问题，代码是可以继续正常执行的，但是写法不太严谨。因为在`while/if`的条件中，系统期望的是一个布尔类型的值(即`0`或`1`)，当表达式传递的结果非布尔值类型时，就会出现这样的警告。

### WARNING: L6306W: '~PRES8' SECTION SHOULD NOT USE 'REQ8'

&emsp;&emsp;QUESTION: I have written an interrupt handler in assembly language using the `RealView` assembler. In this interrupt handler, I am calling another routine that is written in `C`. When I link my program, I receive the following warning: `Warning: L6306W: '~PRES8' section arm_isr.o (asm_irq) should not use the address of 'REQ8' function (c_func)`.
&emsp;&emsp;ANSWER：All `C` code generated by the `RealView` compiler assumes that stack allocation is aligned on `8-byte` boundaries. You must ensure that the assembler interrupt handler has an `8-byte` aligned stack by specifying the `PRESERVE8` directive at the beginning of your assembly file. For example,

``` cpp
    PRESERVE8
.
.
    AREA irq_asm, CODE, READONLY
```

### integer operation result is out of range (61-D)

&emsp;&emsp;在编写测试程序的过程中，有这样的宏定义：

``` cpp
#define UART1_EN ( 1 << 31 )
```

编译后编译器报错`integer operation result is out of range (61-D)`。经查资料，这是由于溢出所致：宏定义默认常量是有符号型，当左移`31`位时，常数就变成负数，编译器就会给出如上的警告信息。解决办法是强制类型转换成无符号类型：

``` cpp
#define UART1_EN ( ( U32 ) 1 << 31 )
```

### the size of an array must be greater than zero

&emsp;&emsp;`Zero-sized` arrays are allowed only when in `GNU` mode (`--gnu`)。For example：`char name[0];`. method: `Options for target -> C/C++ -> Misc Control -> input "--gnu"`.

### error: declaration may not appear after executable statement in block

&emsp;&emsp;在程序中声明变量时，需要在可执行语句之前声明，否则会出现以上错误。

``` cpp
vu16 KeyPortState = 0;
SystemInit();
KeyScanState_Typedef KeyScanState = KeyScanState_0;
GPIO_Configuration();
```

编译会出现错误，原因是`KeyScanState_Typedef KeyScanState = KeyScanState_0;`在`SystemInit();`之后。正确的函数语句为：

``` cpp
vu16 KeyPortState = 0;
KeyScanState_Typedef KeyScanState = KeyScanState_0;
SystemInit();
GPIO_Configuration();
```

### warning: #1134-D: literal treated as "long long"

&emsp;&emsp;在`Keil`中有如下代码：

``` cpp
unsigned int value = 2147483648;
```

`value`在编译时会产生上述警告。`2147483648`是一个字面常量，类型是`int`型，而不是`unsigned int`型。需要先将`int`类型转换成`unsigned int`类型，再赋值给`value`。在转换过程中，因为这个数值超过`32`位`int`类型的表示范围，所以会出现上述警告。如果你想要明白告诉编译器`2147483648`就是`unsigned`类型，可以这么做：

``` cpp
unsigned int value = 2147483648u;
```

### error: #20: identifier "TIM6_IRQn" is undefined

&emsp;&emsp;打开`STM32F103RB`的启动文件`starup_stm32f10x_md.s`，里面有如下内容：

``` cpp
DCD TIM1_BRK_IRQHandler     ; TIM1 Break
DCD TIM1_UP_IRQHandler      ; TIM1 Update
DCD TIM1_TRG_COM_IRQHandler ; TIM1 Trigger and Commutation
DCD TIM1_CC_IRQHandler      ; TIM1 Capture Compare
DCD TIM2_IRQHandler         ; TIM2
DCD TIM3_IRQHandler         ; TIM3
DCD TIM4_IRQHandler         ; TIM4
```

这里面只有`TIM1`至`TIM4`的定时器中断事件，而`TIM6`是没有中断响应这个功能，这是因为`STM32F103RB`芯片没有`TIM6`。

### cannot open source input file "stm32f10x_lib.h": No such file or directory

&emsp;&emsp;将`cortexm3_macro.h`、`stm32f10x_conf.h`、`stm32f10x_it.h`、`stm32f10x_map.h`、`stm32f10x_nvic.h`和`stm32f10x_type.h`拷贝到工程文件夹下。将源文件中的`#include <stm32f10x_lib.h>`替换成`#include <stm32f10x_map.h>`和`#include <stm32f10x_nvic.h>`。

---

### REFERENCE MADE TO UNRESOLVED EXTERNAL

&emsp;&emsp;出现上述警告的原因是变量或者函数只是在头文件中进行了声明，没有在源文件中进行定义。只要在源文件中对变量或者函数进行定义即可。

### ERROR L104: MULTIPLE PUBLIC DEFINITIONS

&emsp;&emsp;出现上述错误则是因为变量被重复定义，把头文件中的变量定义前加`extern`(只是变量声明不用初始化)，再在某一个你要调用该变量的`C`文件的程序之前再定义。

### MULTIPLE CALL TO SEGMENT

&emsp;&emsp;该警告表示连接器发现有一个函数可能会被主函数和一个中断服务程序(或者调用中断服务程序的函数)同时调用，或者同时被多个中断服务程序调用。出现这种问题的原因之一是这个函数是不可重入性函数，当该函数运行时它可能会被一个中断打断，从而使得结果发生变化并可能会引起一些变量形式的冲突(即引起函数内一些数据的丢失，可重入性函数在任何时候都可以被`ISR`打断，一段时间后又可以运行，但是相应数据不会丢失)。可以采用以下几种方法：

- 主程序调用该函数时禁止中断，可以在该函数被调用时用`#pragma disable`语句来实现禁止中断的目的。
- 复制两份该函数的代码，一份到主程序中，另一份复制到中断服务程序中。
- 将该函数设为重入型：

``` cpp
void myfunc(void) reentrant {
    /* ... */
}
```

这种设置将会产生一个可重入堆栈，该堆栈被用于存储函数值和局部变量。使用这种方法时，重入堆栈必须在`STARTUP.A51`文件中配置。这种方法消耗更多的`RAM`并会降低重入函数的执行速度。

### unprintable character 0xA1 skipped

&emsp;&emsp;因为程序中含有全角字符，`Keil`无法识别。全角字符和`ASCII`码显示在屏幕上几乎是一样的，所以人眼很容易就错过了。可以使用半角全角转换工具，将文件中的全角字符转换为半角字符。

### ERROR L105: PUBLIC REFERS TO IGNORED SEGMENT

&emsp;&emsp;该错误说明单片机的`data`空间已经不够用了，需要在工程`Options`的`Target`目录下，将`Memory Model`设置成`Large:variables in XDATA`。