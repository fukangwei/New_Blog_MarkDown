---
title: 宏定义使用技巧
categories: C语言应用代码
abbrlink: 8692c4b3
date: 2019-02-04 12:40:35
---
&emsp;&emsp;1. 防止一个头文件被重复包含：

``` cpp
#ifndef COMDEF_H
#define COMDEF_H
​
/* 头文件内容 */
​
#endif
```

&emsp;&emsp;2. 重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，从而方便移植：

``` cpp
typedef unsigned char     boolean; /* Boolean value type    */
typedef unsigned long int uint32;  /* Unsigned 32 bit value */
typedef unsigned short    uint16;  /* Unsigned 16 bit value */
typedef unsigned char     uint8;   /* Unsigned 8 bit value  */
typedef signed long int   int32;   /* Signed 32 bit value   */
typedef signed short      int16;   /* Signed 16 bit value   */
typedef signed char       int8;    /* Signed 8 bit value    */
```

&emsp;&emsp;3. 得到指定地址上的一个字节或字：

``` cpp
#define MEM_B( x ) ( * ( ( byte * ) ( x ) ) )
#define MEM_W( x ) ( * ( ( word * ) ( x ) ) )
```

&emsp;&emsp;4. 求最大值和最小值：

``` cpp
#define MAX( x, y ) ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) )
#define MIN( x, y ) ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) )
```

&emsp;&emsp;5. 得到`field`在结构体`struct`中的偏移量：

``` cpp
#define FPOS( type, field ) ( ( dword ) & ( ( type * ) 0 )-> field )
```

&emsp;&emsp;6. 得到一个结构体中`field`所占用的字节数：

``` cpp
#define FSIZ( type, field ) sizeof ( ( ( type * ) 0 )->field )
```

&emsp;&emsp;7. 按照`LSB`格式把两个字节转化为一个`Word`：

``` cpp
#define FLIPW( ray ) ( ( ( ( word ) ( ray ) [0] ) * 256 ) + ( ray ) [1] )
```

&emsp;&emsp;8. 按照`LSB`格式把一个`Word`转化为两个字节：

``` cpp
#define FLOPW( ray, val )            \
    ( ray ) [0] = ( ( val ) / 256 ); \
    ( ray ) [1] = ( ( val ) & 0xFF )
```

&emsp;&emsp;9. 得到一个变量的地址(`word`宽度)：

``` cpp
#define B_PTR( var ) ( ( byte * ) ( void * ) & ( var ) )
#define W_PTR( var ) ( ( word * ) ( void * ) & ( var ) )
```

&emsp;&emsp;10. 得到一个字的高位和低位字节：

``` cpp
#define WORD_LO(x) ( ( byte ) ( ( word ) ( x ) & 255 ) )
#define WORD_HI(x) ( ( byte ) ( ( word ) ( x ) >> 8 ) )
```

&emsp;&emsp;11. 返回一个比X大的最接近的`8`的倍数：

``` cpp
#define RND8( x ) ( ( ( ( x ) + 7 ) / 8 ) * 8 )
```

&emsp;&emsp;12. 将一个字母转换为大写：

``` cpp
#define UPCASE( c ) ( ( ( c ) >= 'a' && ( c ) <= 'z' ) ? ( ( c ) - 0x20 ) : ( c ) )
```

&emsp;&emsp;13. 判断字符是不是`10`进值的数字：

``` cpp
#define DECCHK( c ) ( ( c ) >= '0' && ( c ) <= '9' )
```

&emsp;&emsp;14. 判断字符是不是`16`进值的数字：

``` cpp
#define HEXCHK( c ) (                   \
    ( ( c ) >= '0' && ( c ) <= '9' ) || \
    ( ( c ) >= 'A' && ( c ) <= 'F' ) || \
    ( ( c ) >= 'a' && ( c ) <= 'f' ) )
```

&emsp;&emsp;15. 防止溢出的一个方法：

``` cpp
#define INC_SAT( val ) ( val = ( ( val ) + 1 > ( val ) ) ? ( val ) + 1 : ( val ) )
```

&emsp;&emsp;16. 返回数组元素的个数：

``` cpp
#define ARR_SIZE( a ) ( sizeof ( ( a ) ) / sizeof ( ( a[0] ) ) )
```

&emsp;&emsp;17. 对于`IO`空间映射在存储空间的结构，输入输出处理：

``` cpp
#define inp( port )         ( * ( ( volatile byte * ) ( port ) ) )
#define inpw( port )        ( * ( ( volatile word * ) ( port ) ) )
#define inpdw( port )       ( * ( ( volatile dword * ) ( port ) ) )
#define outp( port, val )   ( * ( ( volatile byte * ) ( port ) ) = ( ( byte ) ( val ) ) )
#define outpw( port, val )  ( * ( ( volatile word * ) ( port ) ) = ( ( word ) ( val ) ) )
#define outpdw( port, val ) ( * ( ( volatile dword * ) ( port ) ) = ( ( dword ) ( val ) ) )
```

&emsp;&emsp;18. 使用宏进行跟踪调试：

``` cpp
#ifdef _DEBUG
    #define DEBUGMSG(msg, date) printf ( msg ); printf ( "%d %d %d", date, _LINE_, _FILE_ )
#else
    #define DEBUGMSG(msg, date)
#endif
```

&emsp;&emsp;19. 使用`do{}while(0)`语句可以防止宏定义错误：

``` cpp
#define DO(a, b) do { \
        a + b;        \
        a++;          \
    } while ( 0 )
```

&emsp;&emsp;20. 将宏定义得像函数一样：

``` cpp
#include <stdio.h>
​
#define SWAP(a, b)    \
    {                 \
        int temp = a; \
        a = b;        \
        b = temp;     \
    }
​
int main ( void ) {
    int a = 1;
    int b = 2;
    SWAP ( a, b );
    printf ( "a = %d, b = %d\n", a, b );
    return 0;
}
```