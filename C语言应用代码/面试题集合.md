---
title: 面试题集合
categories: C语言应用代码
date: 2019-02-04 13:42:27
---
&emsp;&emsp;12. 求`n`个数(`1`至`n`)中`k`个数的组合，例如`combination(5, 3)`的输出结果是`543、542、541、532、531、521、432、431、421、321`。

``` cpp
#include <stdio.h>
#include "iostream"

int pop(int *);
int push(int);
void combination(int, int);

int stack[3] = { 0 };
signed int top = -1;

int main() {
    int n, m;
    printf("Input two numbers:\n");

    while ((2 != scanf_s("%d%*c%d", &n, &m))) {
        fflush(stdin);
        printf("Input error! Again:\n");
    }

    combination(n, m);
    printf("\n");
    return 0;
}

void combination(int m, int n) {
    int temp = m;
    push(temp);

    while (1) {
        if (1 == temp) {
            if (pop(&temp) && stack[0] == n) {
                break;
            }
        } else if (push(--temp)) {
            printf("%d%d%d  ", stack[0], stack[1], stack[2]);
            pop(&temp);
        }
    }
}

int push(int i) {
    stack[++top] = i;

    if (top < 2) {
        return 0;
    } else {
        return 1;
    }
}
int pop(int *i) {
    *i = stack[top--];

    if (top >= 0) {
        return 0;
    } else {
        return 1;
    }
}
```

&emsp;&emsp;14. 输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，要求时间复杂度是`O(n)`。如果有多对数字的和等于输入的数字，输出任意一对即可。例如输入数组`{1, 2, 4, 7, 11, 15}`和数字`15`，由于`4 + 11 = 15`，因此输出`4`和`11`。
&emsp;&emsp;由于数组是有序的，因此可以用双指针来做。指针`i`指向`a[0]`，指针`j`指向`a[n-1]`，若`a[i] + a[j] > v`，则`j--;`；若`a[i] + a[j] < v`，则`i++;`；若`a[i] + a[j] = v`，则结束：

``` cpp
#include <iostream>
#include <stdlib.h>

using namespace std;

void find(int a[], int n, int v) {
    int i = 0;
    int j = n - 1;

    while (i < j) {
        if (a[i] + a[j] < v) {
            i++;
        } else if (a[i] + a[j] > v) {
            j--;
        } else {
            cout << a[i] << " + " << a[j] << " = " << v << endl;
            return;
        }
    }
}

int main() {
    int a[10] = { 1, 3, 6, 8, 11, 13, 15, 17, 20, 22 };
    find(a, 10, 4);
    return 0;
}
```

&emsp;&emsp;15. 输入两个整数`n`和`m`，从数列`{1, 2, 3, ..., n}`中随意取几个数，使其和等于`m`，要求将其中所有的可能组合列出来。
&emsp;&emsp;本题其实就是考察数的组合，对于此类问题，通常手段都是递归，而我们的目标就在于找出递归式。问题其实本质上就是`0/1`背包问题，对于每一个`n`，我们采用贪婪策略，先考察是否取`n`，如果取`n`，那么子问题就变成了`find(n-1, m-n)`；如果舍弃`n`，子问题则为`find(n-1, m)`。至此，我们利用`DP`思想找到了递归式。
&emsp;&emsp;那么如何制定解的判定策略？我们知道，递归需要边界条件，而针对背包问题，边界条件只有两种：如果`n < 1`或者`m < 1`，那么便相当于`溢出`；而另一种可能就是在剩余的`n`个数据里恰好满足`m == n`，即此时背包刚好填充满，输出一组解单元。我们设置`flag`背包用来标注对应的`n`是否被选中，`1`表示被选中，`0`则表示未选中。

``` cpp
#include <stdio.h>
#include <stdlib.h>

int length;

void findCombination(int n, int m, int *flag) {
    if (n < 1 || m < 1) {
        return;
    }

    if (n > m) {
        n = m;
    }

    if (n == m) {
        flag[n - 1] = 1;

        for (int i = 0; i < length; i++) {
            if (flag[i] == 1) {
                printf("%d\t", i + 1);
            }
        }

        printf("\n");
        flag[n - 1] = 0;
    }

    flag[n - 1] = 1;
    findCombination(n - 1, m - n, flag);
    flag[n - 1] = 0;
    findCombination(n - 1, m, flag);
}

int main() {
    int n, m;
    scanf_s("%d %d", &n, &m);
    length = n;
    int *flag = (int *)malloc(sizeof(int) * length);
    printf("------------------\n");
    findCombination(n, m, flag);
    free(flag);
    return 0;
}
```

&emsp;&emsp;18. 一个整数数组的长度为`n`，将其分为`m`份，使各份的和相等，求`m`的最大值。比如`{3, 2, 4, 3, 6}`可以分成`{3, 2, 4, 3, 6}`，即`m = 1`；也可以分为`{3, 6}`和`{2, 4, 3}`，即`m = 2`；也可以分为`{3, 3}`、`{2, 4}`和`{6}`，即`m = 3`，所以`m`最大值为`3`：

``` cpp
#include <cstdio>
#include <cstdlib>

#define NUM 7

int maxShares(int a[], int n);

// aux[i]的值表示数组a中第i个元素分在哪个组，值为0表示未分配
// 当前处理的组的现有和 + goal的值 = groupsum
int testShares(int a[], int n, int m, int sum, int groupsum, int aux[], int goal, int groupId);

int main() {
    int a[] = { 8, 4, 3, 3, 2, 2, 2 };
    printf("数组的值：");

    for (int i = 0; i < NUM; i++) {
        printf("%d ", a[i]);
    }

    printf("\n可以分配的最大组数为：%d\n", maxShares(a, NUM));
    return 0;
}

int testShares(int a[], int n, int m, int sum, int groupsum,
               int aux[], int goal, int groupId) {
    if (goal < 0) {
        return 0;
    }

    if (goal == 0) {
        groupId++;
        goal = groupsum;

        if (groupId == m + 1) {
            return 1;
        }
    }

    for (int i = 0; i < n; i++) {
        if (aux[i] != 0) {
            continue;
        }

        aux[i] = groupId;

        if (testShares(a, n, m, sum, groupsum, aux, goal - a[i], groupId)) {
            return 1;
        }

        aux[i] = 0; /* 如果a[i]分配失败，将其置为未分配状态 */
    }

    return 0;
}

int maxShares(int a[], int n) {
    int sum = 0;
    int *aux = (int *)malloc(sizeof(int) * n);

    for (int i = 0; i < n; i++) {
        sum += a[i];
    }

    for (int m = n; m >= 2; m--) {
        if (sum % m != 0) {
            continue;
        }

        for (int i = 0; i < n; i++) {
            aux[i] = 0;
        }

        if (testShares(a, n, m, sum, sum / m, aux, sum / m, 1)) {
            printf("\n分组情况：");

            for (int i = 0; i < NUM; i++) {
                printf("%d ", aux[i]);
            }

            free(aux);
            aux = NULL;
            return m;
        }
    }

    free(aux);
    aux = NULL;
    return 1;
}
```

&emsp;&emsp;19. 输入一个正数`n`，输出所有和为`n`连续正数序列。例如输入`15`，由于`1 + 2 + 3 + 4 + 5 = 4 + 5 + 6 = 7 + 8 = 15`，所以输出`3`个连续序列：即`1`至`5`、`4`至`6`和`7`至`8`。
&emsp;&emsp;我们用一个`small`指示序列中最小值，用`big`指示序列中的最大值，因为和为`n`的序列至少需要两个数字，因而`small`取值是从`1`到中点。如果`small + big < n`，就让`big`后移，以此增大`sum`；而如果`small + big > n`，就让`small`前移，以此缩小`sum`；如果`small + big = n`，打印从`small`到`big`之间的所有值即可。

``` cpp
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

void FindContinuousNumbers(int n) {
    int small = 1;
    int big = 2;
    int middle = (n + 1) / 2;
    int sum = small + big;

    while (small < middle) {
        if (sum == n) {
            for (int i = small; i <= big; ++i) {
                cout << i << "\t";
            }

            cout << endl;
        }

        while (sum > n) {
            sum -= small;
            small++;

            if (sum == n) {
                for (int i = small; i <= big; ++i) {
                    cout << i << "\t";
                }

                cout << endl;
            }
        }

        big++;
        sum += big;
    }
}

int main() {
    cout << "Enter your Number: ";
    int number = 0;
    cin >> number;
    cout << "The sum equals your number is as following:" << endl;
    FindContinuousNumbers(number);
    return 0;
}
```

&emsp;&emsp;21. 有`n`根棍子，棍子`i`的长度为`ai`，想要从中选出三根棍子组成周长尽可能长的三角形。请输出最大的周长，若无法组成三角形则输出`0`。

``` cpp
#include <stdio.h>
#include <stdlib.h>

int MAX(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int a[10] = { 0 };
    int n = 0;
    scanf_s("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf_s("%d", &a[i]);
    }

    int ans = 0; /* 答案 */

    for (int i = 0; i < n; i++) { /* 让“i < j < k”，这样棍子就不会被重复选取了 */
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                int l = a[i] + a[j] + a[k]; /* 周长 */
                int max = MAX(a[i], MAX(a[j], a[k])); /* 找出最长的棍子 */
                int rest = l - max; /* 其余两根棍子的长度之和 */

                if (rest > max) { /* 如果可以构成三角形，则更新最大周长 */
                    ans = MAX(ans, l);
                }
            }
        }
    }

    printf("%d\n", ans);
    return 0;
}
```

&emsp;&emsp;22. `n`只蚂蚁以每秒`1cm`的速度在长为`Lcm`的竿子上爬行，当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离`xi`，但不知道它当前的朝向。请计算所有蚂蚁落下竿子所需的最短时间和最长时间。
&emsp;&emsp;可以知道两只蚂蚁相遇后，当它们保持原样交错而过继续前进也不会有任何问题。这样看来，可以认为每只蚂蚁都是独立运动的，所以要求最长时间，只要求蚂蚁到竿子端点的最大距离就好了。

``` cpp
#include <iostream>
#include <algorithm>
#include <cstdlib>

using namespace std;

int L = 10, n = 3;
int x[] = { 2, 6, 7 };

void solve() {
    int minT = 0; /* 计算最短时间 */

    for (int i = 0; i < n; i++) {
        minT = max(minT, min(x[i], L - x[i]));
    }

    int maxT = 0; /* 计算最长时间 */

    for (int i = 0; i < n; i++) {
        maxT = max(maxT, max(x[i], L - x[i]));
    }

    cout << "min is " << minT << "; max is " << maxT << endl;
}

int main() {
    solve();
    return 0;
}
```

&emsp;&emsp;23. 有一个大小为`N*M`的园子，雨后积了很多水，八连通的积水被认为是在一起的(八连通是指下图中相对于`+`的`*`部分)，请求出园子里共有多少个水洼？例如输入`N`为`10`，`M`为`12`，园子如下图所示(`+`表示积水，`*`表示没有积水)，则输出为`3`：

``` cpp
+********++*
*+++*****+++
****++***++*
*********++*
*********+**
**+******+**
*+*+*****++*
+*+*+*****+*
*+*+******+*
**+*******+*
```

代码如下：

``` cpp
#include "iostream"
#include "cstdlib"

using namespace std;

const int N = 10;
const int M = 12;

char garden[N][M + 1] = { /* 园子 */
    "+********++*",
    "*+++*****+++",
    "****++***++*",
    "*********++*",
    "*********+**",
    "**+******+**",
    "*+*+*****++*",
    "+*+*+*****+*",
    "*+*+******+*",
    "**+*******+*"
};

void dfs(int x, int y);

void solve() {
    int count = 0;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (garden[i][j] == '+') {
                dfs(i, j);
                count++;
            }
        }
    }

    cout << count << endl;
}

void dfs(int x, int y) { /* 现在的位置是(x,y) */
    garden[x][y] = '*'; /* 将现在的位置替换为“*” */

    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            int nx = x + dx, ny = y + dy; /* 向x方向移动dx，向y方向移动dy */

            /* 判断(nx,ny)是否在园子里，以及是否有水 */
            if (nx >= 0 && nx < N && ny >= 0 && ny < M && garden[nx][ny] == '+') {
                dfs(nx, ny);
            }
        }
    }
}

int main() {
    solve();
    return 0;
}
```