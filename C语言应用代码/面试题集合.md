---
title: 面试题集合
categories: C语言应用代码
date: 2019-02-04 13:42:27
---
&emsp;&emsp;1. 在`1901`年`1`月`1`日至`2000`年`12`月`31`日间共有多少个星期天落在每月第一天上？前提为`1900.1.1`是星期一。<!--more-->

``` cpp
#include "stdio.h"

int is_leap_year ( int year ) { /* 判断是否为闰年 */
    if ( ( year % 400 == 0 ) || ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) ) {
        return 1;
    }

    return 0;
}

int main ( void ) {
    int year; /* 定义年份 */
    int sum_sun = 0; /* 定义星期天的数量 */
    /* 从1900年1月1日起对应的天数，此刻为1900年12月1日，注意1900年是闰年 */
    unsigned int year_day = 366 - 31;

    for ( year = 1901; year <= 2000; year++ ) {
        int month; /* 定义月份 */

        for ( month = 1; month <= 12; month++ ) {
            switch ( month ) {
                case 1: case 2: case 4: case 6:
                case 8: case 9: case 11:
                    year_day += 31; break;
                case 5: case 7: case 10: case 12:
                    year_day += 30;
                    break;
                case 3:
                    if ( is_leap_year ( year ) == 1 ) { /* 如果当年是闰年 */
                        year_day += 29;
                    } else {
                        year_day += 28;
                    }

                    break;
            }

            if ( ( year_day % 7 ) == 0 ) {
                /* 打印为每月第一天为星期天的时间 */
                printf ( "%d - %d\n", year, month );
                sum_sun++;
            }
        }
    }

    printf ( "The sum is %d\n", sum_sun );
}
```

&emsp;&emsp;2. 一条长廊里依次装有`n`(`1 ≤ n ≤ 65535`)盏电灯，从头到尾编号`1、2、3、...、n-1、n`。每盏电灯由一个拉线开关控制。开始，电灯全部关着。有`n`个学生从长廊穿过。第一个学生把号码凡是`1`的倍数的电灯的开关拉一下；接着第二个学生把号码凡是`2`的倍数的电灯的开关拉一下；接着第三个学生把号码凡是`3`的倍数的电灯的开关拉一下；如此继续下去，最后第`n`个学生把号码凡是`n`的倍数的电灯的开关拉一下。`n`个学生按此规定走完后，长廊里电灯有几盏亮着。
&emsp;&emsp;方案`1`如下：

``` cpp
#include "stdio.h"

int main ( int argc, char const *argv[] ) {
    unsigned int i, n, k;
    int sum = 0;
    char light[65535] = {0};
    printf ( "input n: " );
    scanf ( "%d", &n );

    for ( i = 0; i < n; i++ ) {
        for ( k = 0; k < 65535; k++ ) {
            if ( ( k + 1 ) % ( i + 1 ) == 0 ) {
                light[k] = !light[k];
            }
        }
    }

    for ( i = 0; i < 65535; i++ ) {
        if ( light[i] == 1 ) {
            sum++;
        }
    }

    printf ( "sum is %d\n", sum );
    return 0;
}
```

该代码的缺点是耗费的时间太长，输入`65535`后，运行了近`30`秒。
&emsp;&emsp;对于任何一盏灯，由于它原来不亮，那么当它的开关被按奇数次时，灯是开着的；当它的开关被按偶数次时，灯是关着的；一盏灯的开关被按的次数，恰等于这盏灯编号的因数的个数。要求哪些灯还亮着，就是问哪些灯编号的因数有奇数个，显然完全平方数有奇数个因数。每个数除以一个数`A`等于另一个数`B`，那么`A`和`B`都是它的因数，于是因数是成对出现的。但要求因数是奇数个，就必须使两个因数相等，即`A = B`。综上所述这道题就是找`1`至`65535`中完全平方数的个数，只有编号为`1`、`4`、`9`、`16`、`25`等编号的电灯最后是亮着的。方案`2`如下：

``` cpp
#include <stdio.h>

int main ( int argc, char *argv[] ) {
    unsigned int n;

    while ( scanf ( "%d", &n ) == 1 ) {
        int ans = 0;

        for ( unsigned int i = 1;; ++i ) {
            if ( i * i > n ) {
                break;
            }

            ++ans;
        }

        printf ( "%d\n", ans );
    }

    return 0;
}
```

&emsp;&emsp;3. 读取文件`file1.txt`的内容(例如`12\n34\n56`)，逆序输出到`file2.txt`中(`56\n34\n12`)：

``` cpp
#include <stdio.h>
#include <stdlib.h>

#define MAX 10
int size;

int main ( void ) {
    FILE *sorcefp, *dstfp;
    int *a = ( int * ) malloc ( sizeof ( int ) * MAX );
    size = MAX;

    if ( NULL == a ) {
        printf ( "error !\n" );
        exit ( -1 );
    }

    sorcefp = fopen ( "file1.txt", "r" );

    if ( NULL == sorcefp ) {
        printf ( "error !\n" );
        exit ( -1 );
    }

    dstfp = fopen ( "file2.txt", "w" );

    if ( NULL == dstfp ) {
        printf ( "error !\n" );
        exit ( -1 );
    }

    int i = 0, j = 0;

    while ( fscanf ( sorcefp, "%d", &a[i] ) != EOF ) {
        i++;
        j++;

        if ( i >= MAX ) {
            int *b = ( int * ) realloc ( a, MAX * sizeof ( int ) + size );
            size = size + MAX;

            if ( NULL == b ) {
                printf ( "error !\n" );
                exit ( -1 );
            }

            a = b;
        }
    }

    for ( ; --j >= 0; ) {
        fprintf ( dstfp, "%d\n", a[j] );
    }

    fclose ( sorcefp );
    fclose ( dstfp );
    return 0;
}
```

&emsp;&emsp;4. 计算两个整数在相加时需要进位多少次：

``` cpp
#include "stdio.h"

int main ( int argc, char const *argv[] ) {
    int a, b;

    while ( scanf ( "%d%d", &a, &b ) == 2 ) {
        if ( !a && !b ) {
            return 0;
        }

        int c = 0, ans = 0;

        for ( int i = 9; i >= 0; i-- ) {
            c = ( a % 10 + b % 10 + c ) > 9 ? 1 : 0;
            ans += c;
            a /= 10;
            b /= 10;
        }

        printf ( "%d\n", ans );
    }

    return 0;
}
```

&emsp;&emsp;5. 请在小于`99999`的正整数中找符合下列条件的数，它既是完全平方数，又有两位数字相同，如`144`和`676`。

``` cpp
#include <stdio.h>
#include <math.h>

/* 函数havesamenum确认num是否满足条件 */
int havesamenum ( int num ) {
    int i = 0, j;
    char a[10] = {0};

    while ( num > 0 ) {
        j = num % 10;
        a[j] += 1;
        num = num / 10;
    }

    while ( a[i] <= 1 && i < 10 ) {
        i++;
    }

    if ( i < 10 ) {
        return 1;
    } else {
        return 0;
    }
}

int main ( void ) {
    int i, j, m;
    m = ( int ) sqrt ( 99999 );

    for ( i = 1; i < m; i++ ) {
        j = i * i;

        if ( 1 == havesamenum ( j ) ) {
            printf ( "%6d\t", j );
        }
    }

    return 0;
}
```

&emsp;&emsp;6. 网球中心共有`100`个网球场，每个单位可以来申请`1`到`100`的场地，申请的场地编号必须是连续的，如果场地已经被其他单位占用，就不能再次使用，而且单位在使用完场地后必须归还。

``` cpp
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>

struct TennisGround {
    int num;
    char *agentName;
};

typedef struct TennisGround TG;

void mallocTG ( TG *total ) {
    int size, start, count = 0;
    TG *check = NULL;
    char *agentName = ( char * ) malloc ( sizeof ( char ) * 10 );
    printf ( "Please input your agentName:" );
    scanf ( "%s", agentName );
    printf ( "Please input the size of the TennisGround:" );
    scanf ( "%d", &size );
    printf ( "Please input the TennisGround number you want to start:" );
    scanf ( "%d", &start );

    for ( check = total + start; check <= total + start + size; check++ ) {
        if ( check->agentName != " " ) {
            printf ( "malloc failed!\n" );
            exit ( -1 );
        }
    }

    while ( count < size ) {
        ( total + start + count )->agentName = agentName;
        count++;
    }

    free ( agentName );
}

void freeTG ( TG *total ) {
    char *an = ( char * ) malloc ( sizeof ( char ) * 10 );
    printf ( "please input agentName you want to free:" );
    scanf ( "%s", an );
    int count = 0;

    while ( count < 100 ) {
        if ( strcmp ( ( total + count )->agentName, an ) == 0 ) {
            ( total + count )->agentName = " ";
        }

        count++;
    }
}

int main() {
    int i;
    int sw;
    TG *total = ( TG * ) malloc ( sizeof ( TG ) * 100 );

    for ( i = 0; i < 100; i++ ) {
        ( total + i )->num = i;
        ( total + i )->agentName = " ";
    }

    while ( 1 ) {
        printf ( "*******Tennis Ground Mallocation******************\n" );

        for ( i = 0; i < 100; i++ ) {
            printf ( "%d(%s) ", ( total + i )->num, ( total + i )->agentName );

            if ( i % 5 == 0 ) {
                printf ( "\n" );
            }
        }

        printf ( "\n" );
        printf ( "**************************************************\n" );
        printf ( "Please input your choosen:(1-malloc,2-free):" );
        scanf ( "%d", &sw );

        if ( sw == 1 ) {
            mallocTG ( total );
        } else {
            freeTG ( total );
        }
    }

    return 0;
}
```

&emsp;&emsp;7. 求出用`1`、`2`和`5`这三个数不同个数组合的和为`100`的组合个数，例如`100`个`1`是一个组合，`5`个`1`加`19`个`5`是一个组合。分析：事实上，这个题目是一道明显的数学问题，而不是单纯的编程问题。我的解法如下：因为`x + 2y + 5z = 100`，所以`x + 2y = 100 - 5z`，且`z <= 20；x <= 100；y <= 50`，所以`(x + 2y) <= 100`，且`x + 5z`是偶数。对`z`作循环，求`x`的可能值如下：

``` cpp
z = 0，x = 100、98、96、... 0
z = 1，x = 95、93、...、1
z = 2，x = 90、88、...、0
z = 3，x = 85、83、...、1
z = 4，x = 80、78、...、0
......
z = 19，x = 5、3、1
z = 20，x = 0
```

因此，组合总数为`100以内的偶数 + 95以内的奇数 + 90以内的偶数 + ... +5以内的奇数 + 1`。某个偶数`m`以内的偶数个数(包括`0`)可以表示为`m / 2 + 1 = (m + 2) / 2`，某个奇数`m`以内的奇数个数也可以表示为`(m + 2) / 2`，所以求总的组合次数可以编程为：

``` cpp
int number = 1;

for ( int m = 5; m <= 100; m += 5 ) {
    number += ( m + 2 ) / 2;
}

printf ( "%d", number );
```

&emsp;&emsp;8. 编写一个函数，要求输入年月日时分秒，输出该年月日时分秒的下一秒。如输入`2004`年`12`月`31`日`23`时`59`分`59`秒，则输出`2005`年`1`月`1`日`0`时`0`分`0`秒。

``` cpp
#include <stdio.h>

void NextMinute ( int *nYear, int *nMonth, int *nDate, int *nHour, int *nMinute, int *nSecond ) {
    int nDays;
    ( *nSecond )++; /* 秒加1 */

    if ( *nSecond >= 60 ) { /* 秒满60，做出特殊处理，下面时、日、月等类似 */
        *nSecond = 0;
        ( *nMinute )++;

        if ( *nMinute >= 60 ) {
            *nMinute = 0;
            ( *nHour )++;

            if ( *nHour >= 24 ) {
                *nHour = 0;
                ( *nDate )++;

                switch ( *nMonth ) {
                    case 1: case 3: case 5: case 7:
                    case 8: case 10: case 12:
                        nDays = 31;
                        break;
                    case 2: /* 判断闰年 */
                        if ( *nYear % 400 == 0 || *nYear % 100 != 0 && *nYear % 4 == 0 ) {
                            nDays = 29;
                        } else {
                            nDays = 28;
                        }

                        break;
                    default:
                        nDays = 30;
                        break;
                }

                if ( *nDate > nDays ) {
                    *nDate = 1;
                    ( *nMonth )++;

                    if ( *nMonth > 12 ) {
                        *nMonth = 1;
                        ( *nYear )++;
                    }
                }
            }
        }
    }
}

int main() {
    int nYear = 2004, nMonth = 12, nDate = 31, nHour = 59, nMinute = 59, nSecond = 59;
    NextMinute ( &nYear, &nMonth, &nDate, &nHour, &nMinute, &nSecond );
    printf ( "The result:%d-%d-%d %d:%d:%d", nYear, nMonth, nDate, nHour, nMinute, nSecond );
    return 0;
}
```

&emsp;&emsp;9. 文件中有一组整数，要求排序后输出到另一个文件中：

``` cpp
#include <iostream>
#include <fstream>
#include <vector>

using namespace std;

void Order ( vector<int> &data ) { /* bubble sort */
    int count = data.size();
    int tag = false;

    for ( int i = 0; i < count; i++ ) {
        for ( int j = 0; j < count - i - 1; j++ ) {
            if ( data[j] > data[j + 1] ) {
                tag = true;
                int temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
            }
        }

        if ( !tag ) {
            break;
        }
    }
}

int main ( void ) {
    vector<int> data;
    ifstream in ( "data.txt" );

    if ( !in ) {
        cout << "file error!";
        exit ( 1 );
    }

    int temp;

    while ( !in.eof() ) {
        in >> temp;
        data.push_back ( temp );
    }

    in.close(); /* 关闭输入文件流 */
    Order ( data );
    ofstream out ( "result.txt" );

    if ( !out ) {
        cout << "file error!";
        exit ( 1 );
    }

    for ( int i = 0; i < data.size(); i++ ) {
        out << data[i] << " ";
    }

    out.close(); /* 关闭输出文件流 */
}
```

&emsp;&emsp;10. 递归判断数组是否为递增数组：

``` cpp
#include <iostream>

using namespace std;

bool fun ( int a[], int n ) {
    if ( n == 1 ) {
        return true;
    }

    if ( n == 2 ) {
        return a[n - 1] >= a[n - 2];
    }

    return fun ( a, n - 1 ) && ( a[n - 1] >= a[n - 2] );
}

int main ( void ) {
    int a[6] = {4, 8, 9, 10, 11, 12};
    int count = sizeof ( a ) / sizeof ( a[0] );
    cout << fun ( a, count ) << endl;
}
```

&emsp;&emsp;11、写一段程序，找出数组中第`k`大小的数，输出数所在的位置。例如`{2, 4, 3, 4, 7}`中第一大的数是`7`，位置在`4`；第二大、第三大的数都是`4`，位置在`1`、`3`，随便输出哪一个均可。

``` cpp
#include <iostream>

using namespace std;

int Partition(int *L, int low, int high) {
    int temp = L[low];
    int pt = L[low];

    while (low < high) {
        while (low < high && L[high] >= pt) {
            --high;
        }

        L[low] = L[high];

        while (low < high && L[low] <= pt) {
            ++low;
        }

        L[low] = temp;
    }

    L[low] = temp;
    return low;
}

void QSort(int *L, int low, int high) {
    if (low < high) {
        int pl = Partition(L, low, high);
        QSort(L, low, pl - 1);
        QSort(L, pl + 1, high);
    }
}

int main() {
    int narry[100], addr[100];
    int sum = 1, t;
    cout << "Input number:" << endl;
    cin >> t;

    while (t != -1) {
        narry[sum] = t;
        addr[sum - 1] = t;
        sum++;
        cin >> t;
    }

    sum -= 1;
    QSort(narry, 1, sum);

    for (int i = 1; i <= sum; i++) {
        cout << narry[i] << '\t';
    }

    cout << endl;
    int k;
    cout << "Please input place you want:" << endl;
    cin >> k;
    int aa = 1;
    int kk = 0;

    for (;;) {
        if (aa == k) {
            break;
        }

        if (narry[kk] != narry[kk + 1]) {
            aa += 1;
            kk++;
        }
    }

    cout << "The NO." << k << " number is: " << narry[sum - kk] << endl;
    cout << "And it's place is: ";

    for (int i = 0; i < sum; i++) {
        if (addr[i] == narry[sum - kk]) {
            cout << i << '\t';
        }
    }

    return 0;
}
```

&emsp;&emsp;12. 求`n`个数(`1`至`n`)中`k`个数的组合，例如`combination(5, 3)`的输出结果是`543、542、541、532、531、521、432、431、421、321`。

``` cpp
#include <stdio.h>
#include "iostream"

int pop(int *);
int push(int);
void combination(int, int);

int stack[3] = { 0 };
signed int top = -1;

int main() {
    int n, m;
    printf("Input two numbers:\n");

    while ((2 != scanf_s("%d%*c%d", &n, &m))) {
        fflush(stdin);
        printf("Input error! Again:\n");
    }

    combination(n, m);
    printf("\n");
    return 0;
}

void combination(int m, int n) {
    int temp = m;
    push(temp);

    while (1) {
        if (1 == temp) {
            if (pop(&temp) && stack[0] == n) {
                break;
            }
        } else if (push(--temp)) {
            printf("%d%d%d  ", stack[0], stack[1], stack[2]);
            pop(&temp);
        }
    }
}

int push(int i) {
    stack[++top] = i;

    if (top < 2) {
        return 0;
    } else {
        return 1;
    }
}
int pop(int *i) {
    *i = stack[top--];

    if (top >= 0) {
        return 0;
    } else {
        return 1;
    }
}
```

&emsp;&emsp;13. 在二叉树中找出和为某一值的所有路径。从树的根结点开始往下访问，一直到叶结点，所经过的所有结点形成一条路径，然后打印出和与输入整数相等的所有路径。例如输入整数`22`和如下二元树：

``` bash
    10
   / \
  5  12
 / \
4   7
```

则打印出两条路径，即`10,12`和`10,5,7`。

``` cpp
#include <stdio.h>
#include <stdlib.h>

#define M 100

int path[M], top = -1;

struct BinaryTreeNode {
    int data;
    BinaryTreeNode *pLeft, *pRight;
    BinaryTreeNode() {
        pLeft = pRight = NULL;
    }
};

bool addNode(BinaryTreeNode **root, int value) {
    if (*root != NULL) {
        if (value > (*root)->data) {
            addNode(&((*root)->pRight), value);
        } else if (value < (*root)->data) {
            addNode(&((*root)->pLeft), value);
        } else {
            printf("repeated node!\n");
            return false;
        }
    } else {
        BinaryTreeNode *p;
        p = new BinaryTreeNode();
        p->data = value;
        *root = p;
    }

    return true;
}

void search(BinaryTreeNode *cur, int sum, int &s) {
    path[++top] = cur->data;

    if (cur->pLeft == NULL && cur->pRight == NULL && s == sum + cur->data) {
        for (int i = 0; i <= top; i++) {
            printf("%d ", path[i]);
        }

        printf("\n");
    }

    if (sum + cur->data >= s) { /* 剪枝 */
        --top;
        return;
    }

    if (cur->pLeft != NULL) {
        search(cur->pLeft, sum + cur->data, s);
    }

    if (cur->pRight != NULL) {
        search(cur->pRight, sum + cur->data, s);
    }

    --top;
}

int main() {
    int data[5] = { 10, 5, 12, 4, 7 };
    BinaryTreeNode *root = NULL;

    for (int i = 0; i < 5; i++) {
        addNode(&root, data[i]);
    }

    int a = 22;
    search(root, 0, a);
    return 0;
}
```

&emsp;&emsp;14. 输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，要求时间复杂度是`O(n)`。如果有多对数字的和等于输入的数字，输出任意一对即可。例如输入数组`{1, 2, 4, 7, 11, 15}`和数字`15`，由于`4 + 11 = 15`，因此输出`4`和`11`。
&emsp;&emsp;由于数组是有序的，因此可以用双指针来做。指针`i`指向`a[0]`，指针`j`指向`a[n-1]`，若`a[i] + a[j] > v`，则`j--;`；若`a[i] + a[j] < v`，则`i++;`；若`a[i] + a[j] = v`，则结束：

``` cpp
#include <iostream>
#include <stdlib.h>

using namespace std;

void find(int a[], int n, int v) {
    int i = 0;
    int j = n - 1;

    while (i < j) {
        if (a[i] + a[j] < v) {
            i++;
        } else if (a[i] + a[j] > v) {
            j--;
        } else {
            cout << a[i] << " + " << a[j] << " = " << v << endl;
            return;
        }
    }
}

int main() {
    int a[10] = { 1, 3, 6, 8, 11, 13, 15, 17, 20, 22 };
    find(a, 10, 4);
    return 0;
}
```

&emsp;&emsp;15. 输入两个整数`n`和`m`，从数列`{1, 2, 3, ..., n}`中随意取几个数，使其和等于`m`，要求将其中所有的可能组合列出来。
&emsp;&emsp;本题其实就是考察数的组合，对于此类问题，通常手段都是递归，而我们的目标就在于找出递归式。问题其实本质上就是`0/1`背包问题，对于每一个`n`，我们采用贪婪策略，先考察是否取`n`，如果取`n`，那么子问题就变成了`find(n-1, m-n)`；如果舍弃`n`，子问题则为`find(n-1, m)`。至此，我们利用`DP`思想找到了递归式。
&emsp;&emsp;那么如何制定解的判定策略？我们知道，递归需要边界条件，而针对背包问题，边界条件只有两种：如果`n < 1`或者`m < 1`，那么便相当于`溢出`；而另一种可能就是在剩余的`n`个数据里恰好满足`m == n`，即此时背包刚好填充满，输出一组解单元。我们设置`flag`背包用来标注对应的`n`是否被选中，`1`表示被选中，`0`则表示未选中。

``` cpp
#include <stdio.h>
#include <stdlib.h>

int length;

void findCombination(int n, int m, int *flag) {
    if (n < 1 || m < 1) {
        return;
    }

    if (n > m) {
        n = m;
    }

    if (n == m) {
        flag[n - 1] = 1;

        for (int i = 0; i < length; i++) {
            if (flag[i] == 1) {
                printf("%d\t", i + 1);
            }
        }

        printf("\n");
        flag[n - 1] = 0;
    }

    flag[n - 1] = 1;
    findCombination(n - 1, m - n, flag);
    flag[n - 1] = 0;
    findCombination(n - 1, m, flag);
}

int main() {
    int n, m;
    scanf_s("%d %d", &n, &m);
    length = n;
    int *flag = (int *)malloc(sizeof(int) * length);
    printf("------------------\n");
    findCombination(n, m, flag);
    free(flag);
    return 0;
}
```

&emsp;&emsp;16. 从考试成绩中划出及格线：`10`个学生考完期末考试评卷完成后，老师需要划出及格线，要求如下：及格线是`10`的倍数；保证至少有`60%`的学生及格；如果所有的学生都高于`60`分，则及格线为`60`分。样例输入为`61 51 49 30 20 10 70 80 90 99`，样例输出为`50`：

``` cpp
#include <stdio.h>
#include <stdlib.h>

int main() {
    int a[10], i, s[7] = { 0 };

    for (i = 0; i < 10; i++) {
        scanf_s("%d", &a[i]);

        switch (a[i] / 10) {
            case 10: case 9: case 8: case 7:
            case 6: s[6]++; break;
            case 5: s[5]++; break;
            case 4: s[4]++; break;
            case 3: s[3]++; break;
            case 2: s[2]++; break;
            case 1: s[1]++; break;
            case 0: s[0]++; break;
        }
    }

    for (i = 6; i > 0; i--) {
        if (s[i] >= 6) {
            break;
        } else {
            s[i - 1] += s[i];
        }
    }

    printf("%d\n", i * 10);
    return 0;
}
```

&emsp;&emsp;17. 地铁换乘：已知`2`条地铁线路，其中`A`为环线，`B`为东西向线路，线路都是双向的。经过的站点名分别如下，两条线交叉的换乘点用`T1`、`T2`表示：

- 地铁线`A`(环线)经过车站：`{A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18}`。
- 地铁线`B`(直线)经过车站：`{B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15}`。

编写程序，任意输入两个站点名称，输出乘坐地铁最少需要经过的车站数量(含输入的起点和终点，换乘站点只计算一次)：

``` cpp
#include <iostream>
#include <string>
#include <stack>

using namespace std;

#define SIZE_A 21
#define SIZE_B 17

#define N 35
#define INF 0xfffff

string A[] = {
    "A1", "A2", "A3", "A4", "A5", "A6", "A7",
    "A8", "A9", "T1", "A10", "A11", "A12", "A13",
    "T2", "A14", "A15", "A16", "A17", "A18", "A1"
};

string B[] = {
    "B1", "B2", "B3", "B4", "B5", "T1", "B6", "B7", "B8",
    "B9", "B10", "T2", "B11", "B12", "B13", "B14", "B15"
};

string Node[] = {
    "A1", "A2", "A3", "A4", "A5", "A6", "A7",
    "A8", "A9", "T1", "A10", "A11", "A12", "A13",
    "T2", "A14", "A15", "A16", "A17", "A18", "B1",
    "B2", "B3", "B4", "B5", "B6", "B7", "B8",
    "B9", "B10", "B11", "B12", "B13", "B14", "B15"
};

int matrix[N][N];

int dist[N][N];
int path[N][N];

int length = 0;

string StrBegin, StrEnd;

void Floyd_Warshall();

int GetPos(string *array, string &str) {
    int n = 0;

    if (str[0] == 'B') {
        n += 20;
        array += 20;
    }

    if (str == "T1") {
        return 9;
    }

    if (str == "T2") {
        return 14;
    }

    while (*array != str) {
        array++;
        n++;
    }

    return n;
}

void BuildGraph() {
    for (int i = 0; i < N; i++) { /* 初始化matrix */
        for (int j = 0; j < N; j++) {
            matrix[i][j] = 0;
        }
    }

    for (int i = 0; i < (SIZE_A - 1); i++) { /* 根据A建立边信息 */
        int u = GetPos(Node, A[i]);
        int v = GetPos(Node, A[i + 1]);
        matrix[u][v] = 1;
        matrix[v][u] = 1;
    }

    for (int i = 0; i < (SIZE_B - 1); i++) { /* 根据B建立边信息 */
        int u = GetPos(Node, B[i]);
        int v = GetPos(Node, B[i + 1]);
        matrix[u][v] = 1;
        matrix[v][u] = 1;
    }

    Floyd_Warshall();
}

void Floyd_Warshall() {
    for (int i = 0; i < N; i++) { /* 初始化 */
        for (int j = 0; j < N; j++) {
            if (i != j && matrix[i][j] > 0) {
                dist[i][j] = matrix[i][j];
                path[i][j] = i;
            } else {
                dist[i][j] = INF;
                path[i][j] = -1;
            }
        }
    }

    for (int k = 0; k < N; k++) { /* Floyd核心三层循环 */
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = path[k][j];
                }
            }
        }
    }

    /* 输出结果 */
    int u = GetPos(Node, StrBegin);
    int v = GetPos(Node, StrEnd);

    while (u != v) {
        v = path[u][v];
        length++;
    }

    length++;
}

int main() {
    length = 0;
    cin >> StrBegin >> StrEnd;

    if (StrBegin == StrEnd) {
        cout << "1" << endl;
    } else {
        BuildGraph();
        cout << length << endl;
    }

    return 0;
}
```

如果输入`A1 A3`，则输出`3`。

&emsp;&emsp;18. 一个整数数组的长度为`n`，将其分为`m`份，使各份的和相等，求`m`的最大值。比如`{3, 2, 4, 3, 6}`可以分成`{3, 2, 4, 3, 6}`，即`m = 1`；也可以分为`{3, 6}`和`{2, 4, 3}`，即`m = 2`；也可以分为`{3, 3}`、`{2, 4}`和`{6}`，即`m = 3`，所以`m`最大值为`3`：

``` cpp
#include <cstdio>
#include <cstdlib>

#define NUM 7

int maxShares(int a[], int n);

// aux[i]的值表示数组a中第i个元素分在哪个组，值为0表示未分配
// 当前处理的组的现有和 + goal的值 = groupsum
int testShares(int a[], int n, int m, int sum, int groupsum, int aux[], int goal, int groupId);

int main() {
    int a[] = { 8, 4, 3, 3, 2, 2, 2 };
    printf("数组的值：");

    for (int i = 0; i < NUM; i++) {
        printf("%d ", a[i]);
    }

    printf("\n可以分配的最大组数为：%d\n", maxShares(a, NUM));
    return 0;
}

int testShares(int a[], int n, int m, int sum, int groupsum,
               int aux[], int goal, int groupId) {
    if (goal < 0) {
        return 0;
    }

    if (goal == 0) {
        groupId++;
        goal = groupsum;

        if (groupId == m + 1) {
            return 1;
        }
    }

    for (int i = 0; i < n; i++) {
        if (aux[i] != 0) {
            continue;
        }

        aux[i] = groupId;

        if (testShares(a, n, m, sum, groupsum, aux, goal - a[i], groupId)) {
            return 1;
        }

        aux[i] = 0; /* 如果a[i]分配失败，将其置为未分配状态 */
    }

    return 0;
}

int maxShares(int a[], int n) {
    int sum = 0;
    int *aux = (int *)malloc(sizeof(int) * n);

    for (int i = 0; i < n; i++) {
        sum += a[i];
    }

    for (int m = n; m >= 2; m--) {
        if (sum % m != 0) {
            continue;
        }

        for (int i = 0; i < n; i++) {
            aux[i] = 0;
        }

        if (testShares(a, n, m, sum, sum / m, aux, sum / m, 1)) {
            printf("\n分组情况：");

            for (int i = 0; i < NUM; i++) {
                printf("%d ", aux[i]);
            }

            free(aux);
            aux = NULL;
            return m;
        }
    }

    free(aux);
    aux = NULL;
    return 1;
}
```

&emsp;&emsp;19. 输入一个正数`n`，输出所有和为`n`连续正数序列。例如输入`15`，由于`1 + 2 + 3 + 4 + 5 = 4 + 5 + 6 = 7 + 8 = 15`，所以输出`3`个连续序列：即`1`至`5`、`4`至`6`和`7`至`8`。
&emsp;&emsp;我们用一个`small`指示序列中最小值，用`big`指示序列中的最大值，因为和为`n`的序列至少需要两个数字，因而`small`取值是从`1`到中点。如果`small + big < n`，就让`big`后移，以此增大`sum`；而如果`small + big > n`，就让`small`前移，以此缩小`sum`；如果`small + big = n`，打印从`small`到`big`之间的所有值即可。

``` cpp
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

void FindContinuousNumbers(int n) {
    int small = 1;
    int big = 2;
    int middle = (n + 1) / 2;
    int sum = small + big;

    while (small < middle) {
        if (sum == n) {
            for (int i = small; i <= big; ++i) {
                cout << i << "\t";
            }

            cout << endl;
        }

        while (sum > n) {
            sum -= small;
            small++;

            if (sum == n) {
                for (int i = small; i <= big; ++i) {
                    cout << i << "\t";
                }

                cout << endl;
            }
        }

        big++;
        sum += big;
    }
}

int main() {
    cout << "Enter your Number: ";
    int number = 0;
    cin >> number;
    cout << "The sum equals your number is as following:" << endl;
    FindContinuousNumbers(number);
    return 0;
}
```

&emsp;&emsp;20. 把数组排成最小的数。输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组`{32, 321}`，则输出这两个能排成的最小数字`32132`。
&emsp;&emsp;我们将输入数组变换成字符串，如果能事先对其排序，如`{"3", "32", "321"}`排序成`{"321", "32", "3"}`，则最后再将排序好的字符串重新串连起来，那么就为要求的输出。
&emsp;&emsp;给定数字`a`和数字`b`，我们将其变成字符串。`ab`表示`a`加在`b`的前面，`ba`表示`b`加在`a`的前面，新的字符串比较规则为：`ab > ba`，则`a > b`；`ab = ba`，则`a = b`；`ab < ba`，则`a < b`。

``` python
import functools

def cmp1(a, b):
    t1 = a + b
    t2 = b + a

    if t1 < t2:
        return -1
    elif t1 == t2:
        return 0
    elif t1 > t2:
        return 1

def PrintMinNumber(numbers):
    numbers = [str(s) for s in numbers]
    numbers.sort(key=functools.cmp_to_key(cmp1))
    return "".join(numbers)

print(PrintMinNumber([21, 2, 13, 4]))
```

&emsp;&emsp;21. 有`n`根棍子，棍子`i`的长度为`ai`，想要从中选出三根棍子组成周长尽可能长的三角形。请输出最大的周长，若无法组成三角形则输出`0`。

``` cpp
#include <stdio.h>
#include <stdlib.h>

int MAX(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int a[10] = { 0 };
    int n = 0;
    scanf_s("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf_s("%d", &a[i]);
    }

    int ans = 0; /* 答案 */

    for (int i = 0; i < n; i++) { /* 让“i < j < k”，这样棍子就不会被重复选取了 */
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                int l = a[i] + a[j] + a[k]; /* 周长 */
                int max = MAX(a[i], MAX(a[j], a[k])); /* 找出最长的棍子 */
                int rest = l - max; /* 其余两根棍子的长度之和 */

                if (rest > max) { /* 如果可以构成三角形，则更新最大周长 */
                    ans = MAX(ans, l);
                }
            }
        }
    }

    printf("%d\n", ans);
    return 0;
}
```

&emsp;&emsp;22. `n`只蚂蚁以每秒`1cm`的速度在长为`Lcm`的竿子上爬行，当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离`xi`，但不知道它当前的朝向。请计算所有蚂蚁落下竿子所需的最短时间和最长时间。
&emsp;&emsp;可以知道两只蚂蚁相遇后，当它们保持原样交错而过继续前进也不会有任何问题。这样看来，可以认为每只蚂蚁都是独立运动的，所以要求最长时间，只要求蚂蚁到竿子端点的最大距离就好了。

``` cpp
#include <iostream>
#include <algorithm>
#include <cstdlib>

using namespace std;

int L = 10, n = 3;
int x[] = { 2, 6, 7 };

void solve() {
    int minT = 0; /* 计算最短时间 */

    for (int i = 0; i < n; i++) {
        minT = max(minT, min(x[i], L - x[i]));
    }

    int maxT = 0; /* 计算最长时间 */

    for (int i = 0; i < n; i++) {
        maxT = max(maxT, max(x[i], L - x[i]));
    }

    cout << "min is " << minT << "; max is " << maxT << endl;
}

int main() {
    solve();
    return 0;
}
```

&emsp;&emsp;23. 有一个大小为`N*M`的园子，雨后积了很多水，八连通的积水被认为是在一起的(八连通是指下图中相对于`+`的`*`部分)，请求出园子里共有多少个水洼？例如输入`N`为`10`，`M`为`12`，园子如下图所示(`+`表示积水，`*`表示没有积水)，则输出为`3`：

``` cpp
+********++*
*+++*****+++
****++***++*
*********++*
*********+**
**+******+**
*+*+*****++*
+*+*+*****+*
*+*+******+*
**+*******+*
```

代码如下：

``` cpp
#include "iostream"
#include "cstdlib"

using namespace std;

const int N = 10;
const int M = 12;

char garden[N][M + 1] = { /* 园子 */
    "+********++*",
    "*+++*****+++",
    "****++***++*",
    "*********++*",
    "*********+**",
    "**+******+**",
    "*+*+*****++*",
    "+*+*+*****+*",
    "*+*+******+*",
    "**+*******+*"
};

void dfs(int x, int y);

void solve() {
    int count = 0;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (garden[i][j] == '+') {
                dfs(i, j);
                count++;
            }
        }
    }

    cout << count << endl;
}

void dfs(int x, int y) { /* 现在的位置是(x,y) */
    garden[x][y] = '*'; /* 将现在的位置替换为“*” */

    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            int nx = x + dx, ny = y + dy; /* 向x方向移动dx，向y方向移动dy */

            /* 判断(nx,ny)是否在园子里，以及是否有水 */
            if (nx >= 0 && nx < N && ny >= 0 && ny < M && garden[nx][ny] == '+') {
                dfs(nx, ny);
            }
        }
    }
}

int main() {
    solve();
    return 0;
}
```