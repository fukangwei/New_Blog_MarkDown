---
title: 卡特兰数
date: 2019-12-22 18:02:31
categories: 数学和物理
mathjax: true
---
&emsp;&emsp;卡特兰数(`Catalan number`)又称卡塔兰数，是组合数学中一个常出现在各种计数问题中出现的数列。前`10`项为：`1`、`1`、`2`、`5`、`14`、`42`、`132`、`429`、`1430`、`4862`。
&emsp;&emsp;卡特兰数满足以下性质：令$h(0) = 1$和$h(1) = 1$，`catalan`数满足递推式：<!--more-->

$$
h(n) = h(0) * h(n - 1) + h(1) * h(n - 2) + ... + h(n - 1)h(0), n >= 2
$$

也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数。该递推关系的解为：

$$
h(n) = \frac{C(2n-2, n-1)}{n}, n = 1, 2, 3, ...
$$

其中$C(2n-2, n-1)$表示$2n-2$个中取$n-1$个的组合数。
&emsp;&emsp;问题描述：`12`个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？
&emsp;&emsp;问题分析：我们先把这`12`个人从低到高排列，然后选择`6`个人排在第一排，那么剩下的`6`个肯定是在第二排。用`0`表示对应的人在第一排，用`1`表示对应的人在第二排，那么含有`6`个`0`和`6`个`1`的序列，就对应一种方案。比如`000000111111`就对应着第一排为`0 1 2 3 4 5`，第二排为`6 7 8 9 10 11`；`010101010101`就对应着第一排为`0 2 4 6 8 10`，第二排为`1 3 5 7 9 11`。问题转换为：这样的满足条件的`01`序列有多少个。
&emsp;&emsp;观察`1`的出现，我们考虑这一个出现能不能放在第二排。显然，在这个`1`之前出现的那些`0`和`1`对应的人要么是在这个`1`左边，要么是在这个`1`前面。而肯定要有一个`0`在这个`1`前面，统计在这个`1`之前的`0`和`1`的个数，也就是要求`0`的个数大于`1`的个数。
&emsp;&emsp;如果把`0`看成入栈操作，`1`看成出栈操作，就是说给定`6`个元素，合法的入栈出栈序列有多少个。这就是`catalan`数，这里只是用于栈，等价地描述还有二叉树的枚举、多边形分成三角形的个数、圆括弧插入公式中的方法数，其通项为$c(2n, n)/(n + 1)$。
&emsp;&emsp;在`计算机程序设计艺术`的第一卷，作者给出了证明，问题大意是用`S`表示入栈，`X`表示出栈，那么合法的序列有多少个(`S`的个数为`n`)。显然有$c(2n, n)$个含`S`、`X`各`n`个的序列，剩下的是计算不允许的序列数(它包含正确个数的`S`和`X`，但是违背其它条件)。
&emsp;&emsp;在任何不允许的序列中，得出使得`X`的个数超过`S`的个数的第一个`X`的位置。然后在导致并包括这个`X`的部分序列中，以`S`代替所有的`X`并以`X`代表所有的`S`。结果是一个有$(n + 1)$个`S`和$(n - 1)$个`X`的序列。对允许类型的每个序列，我们都能逆转这个过程，而且找出导致它的前一种类型的不允许序列，例如`XXSXSSSXXSSS`必然来自`SSXSXXXXXSSS`。这个对应说明，不允许的序列的个数是$c(2n, n - 1)$，因此$a_{n} = c(2n, n) - c(2n, n - 1)$。
&emsp;&emsp;用`F`表示前排，`B`表示后排，在枚举出前排的人之后，对应的就是后排的人了，然后再验证是不是满足后面的比前面对应的人高的要求。

``` cpp
#include <iostream>

using namespace std;
​
int bit_cnt ( int n ) {
    int result = 0;
​
    for ( ; n; n &= n - 1, ++result );​
    return result;
}

int main ( void ) {
    int F[6], B[6];
    int i, j, k, state, ok, ans = 0;
​
    for ( state = 0; state < ( 1 << 12 ); ++state ) {
        if ( bit_cnt ( state ) == 6 ) {
            i = j = 0;
​
            for ( k = 0; k < 12; ++k ) {
                if ( state & ( 1 << k ) ) {
                    F[i++] = k;
                } else {
                    B[j++] = k;
                }
            }
​
            ok = 1;
​
            for ( k = 0; k < 6; ++k ) {
                if ( B[k] < F[k] ) {
                    ok = 0;
                    break;
                }
            }
​
            ans += ok;
        }
    }
​
    cout << ans << endl; /* 输出132 */
    return 0;
}
```