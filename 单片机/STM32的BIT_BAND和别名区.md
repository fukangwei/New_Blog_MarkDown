---
title: STM32的BIT_BAND和别名区
categories: 单片机
abbrlink: 4a674abd
date: 2019-01-19 12:37:59
---
### 什么是位段和别名区

&emsp;&emsp;`MCS51`有位操作，以一位(`BIT`)为数据对象的操作，`MCS51`可以简单的将`P1`口的第`2`位独立操作，例如`P1.2 = 0; P1.2 = 1;`，这样就把`P1`口的第三个脚(`BIT2`)置`0`或置`1`。而现在`STM32`的位段、位带别名区就为了实现这样的功能。它的对象可以是`SRAM`、`I/O`和`外设空间`。要实现对这些地方的某一位的操作。<!--more-->
&emsp;&emsp;它是这样做到的：在寻址空间(`32`位对应的地址空间为`4GB`)的另一地方，取个别名区空间，从这个地址开始处，每一个字(`32BIT`)对应`SRAM`或`I/O`的一位。这样`1MB`的`SRAM`就可以有`32MB`的对应别名区空间，就是`1`位膨胀到`32`位(`1BIT`变为`1`个字)。我们对这个别名区空间内的某一字操作(置`0`或置`1`)，就等于它映射的`SRAM`或`I/O`相应的某地址的某一位的操作。

### 使用位段的好处

&emsp;&emsp;简单来说，可以把代码缩小、速度更快、效率更高、更安全。一般操作要`6`条指令，而使用位带和别名区只要`4`条指令。一般的操作是`读-改-写`的方式，而位带别名区是`写`操作，防止中断对`读-改-写`的方式的影响。

### 应用说明

&emsp;&emsp;支持了位带操作(`bit_band`)，有两个区中实现了位带。其中一个是`SRAM`区的最低`1MB`范围，第二个则是片内外设区的最低`1MB`范围。这两个区中的地址除了可以像普通的`RAM`一样使用外，它们还都有自己的`位带别名区`。位带别名区把每个比特膨胀成一个`32`位的字。每个比特膨胀成一个`32`位的字，就是把`1M`扩展为`32M`。于是位于`RAM`地址`0x200000000`的一个字节扩展为`8`个`32`位的字，扩展后每位相对应的的地址是`0x220000000`、`0x220000004`、`0x220000008`、`0x22000000C`、`0x220000010`、`0x220000014`、`0x220000018`、`0x22000001C`。支持位带操作的两个内存区的范围是：

- `0x2000_0000`至`0x200F_FFFF`(`SRAM`区中的最低`1MB`)
- `0x4000_0000`至`0x400F_FFFF`(片上外设区中的最低`1MB`)

&emsp;&emsp;对`SRAM`位带区的某个比特，记该比特所在字节的地址为`A`，位序号为`n`(`0 <= n <= 7`)，则它在别名区的地址为：

``` c
AliasAddr = 0x22000000 + ((A - 0x20000000) * 8 + n) * 4
          = 0x22000000 + (A - 0x20000000) * 32 + n * 4
```

对于片上外设位带区的某个比特，记该比特所在字节的地址为`A`，位序号为`n`(`0 <= n <= 7`)，则该比特在别名区的地址为：

``` c
AliasAddr = 0x42000000 + ((A - 0x40000000) * 8 + n) * 4
          = 0x42000000 + (A - 0x40000000) * 32 + n * 4
```

上式中，`* 4`表示一个字为`4`个字节，`* 8`表示一个字节中有`8`个比特。
&emsp;&emsp;把`位带地址 + 位序号`转换别名地址宏为：

``` c
#define BITBAND(addr, bitnum) \
    ((addr & 0xF0000000) + 0x2000000 + \
    ((addr & 0xFFFFF) << 5) + (bitnum << 2))
```

这个宏定义后面的算式`(addr & 0xF0000000) + 0x2000000 + ((addr & 0xFFFFF) << 5) + (bitnum << 2)`，`addr & 0xF0000000`取出最高的四位，其实就是用于区别`SRAM`(`0x20000000`)还是片上外设(`0x40000000`)的。`+ 0x2000000`对于`SRAM`位带区则得到`0x22000000`，对于片上外设位带区则得到`0x42000000`。(`addr & 0xFFFFF`)等效于(`addr & 0x000FFFFF`)，就是屏蔽掉高`12`位(个人认为屏蔽高`12`位和屏蔽高`4`位效果是一样的，地址范围是`0x2000_0000`至`0x200F_FFFF`和`0x4000_0000`至`0x400F_FFFF`，无非就是不要那个`2`和`4`)，`<< 5`就等效于乘以`32`(同样`<< 2`等效于乘以`4`)。
&emsp;&emsp;把该地址转换成一个指针：

``` c
#define MEM_ADDR(addr) *((volatile unsigned long *) (addr))
```

例如点亮`LED`，使用`STM32`库为：

``` c
GPIO_ResetBits ( GPIOC, GPIO_Pin_4 ); /* 关LED5 */
GPIO_SetBits ( GPIOC, GPIO_Pin_7 ); /* 开LED2 */
```

一般读操作如下：

``` c
STM32_Gpioc_Regs->bsrr.bit.BR4 = 1; /* 清除对应的ODRy位为0 */
STM32_Gpioc_Regs->bsrr.bit.BS7 = 1; /* 设置对应的ODRy位为1 */
```

如果使用位带别名区操作：

``` c
STM32_BB_Gpioc_Regs->BSRR.BR[4] = 1; /* 清除对应的ODRy位为0 */
STM32_BB_Gpioc_Regs->BSRR.BS[7] = 1; /* 设置对应的ODRy位为1 */
```

代码比`STM32`库高效十倍！
&emsp;&emsp;对内存变量的位操作如下：假设`SRAM`变量为`long CRCValue;`，对`32`位变量的`BIT1`置`1`：

``` c
MEM_ADDR ( BITBAND ( ( u32 ) &CRCValue, 1 ) ) = 0x1;
```

对任意一位(例如第`23`位)判断：

``` c
if ( MEM_ADDR ( BITBAND ( ( u32 ) &CRCValue, 23 ) ) == 1 ) {
}
```

### Cortex-M3中关于位段的定义

&emsp;&emsp;`Cortex-M3`存储器映像包括两个位段区。这两个位段区将别名存储器区中的每个字映射到位段存储器区的一个位，在别名存储区写入一个字具有对位段区的目标位执行`读-改-写`操作的相同效果。所有`STM32F10x`外设寄存器都被映射到一个位段区。这个特性在各个函数中对单个比特进行置`1`或置`0`操作时被大量使用，用以减小和优化代码尺寸。
&emsp;&emsp;映射公式给出别名区中的每个字是如何对应位带区的相应位的，公式如下：

``` c
bit_word_offset = (byte_offset * 32) + (bit_number * 4)
bit_word_addr = bit_band_base + bit_word_offset
```

- `bit_word_offset`：目标位在存取器位段区中的位置。
- `bit_word_addr`：别名存储器区中字的地址，它映射到某个目标位。
- `bit_band_base`：别名区的起始地址。
- `byte_offset`：包含目标位的字节在位段中的序号。
- `bit_number`：目标位所在位置(`0`至`31`)。