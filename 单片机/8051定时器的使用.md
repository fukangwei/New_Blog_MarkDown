---
title: 8051定时器的使用
categories: 单片机
abbrlink: 5588a43e
date: 2018-12-29 19:40:06
---
&emsp;&emsp;`8051`有两个定时器(或计数器)，而`8052`则有三个定时器(或计数器)。定时器、计数器本质都是一样的，定时器通过对内部脉冲进行计数来达到计时的目的，而计数器是对外部输入脉冲进行计数，所以它们的本质都是一样的。
&emsp;&emsp;定时器(或计数器)`0`有四种工作模式，而定时器(或计数器)`1`只有三种工作模式，工作模式由`TMOD`寄存器的`M1`和`M0`位控制：

M1  | M0  | 工作模式
----|-----|---------
`0` | `0` | `0`
`0` | `1` | `1`
`1` | `0` | `2`
`1` | `1` | `3`

- 模式`0`：`13`位定时器(或计数器)。
- 模式`1`：`16`位定时器(或计数器)。
- 模式`2`：`8`位自动重装定时器(或计数器)。
- 模式`3`：只能用于定时器(或计数器)`0`，`T0`被分为两个`8`位定时器(或计数器)。`TL0`可以作为定时器(或计数器)来使用，由`T0`的控制位来控制；而`TH0`只能用于计数器，由`T1`的控制位来控制。

&emsp;&emsp;`GATE`为`0`时，由`TRx`(软件控制)来控制定时器(或计数器)的启动和停止；`GATE`为`1`时，定时器(或计数器)的启动由`TRx`和引脚`INTx`共同来控制(硬件来控制，仅当`TRx = 1`并且引脚`INTx`输入高电平时才工作)。
&emsp;&emsp;`C/T`是定时器(或计数器)选择位，为`0`表示工作在定时器模式，为`1`表示工作在计数器模式。
&emsp;&emsp;`TCON`寄存器主要有`TFx`和`TRx`两个寄存器：

- `TFx`是定时器(或计数器)溢出标志位，当定时器(或计数器)计数溢出时，由硬件自动置`1`，在编写程序时可以通过检测该位来判断是否达到定时时间，需要通过软件来清零。工作在中断方式下不需要清零，因为在执行中断服务程序时会自动给我们清零。
- `TRx`是定时器(或计数器)运行控制位。

&emsp;&emsp;`IE`寄存器如下：

- `ETx`：定时器/计数器中断使能位。
- `EA`：全局中断使能位。

### THx、TLx初值计算

&emsp;&emsp;假设`8051`外接`12MHz`的晶振，由于其机器周期是时钟周期的`12`分频，所以`8051`的机器周期为`1MHz`，那么计数一次的时间刚好为`1us`。如果定时器工作在模式`0`下，那么可以最长计时为`8192us`，工作模式`1`可以最长计时为`65536us`。
&emsp;&emsp;假设`8051`工作在模式`1`下，定时`1ms`，那么`THx`、`TLx`的初值应该为多少呢？如果定时`1ms`，也就意味着需要计数`1000`次，那么初值就应该为`65536 - 1000 = 64536`，也就是`THx = 0xFC`，`TLx = 0x18`。可以总结出如下公式：

``` cpp
定时时间 = (最大计数值 - 计数器初值) * 机器周期 = (最大计数值 - 计数器初值) * (12000000 / 晶振频率(Hz))(us)
计数器初值 = (最大计数值 - 定时时间 * (晶振频率(Hz) / 12000000))
```

套用这个公式，初值为`(65536 - 1000 * (12000000 / 12000000)) = 64536 = 0xFC18`：

``` c
/* timer.h */
#ifndef __TIMER_H
#define __TIMER_H
​
extern void timer0_init ( void );
extern void delayms ( unsigned int n );
​
#endif /* __TIMER_H */
​
/* timer.c */
#include <at89x52.h>
​
#define OSC_FREQ 12000000UL
​
#define TIMER_MODE0 0x00
#define TIMER_MODE1 0x01
#define TIMER_MODE2 0x02
#define TIMER_MODE3 0x03
​
void timer0_init ( void ) {
    TMOD &= 0xF0;
    TMOD |= TIMER_MODE1; /* Timer 0 work on 16-bit timer mode */
    TH0 = ( 65536 - 1000 * ( OSC_FREQ / 12000000 ) ) >> 8;
    TL0 = ( 65536 - 1000 * ( OSC_FREQ / 12000000 ) ) & 0x00FF;
    TR0 = 1; /* Turn on timer 0 */
}
​
void delayms ( unsigned int n ) {
    while ( n-- ) {
        while ( !TF0 );
​
        TF0 = 0;
        TH0 = ( 65536 - 1000 * ( OSC_FREQ / 12000000 ) ) >> 8;
        TL0 = ( 65536 - 1000 * ( OSC_FREQ / 12000000 ) ) & 0x00FF;
    }
}
​
/* main.c */
#include <at89x52.h>
#include "timer.h"
​
#define led1 P2_0
​
void main ( void ) {
    timer0_init();
​
    while ( 1 ) {
        led1 = 0;
        delayms ( 1000 );
        led1 = 1;
        delayms ( 1000 );
    }
}
```