---
title: 带参数的基类构造函数
date: 2019-02-07 15:00:35
categories: C++语法详解
---
&emsp;&emsp;如果一个基类的构造函数带有参数，那么如何编写该基类的派生类呢？

``` cpp
#include <tchar.h>
#include <iostream>
​
using namespace std;
​
class Person {
public:
    Person ( int nAge ) {
        m_nAge = nAge;
    }
​
protected:
    int m_nAge;
};
​
class Men: public Person {
public:
    Men ( int nMenAge, int nMenWeight ) : Person ( nMenAge ) {
        m_nWeight = nMenWeight;
    }
​
    void Print() {
        cout << _T ( "年龄为" ) << m_nAge << endl;
        cout << _T ( "体重为" ) << m_nWeight << endl;
    }
​
private:
    int m_nWeight;
};
​
int _tmain ( int argc, TCHAR argv[], TCHAR envp[] ) {
    Men Mike ( 21, 150 );
    Mike.Print();
    return 0;
}
```

执行结果：

``` cpp
年龄为21
体重为150
```

`Person`类的构造函数是带有参数的，`Men`类从`Person`类共有派生，这就需要在`Men`类的构造函数名后面显示的调用`Person`类的构造函数。

---

&emsp;&emsp;`C++`规定：当派生类构造函数初始化时，必须同时对基类构造函数初始化。构造一个对象是从内向外构造的，也就是先构造基类，再构造派生类。因此，必须在派生类构造函数执行前先执行基类构造函数。`C++`会默认帮你调用无参数的`base()`，因此在派生类构造函数中看不到对基类构造函数的调用。派生类构造函数的完整写法应该是这样的：

``` cpp
class follow {
public:
    follow() : base() { /* 注意这里 */
    }
}
```

&emsp;&emsp;如果基类的构造函数是带参数的，那就必须明白写出来了：

``` cpp
class base {
public:
    base ( int i ) {}
};
​
class follow {
public:
    follow ( int i ) : base ( i ) { /* 这里必须明确指定如何调用基类的构造函数 */
    }
}
```