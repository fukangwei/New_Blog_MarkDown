---
title: 前置声明和头文件
categories: C++语法详解
abbrlink: e39f5355
date: 2019-02-05 18:01:55
---
&emsp;&emsp;假设有一个`Date`类，`Date.h`如下：

``` cpp
class Date {
private:
    int year, month, day;
};
```

如果有个`Task`类的定义要用到`Date`类，有两种写法。
&emsp;&emsp;第一种是定义头文件`Task1.h`：

``` cpp
class Date;
​
class Task1 {
public:
    Date getData();
};
```

&emsp;&emsp;第二种是定义头文件`Task2.h`：

``` cpp
#include "Date.h"
​
class Task2 {
public:
    Date getData();
};
```

一个采用前置声明，另一个采用`include`加入，两种方法都能通过编译，但是`Task1.h`的写法更好。如果`Date.h`的`private`成员变量发送改变，例如变成`double year, month, day;`，`Task1.h`不需要重新编译，而`Task2.h`就要重新编译。更糟的是，如果`Task2.h`还与其他很多头文件有依赖关系，就会引发一连串的重新编译。所以能用前置声明代替`include`时，尽量用前置声明。
&emsp;&emsp;有些情况不能用前置声明代替`include`，例如`Task1.h`改成：

``` cpp
class Date;
​
class Task1 {
public:
    Date d;
};
```

则会编译错误，因为`Date d`定义了一个`Date`类型变量，编译器为`d`分配内存空间时必须知道`d`的大小，因此要包含定义`Date`类的`Date.h`文件。这时可以采用指针来代替：

``` cpp
class Date;
​
class Task1 {
public:
    Date *d;
};
```

指针的大小是固定的，在`32`位机上是`4`字节，`64`位机上是`8`字节，编译`Task1`时不需要指导`Date`的大小。上面的例子可以说明，如果使用`object reference`或`object point`可以完成任务，就不要用`object`，这样可以尽最大可能避免`include`。
&emsp;&emsp;`为声明式和定义式提供不同的头文件`，在函数库的设计过程中，接口的设计就要遵循上述准则。一个接口的头文件应当是这样的：

``` cpp
class Date;
class Address;
class Email;
​
Date getDate();
```

如果客户只用到`Date`类，编译器就只会去编译`Date.h`，而不去编译`Address.h`、`Email.h`等文件。