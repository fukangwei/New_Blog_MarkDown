---
title: 模板
categories: C++语法详解
abbrlink: f6010553
date: 2019-02-07 21:07:50
---
&emsp;&emsp;模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，例如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念，我们可以定义许多不同类型的向量，例如`vector <int>`或`vector <string>`。

### 函数模板

&emsp;&emsp;模板函数定义的一般形式如下：

``` cpp
template <typename type> ret-type func-name ( parameter list ) {
    /* 函数的主体 */
}
```

`type`是函数所使用的数据类型的占位符名称，这个名称可以在函数定义中使用。下面是函数模板的实例，返回两个数中的最大值：

``` cpp
#include <iostream>
#include <string>
​
using namespace std;
​
template <typename T>
inline T const &Max ( T const &a, T const &b ) {
    return a < b ? b : a;
}
​
int main ( void ) {
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max ( i, j ) << endl;
    double f1 = 13.5;
    double f2 = 20.7;
    cout << "Max(f1, f2): " << Max ( f1, f2 ) << endl;
    string s1 = "Hello";
    string s2 = "World";
    cout << "Max(s1, s2): " << Max ( s1, s2 ) << endl;
    return 0;
}
```

执行结果：

``` cpp
Max(i, j): 39
Max(f1, f2): 20.7
Max(s1, s2): World
```

### 类模板

&emsp;&emsp;正如定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下：

``` cpp
template <class type> class class-name {
    /* ... */
}
```

`type`是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。下面的实例定义了类`Stack<>`，并实现了泛型方法来对元素进行入栈出栈操作：

``` cpp
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>
​
using namespace std;
​
template <class T> class Stack {
private:
    vector<T> elems; /* 元素 */
​
public:
    void push ( T const & ); /* 入栈 */
    void pop();              /* 出栈 */
    T top() const;           /* 返回栈顶元素 */
    bool empty() const {     /* 如果为空，则返回真 */
        return elems.empty();
    }
};
​
template <class T> void Stack<T>::push ( T const &elem ) {
    elems.push_back ( elem ); /* 追加传入元素的副本 */
}
​
template <class T> void Stack<T>::pop () {
    if ( elems.empty() ) {
        throw out_of_range ( "Stack<>::pop(): empty stack" );
    }

    elems.pop_back(); /* 删除最后一个元素 */
}
​
template <class T> T Stack<T>::top () const {
    if ( elems.empty() ) {
        throw out_of_range ( "Stack<>::top(): empty stack" );
    }
​
    return elems.back(); /* 返回最后一个元素的副本 */
}
​
int main( void ) {
    try {
        Stack<int> intStack; /* int类型的栈 */
        Stack<string> stringStack; /* string类型的栈 */
        intStack.push ( 7 ); /* 操作int类型的栈 */
        cout << intStack.top() << endl;
        stringStack.push ( "hello" ); /* 操作string类型的栈 */
        cout << stringStack.top() << std::endl;
        stringStack.pop();
        stringStack.pop();
    } catch ( exception const &ex ) {
        cerr << "Exception: " << ex.what() << endl;
        return -1;
    }
}
```

执行结果：

``` cpp
7
hello
Exception: Stack<>::pop(): empty stack
```

---

### 函数模板的声明和模板函数的生成

#### 函数模板的声明

&emsp;&emsp;函数模板可以用来创建一个通用的函数，以支持多种不同的形参，避免重载函数的函数体重复设计。它的最大特点是把函数使用的数据类型作为参数。函数模板的声明形式为：

``` cpp
template < typename 数据类型参数标识符 >
返回类型 函数名 ( 参数表 ) {
    /* 函数体 */
}
```

`template`是定义模板函数的关键字，其后面的尖括号不能省略；`typename`(或`class`)是声明数据类型参数标识符的关键字，用以说明它后面的标识符是数据类型标识符。

``` cpp
template<typename T>
T fuc ( T x, int y ) {
    T x;
    /* ... */
}
```

如果主调函数中有以下语句：

``` cpp
double d;
int a;
fuc ( d, a );
```

则系统将用实参`d`的数据类型`double`去代替函数模板中的`T`：

``` cpp
double fuc ( double x, int y ) {
    double x;
    /* ... */
}
```

函数模板只是声明了一个函数的描述，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。
&emsp;&emsp;关键字`typename`也可以使用关键字`class`，这时数据类型参数标识符就可以使用所有的`C++`数据类型。

#### 模板函数的生成

&emsp;&emsp;函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为`模板实参`，用模板实参实例化的函数称为模板函数(简单地说，类实例化生成实例，函数模板实例化生成模板函数)。模板函数的生成就是将函数模板的类型形参实例化的过程。使用中应注意的几个问题：
&emsp;&emsp;1. 函数模板允许使用多个类型参数，但在`template`定义部分的每个形参前必须有关键字`typename`或`class`：

``` cpp
template < class 数据类型参数标识符_1, ..., class 数据类型参数标识符_N >
返回类型 函数名 ( 参数表 ) {
    /* 函数体 */
}
```

&emsp;&emsp;2. 在`template`语句与函数模板定义语句的返回类型之间不允许有别的语句，下面的声明是错误的：

``` cpp
template<class T>
int I;
T min ( T x, T y ) {
    /* 函数体 */
}
```

&emsp;&emsp;3. 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作。

#### 函数模板的异常处理

&emsp;&emsp;函数模板中的模板形参可实例化为各种类型，但当实例化模板形参的各模板实参之间不完全一致时，就可能发生错误：

``` cpp
template<typename T>
void min ( T &x, T &y ) {
    return ( x < y ) ? x : y;
}
​
void func ( int i, char j ) {
    min ( i, i );
    min ( j, j );
    min ( i, j );
    min ( j, i );
}
```

例子中的后两个调用是错误的。出现错误的原因是：在调用时，编译器按最先遇到的实参类型隐式地生成一个模板函数，并用它对所有模板函数进行一致性检查。例如对语句`min(i, j);`，先遇到的实参`i`是整型的，编译器就将模板形参解释为整型，此后出现的模板实参`j`不能解释为整型而产生错误，此时没有隐含的类型转换功能。解决此种异常的方法有两种：

- 采用强制类型转换，如将语句`min(i, j);`改写为`min(i, int(j));`。
- 用非模板函数重载函数模板。具体情况如下所示：

&emsp;&emsp;1. 借用函数模板的函数体。此时只声明非模板函数的原型，它的函数体借用函数模板的函数体。改写上面的例子如下：

``` cpp
template<typename T>
void min ( T &x, T &y ) {
    return ( x < y ) ? x : y;
}
​
int min ( int, int );
​
void func ( int i, char j ) {
    min ( i, i );
    min ( j, j );
    min ( i, j );
    min ( j, i );
}
```

执行该程序就不会出错了，因为重载函数支持数据间的隐式类型转换。
&emsp;&emsp;2. 重新定义函数体。就像一般的重载函数一样，重新定义一个完整的非模板函数，它所带的参数可以随意。`C++`中，函数模板与同名的非模板函数重载时，应遵循下列调用原则：

- 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。
- 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。
- 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。
- 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用。

---

### C++函数模板重载

&emsp;&emsp;和普通函数一样，在`C++`中模板函数也同样支持函数重载的功能，甚至可以将模板函数与普通函数混合在一起，以达到更为灵活的函数重载的效果。下面给出一个利用模板函数重载计算哈希值的代码示例：

``` cpp
#include <stdio.h>
​
template<typename T>
int hash_code ( T v ) {
    return v.hashCode() * 2;
}
​
template<typename T>
int hash_code ( T *v ) {
    return v->hashCode();
}
​
int hash_code ( const int v ) {
    return v + 100;
}
​
class HashClass {
public:
    HashClass ( int v ) : _v ( v ) {}

    int hashCode() {
        return _v + 200;
    }
​
private:
    int _v;
};
​
int main() {
    HashClass c1 ( 10 );
    /* 调用的是“template<typename T> int hash_code(T v)” */
    printf ( "The hash value is %d\n", hash_code ( c1 ) );
    HashClass c2 ( 20 );
    /* 调用的是“template<typename T> int hash_code(T* v)” */
    printf ( "The hash value is %d\n", hash_code ( &c2 ) );
    int i3 = 30;
    /* 调用的是“int hash_code(const int v)” */
    printf ( "The hash value is %d\n", hash_code ( i3 ) );
    return 0;
}
```

`hash_code`函数可以让编译器根据参数的不同选择最为合适的候选函数。在这里模板函数和普通函数一同参与了函数重载。对于模板函数重载，主要应用于算法领域，既对于大多数的类型可以通过泛型算法以达到预期的效果，而对于特殊类型，则可以通过函数重载的方式，针对该类型实现另外一套更为高效的算法。

---

### C++模板特例化应用实例

&emsp;&emsp;如果我们想对特定的数据类型执行不同的代码(而不是通用模板)，这种情况下就可以使用模板特例化(`template specialization`)。

#### 函数模板特例化

&emsp;&emsp;当特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。使用关键字`template`后跟一个空尖括号`<>`，即`template <>`，以指出我们正在特例化一个模板。

``` cpp
#include <iostream>
​
using namespace std;
​
template <typename T>
void fun ( T a ) {
    cout << "The main template fun(): " << a << endl;
}
​
template <> /* 对int型特例化 */
void fun ( int a ) {
    cout << "Specialized template for int type: " << a << endl;
}
​
int main() {
    fun<char> ( 'a' );
    fun<int> ( 10 );
    fun<float> ( 9.15 );
    return 0;
}
```

执行结果：

``` cpp
The main template fun(): a
Specialized template for int type: 10
The main template fun(): 9.15
```

对于除`int`型外的其他数据类型，都会调用通用版本的函数模板`fun(T a)`；对于`int`型，则会调用特例化版本的`fun(int a)`。注意，一个特例化版本的本质是一个实例，而非函数的重载，因此特例化不影响函数匹配。

#### 类模板特例化

&emsp;&emsp;除了特例化函数模板，我们还可以特例化类模板。下面是一个简单的例子：

``` cpp
#include <iostream>
​
using namespace std;
​
template <typename T>
class Test {
public:
    void print() {
        cout << "General template object" << endl;
    }
};
​
template<> /* 对int型特例化 */
class Test<int> {
public:
    void print() {
        cout << "Specialized template object" << endl;
    }
};
​
int main() {
    Test<int> a;
    Test<char> b;
    Test<float> c;
    a.print();
    b.print();
    c.print();
    return 0;
}
```

执行结果：

``` cpp
Specialized template object
General template object
General template object
```

与函数模板不同的是，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，这种叫做类模板的偏特化或部分特例化(`partial specialization`)。例如`C++`标准库中类`vector`的定义：

``` cpp
template <typename T, typename Allocator>
class vector {
    /* ... */
};
​
/* 部分特例化 */
template <typename Allocator>
class vector<bool, Allocator> {
    /* ... */
};
```

在`vector`这个例子中，一个参数被绑定到`bool`类型，而另一个参数仍未绑定需要由用户指定。注意，一个类模板的部分特例化版本仍然是一个模板，因为使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。