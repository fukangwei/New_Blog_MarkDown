---
title: 构造函数初始化列表与赋值
categories: C++语法详解
abbrlink: b18ad7bb
date: 2019-02-05 19:16:46
---
&emsp;&emsp;`C++`类中成员变量的初始化有两种方式，即构造函数初始化列表和构造函数体内赋值。<!--more-->
&emsp;&emsp;1. 内部数据类型：

``` cpp
class Animal {
public:
    Animal ( int weight, int height ) : /* A初始化列表 */
        m_weight ( weight ),
        m_height ( height ) {
    }

    Animal ( int weight, int height ) { /* B函数体内初始化 */
        m_weight = weight;
        m_height = height;
    }

private:
    int m_weight;
    int m_height;
};
```

对于这些内部类型来说，基本上是没有区别的，效率上也不存在多大差异，当然`A`和`B`方式不能共存的。
&emsp;&emsp;2. 无默认构造函数的继承关系中：

``` cpp
class Animal {
public:
    /* 没有提供无参的构造函数 */
    Animal ( int weight, int height ) :
        m_weight ( weight ),
        m_height ( height ) {
    }

private:
    int m_weight;
    int m_height;
};

class Dog: public Animal {
public:
    /* error，父类Animal无合适构造函数 */
    Dog ( int weight, int height, int type ) {
    }

private:
    int m_type;
};
```

这种情况下，必须在派生类中构造函数中初始化提供父类的初始化，因为对象构造的顺序是先父类再子类。所以必须为：

``` cpp
class Dog: public Animal {
public:
    /* 必须使用初始化列表增加对父类的初始化 */
    Dog ( int weight, int height, int type ) : Animal ( weight, height ) {
        ;
    }

private:
    int m_type;
};
```

&emsp;&emsp;3. 类中`const`常量必须在初始化列表中初始，不能使用赋值的方式初始化：

``` cpp
class Dog: public Animal {
public:
    /* 必须在初始化列表中初始化 */
    Dog ( int weight, int height, int type ) : Animal ( weight, height ), LEGS ( 4 ) {
        // LEGS = 4; /* error */
    }

private:
    int m_type;
    const int LEGS;
};
```

&emsp;&emsp;4. 包含有自定义数据类型(类)对象的成员初始化：

``` cpp
class Food {
public:
    Food ( int type = 10 ) {
        m_type = 10;
    }

    Food ( Food &other ) { /* 拷贝构造函数 */
        m_type = other.m_type;
    }

    Food &operator = ( Food &other ) { /* 重载赋值“=”函数 */
        m_type = other.m_type;
        return *this;
    }

private:
    int m_type;
};
```

- 构造函数赋值方式来初始化成员对象`m_food`：

``` cpp
class Dog: public Animal {
public:
    Dog ( Food &food ) {
        m_food = food; /* 初始化成员对象 */
    }

private:
    Food m_food;
};

Food fd;
Dog dog ( fd );
```

`Dog dog(fd);`的结果为：先执行函数`Food(int type = 10)`，然后执行函数`Food & operator =(Food &other)`。

- 构造函数初始化列表方式：

``` cpp
class Dog: public Animal {
public:
    Dog ( Food &food ) : m_food ( food ) { /* 初始化成员对象 */
    }

private:
    Food m_food;
};

Food fd;
Dog dog ( fd );
```

`Dog dog(fd);`的结果为：执行`Food(Food &other)`拷贝构造函数完成初始化。不同的初始化方式得到不同的结果，构造函数初始化列表的方式效率更高。
&emsp;&emsp;`C++`初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序：

``` cpp
class CMyClass {
    CMyClass ( int x, int y );
    int m_x;
    int m_y;
};

CMyClass::CMyClass ( int x, int y ) : m_y ( y ), m_x ( m_y ) {
}
```

&emsp;&emsp;你可能以为上面的代码将会首先做`m_y = y`，然后做`m_x = m_y`，最后它们有相同的值。但是编译器先初始化`m_x`，然后是`m_y`，因为它们是按这样的顺序声明的，结果是`m_x`将有一个不可预测的值。