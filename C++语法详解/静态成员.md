---
title: 静态成员
categories: C++语法详解
date: 2019-02-06 10:39:04
---
&emsp;&emsp;我们可以使用`static`关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。<!--more-->
&emsp;&emsp;静态成员在类的所有对象中是共享的。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性，还可以节省内存。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员放置在类的定义中，但是可以在类的外部通过使用范围解析运算符`::`来重新声明静态变量从而对它进行初始化：

``` cpp
#include <iostream>

using namespace std;

class Box {
public:
    static int objectCount;
    Box ( double l = 2.0, double b = 2.0, double h = 2.0 ) {
        cout << "Constructor called." << endl;
        length = l;
        breadth = b;
        height = h;
        objectCount++; /* 每次创建对象时增加1 */
    }

    double Volume() {
        return length * breadth * height;
    }

private:
    double length; /* 长度 */
    double breadth; /* 宽度 */
    double height; /* 高度 */
};

int Box::objectCount = 0; /* 初始化类Box的静态成员 */

int main ( void ) {
    Box Box1 ( 3.3, 1.2, 1.5 ); /* 声明box1 */
    Box Box2 ( 8.5, 6.0, 2.0 ); /* 声明box2 */
    cout << "Total objects: " << Box::objectCount << endl; /* 输出对象的总数 */
    return 0;
}
```

执行结果：

``` cpp
Constructor called.
Constructor called.
Total objects: 2
```

&emsp;&emsp;如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符`::`就可以访问。
&emsp;&emsp;静态成员函数只能访问静态数据成员，不能访问其他静态成员函数和类外部的其他函数。静态成员函数有一个类范围，它们不能访问类的`this`指针。你可以使用静态成员函数来判断类的某些对象是否已被创建。程序中采用静态成员函数的好处是可以不依赖于任何对象，直接访问静态数据。

``` cpp
#include <iostream>

using namespace std;

class Box {
public:
    static int objectCount;

    Box ( double l = 2.0, double b = 2.0, double h = 2.0 ) {
        cout << "Constructor called." << endl;
        length = l;
        breadth = b;
        height = h;
        objectCount++;
    }

    double Volume() {
        return length * breadth * height;
    }

    static int getCount() {
        return objectCount;
    }

private:
    double length;
    double breadth;
    double height;
};

int Box::objectCount = 0;

int main ( void ) {
    /* 在创建对象之前输出对象的总数 */
    cout << "Inital Stage Count: " << Box::getCount() << endl;
    Box Box1 ( 3.3, 1.2, 1.5 );
    Box Box2 ( 8.5, 6.0, 2.0 );
    /* 在创建对象之后输出对象的总数 */
    cout << "Final Stage Count: " << Box::getCount() << endl;
    return 0;
}
```

执行结果：

``` cpp
Inital Stage Count: 0
Constructor called.
Constructor called.
Final Stage Count: 2
```


---

&emsp;&emsp;1. 通过类名调用静态成员函数和非静态成员函数：

``` cpp
class Point {
public:
    void init() {
    }

    static void output() {
    }
};

void main() {
    Point::init();
    Point::output();
}
```

编译出错`error C2352: 'Point::init': illegal call of non-static member function`。结论为：不能通过类名来调用类的非静态成员函数。
&emsp;&emsp;2. 通过类的对象调用静态成员函数和非静态成员函数：

``` cpp
void main() {
    Point pt;
    pt.init();
    pt.output();
}
```

编译通过。结论为：类的对象可以使用静态成员函数和非静态成员函数。
&emsp;&emsp;3. 在类的静态成员函数中使用类的非静态成员：

``` cpp
#include <stdio.h>

class Point {
public:
    void init() {
    }

    static void output() {
        printf ( "%d\n", m_x );
    }

private:
    int m_x;
};

void main() {
    Point pt;
    pt.output();
}
```

编译出错`error C2597: illegal reference to data member 'Point::m_x' in a static member function`。因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象后才有内存空间，所以这个调用就出错了，就好比没有声明一个变量却提前使用它一样。结论为：静态成员函数中不能引用非静态成员。
&emsp;&emsp;4. 在类的非静态成员函数中使用类的静态成员：

``` cpp
class Point {
public:
    void init() {
        output();
    }

    static void output() {
    }
};

void main() {
    Point pt;
    pt.output();
}
```

编译通过。结论为：类的非静态成员函数可以调用用静态成员函数，反之则不能。
&emsp;&emsp;5. 使用类的静态成员变量：

``` cpp
#include <stdio.h>

class Point {
public:
    Point() {
        m_nPointCount++;
    }

    ~Point() {
        m_nPointCount--;
    }

    static void output() {
        printf ( "%d\n", m_nPointCount );
    }

private:
    static int m_nPointCount;
};

void main() {
    Point pt;
    pt.output();
}
```

编译无错误，但是链接出现错误`error LNK2001: unresolved external symbol "private: static int Point::m_nPointCount" (?m_nPointCount@Point@@0HA)`。这是因为类的静态成员变量在使用前必须先初始化。在`main`函数前加上`int Point::m_nPointCount = 0;`，再编译链接无错误，运行程序将输出`1`。结论为：类的静态成员变量必须先初始化再使用。