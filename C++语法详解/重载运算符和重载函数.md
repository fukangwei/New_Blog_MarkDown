---
title: 重载运算符和重载函数
categories: C++语法详解
date: 2019-03-10 18:25:31
---
&emsp;&emsp;`C++`允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义不相同。当调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。<!--more-->

### C++中的函数重载

&emsp;&emsp;在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数(参数的个数、类型或者顺序)必须不同。您不能仅通过返回类型的不同来重载函数。下面的实例中，同名函数`print`被用于输出不同的数据类型：

``` cpp
#include <iostream>

using namespace std;

class printData {
public:
    void print ( int i ) {
        cout << "Printing int: " << i << endl;
    }

    void print ( double f ) {
        cout << "Printing float: " << f << endl;
    }

    void print ( string c ) {
        cout << "Printing character: " << c << endl;
    }
};

int main ( void ) {
    printData pd;
    pd.print ( 5 ); /* Call print to print integer */
    pd.print ( 500.263 ); /* Call print to print float */
    pd.print ( "Hello C++" ); /* Call print to print character */
    return 0;
}
```

执行结果：

``` cpp
Printing int: 5
Printing float: 500.263
Printing character: Hello C++
```

### C++中的运算符重载

&emsp;&emsp;您可以重定义或重载大部分`C++`内置的运算符，这样就能使用自定义类型的运算符。重载的运算符是带有特殊名称的函数，函数名是由关键字`operator`和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

``` cpp
Box operator+(const Box&);
```

声明加法运算符用于把两个`Box`对象相加，返回最终的`Box`对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么需要为每次操作传递两个参数：

``` cpp
Box operator+(const Box&, const Box&);
```

下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用`this`运算符进行访问：

``` cpp
#include <iostream>

using namespace std;

class Box {
public:
    double getVolume ( void ) {
        return length * breadth * height;
    }

    void setLength ( double len ) {
        length = len;
    }

    void setBreadth ( double bre ) {
        breadth = bre;
    }

    void setHeight ( double hei ) {
        height = hei;
    }

    Box operator+ ( const Box &b ) { /* 重载“+”运算符，用于把两个Box对象相加 */
        Box box;
        box.length = this->length + b.length;
        box.breadth = this->breadth + b.breadth;
        box.height = this->height + b.height;
        return box;
    }

private:
    double length;  /* 长度 */
    double breadth; /* 宽度 */
    double height;  /* 高度 */
};

int main() {
    Box Box1;
    Box Box2;
    Box Box3;
    double volume = 0.0; /* 把体积存储在该变量中 */

    /* Box1详述 */
    Box1.setLength ( 6.0 );
    Box1.setBreadth ( 7.0 );
    Box1.setHeight ( 5.0 );

    /* Box2详述 */
    Box2.setLength ( 12.0 );
    Box2.setBreadth ( 13.0 );
    Box2.setHeight ( 10.0 );

    /* Box1的体积 */
    volume = Box1.getVolume();
    cout << "Volume of Box1 : " << volume << endl;

    /* Box2的体积 */
    volume = Box2.getVolume();
    cout << "Volume of Box2 : " << volume << endl;
    /* 把两个对象相加，得到Box3 */
    Box3 = Box1 + Box2;
    /* Box3的体积 */
    volume = Box3.getVolume();
    cout << "Volume of Box3 : " << volume << endl;
    return 0;
}
```

执行结果：

``` cpp
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
```

### 可重载运算符/不可重载运算符

&emsp;&emsp;下面是可重载的运算符列表：

``` cpp
+       -       *       /       %       ^
&       |       ~       !       ,       =
<       >       <=      >=      ++      --
<<      >>      ==      !=      &&      ||
+=      -=      /=      %=      ^=      &=
|=      *=      <<=     >>=     []      ()
->      ->*     new     new []  delete  delete []
```

下面是不可重载的运算符列表：

``` cpp
::  .*  .   ?:
```

### 运算符重载实例

#### C++一元运算符重载

&emsp;&emsp;一元运算符只对一个操作数进行操作，通常出现在它们所操作的对象的左边，比如`!obj`、`-obj`和`++obj`。但有时它们也可以作为后缀，比如`obj++`或`obj--`。

``` cpp
#include <iostream>

using namespace std;

class Distance {
private:
    int feet;
    int inches;

public:
    Distance() { /* 所需的构造函数 */
        feet = 0;
        inches = 0;
    }

    Distance ( int f, int i ) {
        feet = f;
        inches = i;
    }

    void displayDistance() { /* 显示距离的方法 */
        cout << "F: " << feet << " I:" << inches << endl;
    }

    Distance operator- () { /* 重载负运算符“-” */
        feet = -feet;
        inches = -inches;
        return Distance ( feet, inches );
    }
};

int main() {
    Distance D1 ( 11, 10 ), D2 ( -5, 11 );
    -D1; /* 取相反数 */
    D1.displayDistance(); /* D1的距离 */
    -D2; /* 取相反数 */
    D2.displayDistance(); /* D2的距离 */
    return 0;
}
```

执行结果：

``` cpp
F: -11 I:-10
F: 5 I:-11
```

#### C++二元运算符重载

&emsp;&emsp;二元运算符需要两个参数，我们平常使用的加运算符`+`、减运算符`-`、乘运算符`*`和除运算符`/`都属于二元运算符。

#### C++关系运算符重载

&emsp;&emsp;`C++`语言支持各种关系运算符(`<`、`>`、`<=`、`>=`、`==`等)，它们可用于比较`C++`内置的数据类型。您可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。下面的实例演示了如何重载`<`运算符，类似地，您也可以尝试重载其他的关系运算符。

``` cpp
#include <iostream>

using namespace std;

class Distance {
private:
    int feet;
    int inches;

public:
    Distance() {
        feet = 0;
        inches = 0;
    }

    Distance ( int f, int i ) {
        feet = f;
        inches = i;
    }

    void displayDistance() {
        cout << "F: " << feet << " I:" << inches << endl;
    }

    bool operator < ( const Distance &d ) { /* 重载小于运算符(<) */
        if ( feet < d.feet ) {
            return true;
        }

        if ( feet == d.feet && inches < d.inches ) {
            return true;
        }

        return false;
    }
};

int main() {
    Distance D1 ( 11, 10 ), D2 ( 5, 11 );

    if ( D1 < D2 ) {
        cout << "D1 is less than D2" << endl;
    } else {
        cout << "D2 is less than D1" << endl;
    }

    return 0;
}
```

执行结果：

``` cpp
D2 is less than D1
```

#### C++输入/输出运算符重载

&emsp;&emsp;`C++`能够使用流提取运算符`>>`和流插入运算符`<<`来输入和输出内置的数据类型。您可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。我们需要把运算符重载函数声明为类的友元函数，这样就能不用创建对象而直接调用函数。下面的实例演示了如何重载提取运算符`>>`和插入运算符`<<`：

``` cpp
#include <iostream>

using namespace std;

class Distance {
private:
    int feet;
    int inches;

public:
    Distance() {
        feet = 0;
        inches = 0;
    }

    Distance ( int f, int i ) {
        feet = f;
        inches = i;
    }

    friend ostream &operator<< ( ostream &output, const Distance &D ) {
        output << "F : " << D.feet << " I : " << D.inches;
        return output;
    }

    friend istream &operator>> ( istream &input, Distance &D ) {
        input >> D.feet >> D.inches;
        return input;
    }
};

int main() {
    Distance D1 ( 11, 10 ), D2 ( 5, 11 ), D3;
    cout << "Enter the value of object : " << endl;
    cin >> D3;
    cout << "First Distance :" << D1 << endl;
    cout << "Second Distance :" << D2 << endl;
    cout << "Third Distance :" << D3 << endl;
    return 0;
}
```

执行结果：

``` cpp
Enter the value of object :
70
10
First Distance :F : 11 I : 10
Second Distance :F : 5 I : 11
Third Distance :F : 70 I : 10
```

#### C++的++和--运算符重载

&emsp;&emsp;下面的实例演示了如何重载递增运算符`++`，包括前缀和后缀两种用法。类似地，您也可以尝试重载递减运算符`--`。

``` cpp
#include <iostream>

using namespace std;

class Time {
private:
    int hours;
    int minutes;

public:
    Time() {
        hours = 0;
        minutes = 0;
    }

    Time ( int h, int m ) {
        hours = h;
        minutes = m;
    }

    void displayTime() { /* 显示时间的方法 */
        cout << "H: " << hours << " M: " << minutes << endl;
    }

    Time operator++ () { /* 重载前缀递增运算符(++) */
        ++minutes; /* 对象加1 */

        if ( minutes >= 60 ) {
            ++hours;
            minutes -= 60;
        }

        return Time ( hours, minutes );
    }

    Time operator++ ( int ) { /* 重载后缀递增运算符(++) */
        Time T ( hours, minutes ); /* 保存原始值 */
        ++minutes; /* 对象加1 */

        if ( minutes >= 60 ) {
            ++hours;
            minutes -= 60;
        }

        return T; /* 返回旧的原始值 */
    }
};

int main() {
    Time T1 ( 11, 59 ), T2 ( 10, 40 );
    ++T1;             /* T1加1   */
    T1.displayTime(); /* 显示T1  */
    ++T1;             /* T1再加1 */
    T1.displayTime(); /* 显示T1  */
    T2++;             /* T2加1   */
    T2.displayTime(); /* 显示T2  */
    T2++;             /* T2再加1 */
    T2.displayTime(); /* 显示T2  */
    return 0;
}
```

执行结果：

``` cpp
H: 12 M: 0
H: 12 M: 1
H: 10 M: 41
H: 10 M: 42
```

#### C++赋值运算符重载

&emsp;&emsp;您可以重载赋值运算符`=`，用于创建一个对象，比如拷贝构造函数。`C++`规定，赋值运算符必须使用成员函数重载，而重载赋值运算符的成员函数不能被派生类继承。

``` cpp
#include <iostream>

using namespace std;

class Distance {
private:
    int feet;
    int inches;

public:
    Distance() {
        feet = 0;
        inches = 0;
    }

    Distance ( int f, int i ) {
        feet = f;
        inches = i;
    }

    void operator= ( const Distance &D ) {
        feet = D.feet;
        inches = D.inches;
    }

    void displayDistance() {
        cout << "F: " << feet << " I:" << inches << endl;
    }
};

int main() {
    Distance D1 ( 11, 10 ), D2 ( 5, 11 );
    cout << "First Distance : ";
    D1.displayDistance();
    cout << "Second Distance :";
    D2.displayDistance();
    D1 = D2; /* 使用赋值运算符 */
    cout << "First Distance :";
    D1.displayDistance();
    return 0;
}
```

执行结果：

``` cpp
First Distance : F: 11 I:10
Second Distance :F: 5 I:11
First Distance :F: 5 I:11
```

#### C++函数调用运算符\(\)重载

&emsp;&emsp;函数调用运算符`()`可以被重载用于类的对象。当重载`()`时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。该运算符不能用友元函数来实现，只能采用非静态的成员函数。

``` cpp
#include <iostream>

using namespace std;

class Distance {
private:
    int feet;
    int inches;

public:
    Distance() {
        feet = 0;
        inches = 0;
    }

    Distance ( int f, int i ) {
        feet = f;
        inches = i;
    }

    Distance operator() ( int a, int b, int c ) { /* 重载函数调用运算符 */
        Distance D;
        D.feet = a + c + 10;
        D.inches = b + c + 100;
        return D;
    }

    void displayDistance() {
        cout << "F: " << feet << " I: " << inches << endl;
    }
};

int main() {
    Distance D1 ( 11, 10 ), D2;
    cout << "First Distance: ";
    D1.displayDistance();
    D2 = D1 ( 10, 10, 10 ); /* invoke operator() */
    cout << "Second Distance: ";
    D2.displayDistance();
    return 0;
}
```

执行结果：

``` cpp
First Distance: F: 11 I: 10
Second Distance: F: 30 I: 120
```

#### C++下标运算符\[\]重载

&emsp;&emsp;下标操作符`[]`通常用于访问数组元素。重载该运算符用于增强操作`C++`数组的功能。下标运算符只能由类的成员函数来实现，不能由友元函数来实现。

``` cpp
#include <iostream>

using namespace std;

const int SIZE = 10;

class safearay {
private:
    int arr[SIZE];

public:
    safearay() {
        register int i;

        for ( i = 0; i < SIZE; i++ ) {
            arr[i] = i;
        }
    }

    int operator[] ( int i ) {
        if ( i > SIZE ) {
            cout << "索引超过最大值" << endl;
            return arr[0]; /* 返回第一个元素 */
        }

        return arr[i];
    }
};

int main() {
    safearay A;
    cout << "A[2]的值为 : " << A[2] << endl;
    cout << "A[5]的值为 : " << A[5] << endl;
    cout << "A[12]的值为 : " << A[12] << endl;
    return 0;
}
```

执行结果：

``` cpp
A[2]的值为 : 2
A[5]的值为 : 5
索引超过最大值
A[12]的值为 : 0
```

#### C++类成员访问运算符->重载

&emsp;&emsp;类成员访问运算符`->`可以被重载，用于为一个类赋予`指针`行为。运算符`->`必须是一个成员函数。如果使用了`->`运算符，返回类型必须是指针或者是类的对象。
&emsp;&emsp;运算符`->`通常与指针引用运算符`*`结合使用，用于实现`智能指针`。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁或者当指针指向另一个对象时，它自动删除对象。
&emsp;&emsp;间接引用运算符`->`可被定义为一个一元后缀运算符。也就是说，给出一个类：

``` cpp
class Ptr {
    /* ... */
    X *operator->();
};
```

类`Ptr`的对象可用于访问类`X`的成员，使用方式与指针的用法十分相似。

``` cpp
void f ( Ptr p ) {
    p->m = 10; /* (p.operator->())->m = 10 */
}
```

语句`p->m`被解释为`(p.operator->())->m`。

``` cpp
#include <iostream>
#include <vector>

using namespace std;

class Obj { /* 假设一个实际的类 */
private:
    static int i, j;

public:
    void f() const {
        cout << i++ << endl;
    }

    void g() const {
        cout << j++ << endl;
    }
};

int Obj::i = 10; /* 静态成员定义 */
int Obj::j = 12;

class ObjContainer { /* 为上面的类实现一个容器 */
private:
    vector<Obj *> a;

public:
    void add ( Obj *obj ) {
        a.push_back ( obj ); /* 调用向量的标准方法 */
    }

    friend class SmartPointer;
};

class SmartPointer { /* 实现智能指针，用于访问类Obj的成员 */
private:
    ObjContainer oc;
    int index;

public:
    SmartPointer ( ObjContainer &objc ) {
        oc = objc;
        index = 0;
    }

    /* 返回值表示列表结束 */
    bool operator++() { /* 前缀版本 */
        if ( index >= oc.a.size() ) {
            return false;
        }

        if ( oc.a[++index] == 0 ) {
            return false;
        }

        return true;
    }

    bool operator++ ( int ) { /* 后缀版本 */
        return operator++();
    }

    /* 重载运算符“->” */
    Obj *operator->() const {
        if ( !oc.a[index] ) {
            cout << "Zero value";
            return ( Obj * ) 0;
        }

        return oc.a[index];
    }
};

int main() {
    const int sz = 10;
    Obj o[sz];
    ObjContainer oc;

    for ( int i = 0; i < sz; i++ ) {
        oc.add ( &o[i] );
    }

    SmartPointer sp ( oc ); /* 创建一个迭代器 */

    do {
        sp->f(); /* 智能指针调用 */
        sp->g();
    } while ( sp++ );

    return 0;
}
```

执行结果：

``` cpp
10
12
11
13
12
14
13
15
14
16
15
17
16
18
17
19
18
20
19
21
```


---

&emsp;&emsp;运算符重载的函数一般地采用如下两种形式：成员函数和友元函数，这两种形式都可访问类中的私有成员。

### 重载为类的成员函数

&emsp;&emsp;这里先举一个重载复数的四则运算符的例子。复数由实部和虚部构造，可以先定义一个复数类，然后再在类中重载复数四则运算的运算符。

``` cpp
#include <iostream>

using namespace std;

class complex {
public:
    complex() {
        real = imag = 0;
    }

    complex ( double r, double i ) {
        real = r, imag = i;
    }

    complex operator + ( const complex &c );
    complex operator - ( const complex &c );
    complex operator * ( const complex &c );
    complex operator / ( const complex &c );
    friend void print ( const complex &c );

private:
    double real, imag;
};

inline complex complex::operator + ( const complex &c ) {
    return complex ( real + c.real, imag + c.imag );
}

inline complex complex::operator - ( const complex &c ) {
    return complex ( real - c.real, imag - c.imag );
}

inline complex complex::operator * ( const complex &c ) {
    return complex ( real * c.real - imag * c.imag, real * c.imag + imag * c.real );
}

inline complex complex::operator / ( const complex &c ) {
    return complex ( ( real * c.real + imag + c.imag ) / ( c.real * c.real + c.imag * c.imag ),
                     ( imag * c.real - real * c.imag ) / ( c.real * c.real + c.imag * c.imag ) );
}

void print ( const complex &c ) {
    if ( c.imag < 0 ) {
        cout << c.real << c.imag << 'i';
    } else {
        cout << c.real << '+' << c.imag << 'i';
    }
}

int main() {
    complex c1 ( 2.0, 3.0 ), c2 ( 4.0, -2.0 ), c3;
    c3 = c1 + c2;
    cout << "c1+c2=";
    print ( c3 );
    c3 = c1 - c2;
    cout << "\nc1-c2=";
    print ( c3 );
    c3 = c1 * c2;
    cout << "\nc1*c2=";
    print ( c3 );
    c3 = c1 / c2;
    cout << "\nc1/c2=";
    print ( c3 );
    c3 = ( c1 + c2 ) * ( c1 - c2 ) * c2 / c1;
    cout << "\n(c1+c2)*(c1-c2)*c2/c1=";
    print ( c3 );
    cout << endl;
}
```

执行结果：

``` cpp
c1+c2=6+1i
c1-c2=-2+5i
c1*c2=14+8i
c1/c2=0.45+0.8i
(c1+c2)*(c1-c2)*c2/c1=9.61538+25.2308i
```

类`complex`定义了`4`个成员函数作为运算符重载函数。将运算符重载函数说明为类的成员函数格式如下：

``` cpp
<类名> operator <运算符>(<参数表>)
```

`operator`是定义运算符重载函数的关键字。程序中出现的表达式`c1+c2`，编译程序将其解释为`c1.operator+(c2)`，其中`c1`和`c2`是`complex`类的对象。`operator+()`是运算`+`的重载函数。
&emsp;&emsp;该运算符重载函数仅有一个参数`c2`。可见，当重载为成员函数时，双目运算符仅有一个参数，单目运算符不能再显式地说明参数。重载为成员函数时，总时隐含了一个参数，该参数是`this`指针。`this`指针是指向调用该成员函数对象的指针。

### 重载为友元函数

&emsp;&emsp;运算符重载函数还可以为友元函数。当重载为友元函数时，将没有隐含的参数`this`指针。对于双目运算符，友元函数有`2`个参数；对单目运算符，友元函数有一个参数。但有些运行符不能重载为友元函数，它们是`=`、`()`、`[]`和`->`。重载为友元函数的运算符重载函数的定义格式如下：

``` cpp
friend <类型说明符> operator <运算符> (<参数表>) {
}
```

&emsp;&emsp;下面用友元函数代码成员函数，重载编写上述的例子：

``` cpp
#include <iostream>

using namespace std;

class complex {
public:
    complex() {
        real = imag = 0;
    }

    complex ( double r, double i ) {
        real = r, imag = i;
    }

    friend complex operator + ( const complex &c1, const complex &c2 );
    friend complex operator - ( const complex &c1, const complex &c2 );
    friend complex operator * ( const complex &c1, const complex &c2 );
    friend complex operator / ( const complex &c1, const complex &c2 );
    friend void print ( const complex &c );

private:
    double real, imag;
};

complex operator + ( const complex &c1, const complex &c2 ) {
    return complex ( c1.real + c2.real, c1.imag + c2.imag );
}

complex operator - ( const complex &c1, const complex &c2 ) {
    return complex ( c1.real - c2.real, c1.imag - c2.imag );
}

complex operator * ( const complex &c1, const complex &c2 ) {
    return complex ( c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real );
}

complex operator / ( const complex &c1, const complex &c2 ) {
    return complex ( ( c1.real * c2.real + c1.imag * c2.imag ) / ( c2.real * c2.real + c2.imag * c2.imag ),
                     ( c1.imag * c2.real - c1.real * c2.imag ) / ( c2.real * c2.real + c2.imag * c2.imag ) );
}

void print ( const complex &c ) {
    if ( c.imag < 0 ) {
        cout << c.real << c.imag << 'i';
    } else {
        cout << c.real << '+' << c.imag << 'i';
    }
}

int main() {
    complex c1 ( 2.0, 3.0 ), c2 ( 4.0, -2.0 ), c3;
    c3 = c1 + c2;
    cout << "c1+c2=";
    print ( c3 );
    c3 = c1 - c2;
    cout << "\nc1-c2=";
    print ( c3 );
    c3 = c1 * c2;
    cout << "\nc1*c2=";
    print ( c3 );
    c3 = c1 / c2;
    cout << "\nc1/c2=";
    print ( c3 );
    c3 = ( c1 + c2 ) * ( c1 - c2 ) * c2 / c1;
    cout << "\n(c1 + c2) * (c1 - c2) * c2 / c1 = ";
    print ( c3 );
    cout << endl;
}
```

前面已讲过，对于双目运算符，重载为成员函数时，仅有一个参数，另一个被隐含；重载为友元函数时，有两个参数，没有隐含参数。因此，程序中出现的`c1+c2`，编译程序解释为`operator+(c1, c2)`，调用如下函数进行求值：

``` cpp
complex operator + ( const coplex &c1, const complex &c2 )
```

### 两种重载形式的比较

&emsp;&emsp;一般说来，单目运算符最好被重载为成员；对双目运算符最好被重载为友元函数，双目运算符重载为友元函数比重载为成员函数更方便一些。但是，有的双目运算符还是重载为成员函数为好，例如赋值运算符，因为它如果被重载为友元函数，将会出现与赋值语义不一致的地方。

---

### 类型转换函数

&emsp;&emsp;类型转换函数是指用转换构造函数可以将一个指定类型的数据转换为类的对象。
&emsp;&emsp;用类型转换函数(`type conversion function`)可以将一个类的对象转换为一个指定类型的数据。类型转换函数的一般形式为：

``` cpp
operator 类型名() {
    /* 实现转换的语句 */
}
```

在函数名前面不能指定函数类型，函数没有参数。请注意，函数名是`operator double`，这一点和运算符重载是一致的。
&emsp;&emsp;类型转换函数的作用是将一个类的对象转换成另一类型的数据，例如如果已声明了一个`Complex`类，可以在`Complex`类中这样定义类型转换函数：

``` cpp
operator double() {
    return m_dReal;
}
```

函数返回`double`型变量`m_dReal`的值，它的作用是将一个`Complex`类对象转换为一个`double`型数据，其值是`Complex`类中的数据成员`m_dReal`的值。

``` cpp
#include <iostream>

using namespace std;

class Complex {
public:
    Complex();
    Complex ( double dReal, double dImag );
    operator double();

private:
    double m_dReal;
    double m_dImag;
};

Complex::Complex() {
    m_dReal = 0;
    m_dImag = 0;
}

Complex::Complex ( double dReal, double dImag ) {
    m_dReal = dReal;
    m_dImag = dImag;
}

Complex::operator double() {
    return m_dReal;
}

int main() {
    Complex obj ( 3, 4 );
    double dNum = 0.0;
    dNum = 2.5 + obj;
    cout << "dNum = " << dNum << endl; /* dNum = 5.5 */
    return 0;
}
```

如果在`Complex`类中没有定义类型转换函数`operator double`，程序编译将出错，因为不能实现`double`型数据与`Complex`类对象相加。现在定义了成员函数`operator double`，就可以利用它将`Complex`类对象转换为`double`型数据。请注意，程序中不必显式地调用类型转换函数，它是自动被调用的，即隐式调用，当然也可以显式调用。
&emsp;&emsp;转换函数只能是成员函数，不能是友元函数。转换函数可以被继承，也可以说明为虚函数，一个类中可以定义多个转换函数。