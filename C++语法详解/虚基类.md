---
title: 虚基类
date: 2019-02-05 20:03:11
categories: C++语法详解
---
&emsp;&emsp;例如有基类`B`，从`B`派生出`C`和`D`，然后类`F`又同时继承了`C`和`D`。如果`F`访问自己的从基类`B`那里继承过来的的数据成员或者函数成员，那么编译器就不知道你指的到底是从`C`那里继承过来的`B`对象呢，还是从`D`那里继承过来的`B`对象呢。
&emsp;&emsp;于是虚基类诞生了，将`C`和`D`的继承方式改为虚继承，那么`F`访问自己从`B`那里继承过来的成员就不会有二义性问题了。下面用一段代码来说明虚基类的使用：

``` cpp
#include <iostream>
​
using namespace std;
​
class A {
public:
    int i;
    void showa() {
        cout << "i = " << i << endl;
    }
};
​
class B: virtual public A { /* 此处采用虚继承 */
public:
    int j;
};
​
class C: virtual public A { /* 此处采用虚继承 */
public:
    int k;
};
​
class D: public B, public C {
public:
    int m;
};
​
int main( void ) {
    A a;
    B b;
    C c;
    a.i = 1;
    a.showa();
    b.i = 2;
    b.showa();
    c.i = 3;
    c.showa();
    D d;
    d.i = 4;
    d.showa();
    // cout << "Hello world!" << endl;
    return 0;
}
```

&emsp;&emsp;从这个代码可以看出，`B`、`C`和`D`从`A`那里继承过来了`i`这个变量，并且它们之间不会有任何影响。如果`B`和`C`不是采用虚继承方式，那么`d.i = 4;`就不能编译通过了。

---

&emsp;&emsp;当在多条继承路径上有一个公共的基类，在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)。若只想保存这个基类的一个实例，可以将这个公共基类说明为虚基类。
&emsp;&emsp;在继承中产生歧义的原因有可能是继承类继承了基类多次，从而产生了多个拷贝，即不止一次的通过多个路径继承类在内存中创建了基类成员的多份拷贝。虚基类的基本原则是在内存中只有基类成员的一份拷贝。这样，通过把基类继承声明为虚拟的，就只能继承基类的一份拷贝，从而消除歧义。用`virtual`限定符把基类继承说明为虚拟的：

``` cpp
class x1: virtual public x {
};
​
class x2: virtual public x {
};
```

&emsp;&emsp;虚基类的初始化与一般多继承的初始化在语法上是一样的，但构造函数的调用次序不同。派生类构造函数的调用次序有三个原则：

- 虚基类的构造函数在非虚基类之前调用。
- 若同一层次中包含多个虚基类，这些虚基类的构造函数按它们说明的次序调用。
- 若虚基类由非虚基类派生而来，则仍先调用基类构造函数，再调用派生类的构造函数。

``` cpp
#include <iostream>
​
using namespace std;
​
class B0 { /* 声明为基类B0 */
    int nv;

public:
    B0 ( int n ) {
        nv = n; /* B0类的构造函数 */
        cout << "Member of B0" << endl;
    }

    void fun() {
        cout << "fun of B0" << endl;
    }
};
​
class B1 : virtual public B0 {
    int nv1;

public:
    B1 ( int a ) : B0 ( a ) {
        cout << "Member of B1" << endl;
    }
};
​
class B2 : virtual public B0 {
    int nv2;

public:
    B2 ( int a ) : B0 ( a ) {
        cout << "Member of B2" << endl;
    }
};
​
class D1 : public B1, public B2 {
    int nvd;

public:
    D1 ( int a ) : B0 ( a ), B1 ( a ), B2 ( a ) {
        cout << "Member of D1" << endl;
    }

    void fund() {
        cout << "fun of D1" << endl;
    }
};
​
int main ( void ) {
    D1 d1 ( 1 );
    d1.fund();
    d1.fun();
    return 0;
}
```

执行结果：

``` cpp
Member of B0
Member of B1
Member of B2
Member of D1
fun of D1
fun of B0
```

这里`D1`在`B1`、`B2`上继承，间接继承`B0`。`D1`继承的成员变量有`nv`、`nv1`、`nv2`，并且只继承一次，若不是由虚基类继承而来，那么`nv`会被`D1`从`B1`和`B2`各继承一次，造成冗余。