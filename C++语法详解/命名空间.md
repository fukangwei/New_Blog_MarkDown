---
title: 命名空间
date: 2019-02-07 11:23:43
tags:
---
&emsp;&emsp;假设这样一种情况，当一个班上有两个名叫`Zara`的学生时，为了区分它们，除了使用名字之外，不得不使用一些额外的信息，例如他们的家庭住址。同样的情况也出现在`C++`程序中。例如，您可能会写一个名为`xyz`的函数，在另一个可用的库中也存在函数`xyz`。这样，编译器就无法判断您所使用的是哪一个`xyz`函数。因此引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文，本质上命名空间就是定义了一个范围。
&emsp;&emsp;命名空间的定义使用关键字`namespace`，后跟命名空间的名称：

``` cpp
namespace namespace_name {
    /* 代码声明 */
}
```

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：

``` cpp
name::code;  /* code可以是变量或函数 */
```

&emsp;&emsp;来看看命名空间如何为变量或函数等实体定义范围：

``` cpp
#include <iostream>
​
using namespace std;
​
namespace first_space { /* 第一个命名空间 */
    void func() {
        cout << "Inside first_space" << endl;
    }
}
​
namespace second_space { /* 第二个命名空间 */
    void func() {
        cout << "Inside second_space" << endl;
    }
}
​
int main () {
    first_space::func(); /* 调用第一个命名空间中的函数 */
    second_space::func(); /* 调用第二个命名空间中的函数 */
    return 0;
}
```

执行结果：

``` cpp
Inside first_space
Inside second_space
```

&emsp;&emsp;可以使用`using namespace`指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。

``` cpp
#include <iostream>
​
using namespace std;
​
namespace first_space { /* 第一个命名空间 */
    void func() {
        cout << "Inside first_space" << endl;
    }
}
​
namespace second_space { /* 第二个命名空间 */
    void func() {
        cout << "Inside second_space" << endl;
    }
}
​
using namespace first_space;
​
int main () {
    func(); /* 调用第一个命名空间中的函数 */
    return 0;
}
```

执行结果：

``` cpp
Inside first_space
```

&emsp;&emsp;`using`指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用`std`命名空间中的`cout`部分，可以使用如下的语句：

``` cpp
using std::cout;
```

随后的代码中，在使用`cout`时就可以不用加上命名空间名称作为前缀，但是`std`命名空间中的其他项目仍然需要加上命名空间名称作为前缀：

``` cpp
#include <iostream>
​
using std::cout;
​
int main () {
    cout << "std::endl is used with std!" << std::endl;
    return 0;
}
```

执行结果：

``` cpp
std::endl is used with std!
```

&emsp;&emsp;`using`指令引入的名称遵循正常的范围规则。名称从使用`using`指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。
&emsp;&emsp;命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中，所以如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：

``` cpp
namespace namespace_name {
    /* 代码声明 */
}
```

命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间：

``` cpp
namespace namespace_name1 {
    /* 代码声明 */
    namespace namespace_name2 {
        /* 代码声明 */
    }
}
```

您可以通过使用`::`运算符来访问嵌套的命名空间中的成员：

``` cpp
using namespace namespace_name1::namespace_name2; /* 访问namespace_name2中的成员 */
using namespace namespace_name1; /* 访问namespace:name1中的成员 */
```

在上面的语句中，如果使用的是`namespace_name1`，那么在该范围内`namespace_name2`中的元素也是可用的。

``` cpp
#include <iostream>
​
using namespace std;
​
namespace first_space { /* 第一个命名空间 */
    void func() {
        cout << "Inside first_space" << endl;
    }
​
    namespace second_space { /* 第二个命名空间 */
        void func() {
            cout << "Inside second_space" << endl;
        }
    }
}
​
using namespace first_space::second_space;
​
int main () {
    func(); /* 调用第二个命名空间中的函数 */
    return 0;
}
```

---

### C++在命名空间中声明类和成员函数

&emsp;&emsp;名字空间是一个范畴，它包含类声明、函数声明、常量声明和模板声明等名字空间成员。例如：

``` cpp
namespace proj_alpha {
class Spy { /* 下面是名字空间proj_alpha的成员 */
    /* ... */
};
​
void encrypt ( char *msg );
const int MAX_SPIES = 8;
}
```

在上面的例子中，类`Spy`在一个单独的文件中实现。通常是在一个专门的头文件中声明一个类并在不同的源文件中独立地定义其成员函数。那么如何将名字空间成员类分离成多个源文件呢？
&emsp;&emsp;下面是名为`Foo.hpp`的头文件，其中定义了一个名为`NS`的名字空间，它包含类`Foo`的声明：

``` cpp
namespace NS {
class Foo {
public:
    void f();
    void g();
};
}
```

在一个单独的源文件`Foo.cpp`中，首先包含头文件`Foo.hpp`以便实现类`Foo`的成员函数`f`和`g`：

``` cpp
#include "Foo.hpp"
​
void NS::Foo::f() {
    /* ... */
}
​
void NS::Foo::g() {
    /* ... */
}
```

为了使用名字空间成员，必须使用成员的全路径名，它由名字空间后跟`::`合成原名组成。因此，类`Foo`的全路径名是`NS::Foo`。这样，编译器便可以知道`NS`是一个名字空间名，头文件`Foo.hpp`必须在引用`NS`之前被包含。
&emsp;&emsp;名字空间是可以扩展的，也就是说可以声明类，而且所声明的类在其它的`.cpp`文件中是相同的名字空间成员：

``` cpp
/* Bar.hpp */
namespace NS { /* 扩展NS */
class Bar {
public:
    void a();
    void b();
};
}
```

在`Bar.cpp`文件中：

``` cpp
#include "Bar.hpp"
​
void NS::Bar::a() {
    /* ... */
}
​
void NS::Bar::b() {
    /* ... */
}
```

可以看出，虽然`Foo`和`Bar`这两个类在不同的头文件中声明，但它们都是名字空间`NS`的成员。并且编译器和链接器将这两个类看成是同一名字空间的成员。

---

### Namespace aliases

&emsp;&emsp;Namespace aliases allow the programmer to define an alternate name for a namespace. They are commonly used as a convenient shortcut for long or `deeply-nested` namespaces. Syntax:

``` cpp
namespace alias_name = ns_name;              (1)  
namespace alias_name = ::ns_name;            (2)  
namespace alias_name = nested_name::ns_name; (3)
```

&emsp;&emsp;Explanation: The new alias `alias_name` provides an alternate method of accessing `ns_name`. `alias_name` must be a name not previously used. `alias_name` is valid for the duration of the scope in which it is introduced. Example:

``` cpp
#include <iostream>
​
namespace foo {
    namespace bar {
        namespace baz {
            int qux = 42;
        }
    }
}
​
namespace fbz = foo::bar::baz;
​
int main() {
    std::cout << fbz::qux << '\n';
}
```

Output: `42`.