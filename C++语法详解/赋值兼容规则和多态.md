---
title: 赋值兼容规则和多态
categories: C++语法详解
abbrlink: 97527f40
date: 2018-12-27 10:10:28
---
&emsp;&emsp;赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且对于调用者来说，所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。赋值兼容规则中所指的替代包括以下的情况：<!--more-->

- 派生类的对象可以赋值给基类对象。
- 派生类的对象可以初始化基类的引用。
- 派生类对象的地址可以赋给指向基类的指针。

&emsp;&emsp;在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。如果`B`类为基类，`D`为`B`类的公有派生类，则`D`类中包含了基类`B`中除构造、析构函数之外的所有成员，这时根据赋值兼容规则，在基类`B`的对象可以使用的任何地方，都可以用派生类的对象来替代。在如下程序中，`b1`为`B`类的对象，`d1`为`D`的对象。

``` cpp
class B {
}
​
class D：public B {
}
​
B b1, *pbl;
D d1;
```

- 派生类对象可以赋值给基类对象，即用派生类对象中从基类继承来的成员，逐个赋值给基类对象的成员：`b1 = d1;`，这里会发生内容切割(`object slicing`)。
- 派生类的对象也可以初始化基类对象的引用：`B &bb = d1;`。
- 派生类对象的地址也可以赋给指向基类的指针：`pb1 = &d1;`。

&emsp;&emsp;由于赋值兼容规则的引入，对于基类及其公有派生类的对象，我们可以使用相同的函数统一进行处理(因为当函数的形参为基类的对象时，实参可以是派生类的对象)，而没有必要为每一个类设计单独的模块，从而大大提高了程序的效率。这正是`C++`的又一重要特色，即多态性，可以说赋值兼容规则是多态性的重要基础之一。
&emsp;&emsp;运行过程中的多态需要满足三个条件：首先类之间应满足赋值兼容规则，其二是要声明虚函数，第三是要由成员函数来调用或者是通过指针、引用来访问虚函数。如果是使用对象名来访问虚函数，则联编在编译过程中就可以进行(静态联编)，而无需在运行过程中进行。