---
title: 函数返回引用
categories: C++语法详解
abbrlink: 9379a316
date: 2019-02-05 20:14:57
---
&emsp;&emsp;`C++`函数为什么要使用引用？`C`语言代码大量地利用指针作为函数形参或者返回值，这是由于值拷贝会有很大的消耗(例如传入传出一个结构体)。所以`C++`使用引用作为函数参数和返回值的目的和使用指针是一样的，而且形式上更加直观。<!--more-->
&emsp;&emsp;当函数返回引用类型的时候，没有复制返回值，而是返回对象的引用(即对象本身)。函数返回的引用实际上是一个变量的内存地址，既然是内存地址的话，那么肯定可以读写该地址所对应的内存区域的值(就是左值)，可以出现在赋值语句的左边。函数返回的对象引用，必须在调用函数前就已经存在，不允许返回局部变量的引用！如果不希望返回的对象被修改的时候，可以添加`const`。

``` cpp
#include <iostream>
​
using namespace std;
​
string make_plural ( size_t, const string &, const string & );
const string &shorterString ( const string &, const string & );
const string &mainip ( const string & );
char &get_val ( string &, string::size_type );
​
int main ( void ) {
    cout << make_plural ( 1, "dog", "s" ) << endl;
    cout << make_plural ( 2, "dog", "s" ) << endl;
    string string1 = "1234";
    string string2 = "abc";
    cout << shorterString ( string1, string2 ) << endl;
    cout << mainip ( "jiajia" ) << endl;
    string s ( "123456" );
    cout << s << endl;
    get_val ( s, 0 ) = 'a';
    cout << s << endl;
    getchar();
    return 0;
}
​
/* 返回非引用 */
string make_plural ( size_t i, const string &word, const string &ending ) {
    return ( i == 1 ) ? word : word + ending;
}
​
/* 返回引用 */
const string &shorterString ( const string &s1, const string &s2 ) {
    return s1.size() < s2.size() ? s1 : s2;
}
​
/* 禁止返回局部对象的引用 */
const string &mainip ( const string &s ) {
    string ret = s;
    return ret;
}
​
/* 引用返回左值 */
char &get_val ( string &str, string::size_type ix ) {
    return str[ix];
}
```

当函数返回值类型为引用时，一般就用引用类型去接收。如果用非引用类型接收，就等于将函数返回的引用的数据值复制给了该接收对象，和函数返回非引用类型是一样的。注意如下事项：
&emsp;&emsp;1. 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了`无所指`的引用，程序会进入未知状态。
&emsp;&emsp;2. 不能返回函数内部`new`分配的内存的引用。虽然不存在局部变量的被动销毁问题，但是对于这种情况，又面临其它尴尬局面。例如被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间(由`new`分配)就无法释放，造成`memory leak`。
&emsp;&emsp;3. 可以返回类成员的引用，但最好是`const`。主要原因是当对象的属性是与某种业务规则(`business rule`)相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用(或指针)，那么对该属性的单纯赋值就会破坏业务规则的完整性。
&emsp;&emsp;4. 流操作符重载返回值申明为`引用`的作用：对于流操作符`<<`和`>>`，这两个操作符常常希望被连续使用，例如`cout << "hello" << endl;`，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新(拷贝)构造一个新的流对象，也就是说，连续的两个`<<`操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针，则不能连续使用`<<`操作符，因此返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是`C++`语言中引入`引用`这个概念的原因吧。赋值操作符`=`像流操作符一样，是可以连续使用的，例如`x = j = 10;`或者`(x = 10) = 100;`。赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
&emsp;&emsp;5. 千万不能返回四则运算符的引用。主要原因是这四个操作符没有`side effect`，因此它们必须构造一个对象作为返回值。

&emsp;&emsp;**补充说明**：引用必须被初始化，指针不必。