---
title: 析构函数
date: 2019-02-05 20:58:01
categories: C++语法详解
---
&emsp;&emsp;一个良好的`class`需要有资源回收的机制，而这一操作便落在了析构函数的头上，析构函数来负责类内资源的释放：

``` cpp
class myclass {
public:
    myclass() {
        cout << "构造函数" << endl;
    }

    ~myclass() {
        cout << "析构函数" << endl;
    }
};
​
int main() {
    myclass mc;
    return 0;
}
```

执行结果：

``` cpp
构造函数
析构函数
```

对象在声明的时候，就调用了类的构造函数。在函数结束之前，也自动调用了类的析构函数。

``` cpp
int main() {
    myclass *mc;
    return 0;
}
```

该代码运行无结果。如果直接声明一个对象指针(只是声明而已)，则不自动调用构造函数和析构函数。

``` cpp
int main() {
    myclass *mc;
    mc = new myclass();
    return 0;
}
```

执行结果：

``` cpp
构造函数
```

给对象指针分配一个内存空间，自然就会调用构造函数。但为什么不自动调用析构函数？说明`C++`内部缺少这一机制。`C++`毫不客气地对你说：`你提醒我给一个对象分配空间，那也得麻烦你提醒我将它释放(delete)`。于是便有如下代码：

``` cpp
int main() {
    myclass *mc;
    mc = new myclass();
    delete mc;
    return 0;
}
```

执行结果：

``` cpp
构造函数
析构函数
```

&emsp;&emsp;如果函数的参数是类，则应当使用`常引用`，因为它跟析构函数有很大关系：

``` cpp
void function ( myclass mc ) {
}
​
int main() {
    myclass mc;
    function ( mc );
    return 0;
}
```

执行结果：

``` cpp
构造函数
析构函数
析构函数
```

`function`函数内对`myclass`类的对象`mc`作了一次复制(`浅复制`而已)，也就是函数内的对象副本。调用函数时，如果选择传值调用，那么会有参数副本被复制到函数的栈区。这里调用了`myclass`类默认的`copy`构造函数，而不是其构造函数。但无论是哪种方法，都使用了构造，需要花费一些时间；遇上析构函数那是必然的。
&emsp;&emsp;解决方法就是：宁以`pass-by-reference-to-const`替换`pass-by-value`：

``` cpp
void function ( const myclass &mc ) {
}
​
int main() {
    myclass mc;
    function ( mc );
    return 0;
}
```

执行结果：

``` cpp
构造函数
析构函数
```

---

&emsp;&emsp;首先要明确一点，系统只会自动释放栈内空间，而堆内空间需要用户自己维护。在`C++`中，除了`new`来的空间存放在堆内，其他均存放在栈中。
&emsp;&emsp;当单纯地创建对象的时候，对象存放在栈中，在函数快要结束时，系统会自动调用析构函数，释放掉栈空间。但如果创建了指向`new`来的空间的指针时，并且没有显式地释放掉该堆空间，那么系统是不会自动调用析构函数。

``` cpp
#include <iostream>
​
using namespace std;
​
class CBase {
public:
    CBase ( int num ) {
        this->num = num;
        cout << num << "号Base类构造函数运行！" << endl;
    };

    ~CBase() {
        cout << num << "号Base类析构函数运行！" << endl;
    };

private:
    int num;
};
​
int main() {
    CBase bobj ( 1 ); /* 析构函数会自动调用 */
    CBase *bptr = new CBase ( 2 );
    // delete bptr; /* 如果没有这句，系统不会自动运行2号的析构函数 */
}
```

此处`delete`释放的是指针指向的堆空间，然后系统会调用析构函数。

---

### 析构函数和动态内存的申请

&emsp;&emsp;示例代码如下：

``` cpp
#include <iostream>
#include <cstring>
​
using namespace std;
​
class Person {
private:
    char *pName;

public:
    Person ( char *pN = "noName" ) { /* 构造函数 */
        std::cout << "constructing : " << pN << endl;
        pName = new char[strlen ( pN ) + 1]; /* 分配动态内存空间给对象中的指针成员 */
​
        if ( pName ) {
            strcpy ( pName, pN );
        }
    }

    ~Person() { /* 析构函数 */
        std::cout << "destructing : " << pName << endl;
        delete[] pName;
    }
};
​
int main ( int argc, char **argv ) {
    Person p1 ( "Jack" );
    Person p2 ( "Sam" );
    Person p3;
    return 0;
}
```

执行结果：

``` cpp
constructing : Jack
constructing : Sam
constructing : noName
destructing : noName
destructing : Sam
destructing : Jack
```

程序先创建`p1`对象，再创建`p2`对象，最后创建`p3`对象，`p3`因为没有初始化，所以就给了默认的`noName`名称。对象执行析构函数的顺序与构造函数的顺序相反，先是`p3`被析构，接着`p2`被析构，最后`p1`被析构。