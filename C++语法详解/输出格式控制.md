---
title: 输出格式控制
categories: C++语法详解
date: 2019-02-07 18:41:42
---
&emsp;&emsp;在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式。但有时希望数据按指定的格式输出，例如要求以十六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的：一是使用控制符的方法；二是使用流对象的有关成员函数。<!--more-->
&emsp;&emsp;1. 使用控制符控制输出格式：

控制符                         | 作用
-------------------------------|-----
`dec`                          | 设置整数的基数为`10`
`hex`                          | 设置整数的基数为`16`
`oct`                          | 设置整数的基数为`8`
`setbase(n)`                   | 设置整数的基数为`n`(`n`只能是`16`、`10`、`8`之一)
`setfill(c)`                   | 设置填充字符`c`，`c`可以是字符常量或字符变量
`setprecision(n)`              | 设置实数的精度为`n`位。在以一般十进制小数形式输出时，`n`代表有效数字。在以`fixed`(固定小数位数)形式和`scientific`(指数)形式输出时，`n`为小数位数
`setw(n)`                      | 设置字段宽度为`n`位
`setiosflags(ios::fixed)`      | 设置浮点数以固定的小数位数显示
`setiosflags(ios::scientific)` | 设置浮点数以科学计数法(即指数形式)显示
`setiosflags(ios::left)`       | 输出数据左对齐
`setiosflags(ios::right)`      | 输出数据右对齐
`setiosflags(ios::shipws)`     | 忽略前导的空格
`setiosflags(ios::uppercase)`  | 在以科学计数法输出`E`和十六进制输出字母`X`时，以大写表示
`setiosflags(ios::showpos)`    | 输出正数时，给出`+`号
`resetiosflags()`              | 终止已设置的输出格式状态，在括号中应指定内容

代码如下：

``` cpp
#include <iostream>
#include <iomanip> /* 不要忘记包含此头文件 */

using namespace std;

int main() {
    int a;
    cout << "input a:";
    cin >> a;
    /* 以十进制形式输出整数 */
    cout << "dec:" << dec << a << endl;
    /* 以十六进制形式输出整数a */
    cout << "hex:" << hex << a << endl;
    /* 以八进制形式输出整数a */
    cout << "oct:" << setbase ( 8 ) << a << endl;
    char *pt = "China"; /* pt指向字符串"China" */
    cout << setw ( 10 ) << pt << endl; /* 指定域宽为10，输出字符串 */
    /* 指定域宽为10，输出字符串，空白处以"*"填充 */
    cout << setfill ( '*' ) << setw ( 10 ) << pt << endl;
    double pi = 22.0 / 7.0; /* 计算pi值 */
    /* 按指数形式输出，8位小数 */
    cout << setiosflags ( ios::scientific ) << setprecision ( 8 );
    cout << "pi=" << pi << endl; /* 输出pi值 */
    /* 改为位小数 */
    cout << "pi=" << setprecision ( 4 ) << pi << endl;
    /* 改为小数形式输出 */
    cout << "pi=" << setiosflags ( ios::fixed ) << pi << endl;
    return 0;
}
```

执行结果：

``` cpp
input a:34        (输入a的值)
dec:34            (十进制形式)
hex:22            (十六进制形式)
oct:42            (八进制形式)
         China    (域宽为10)
*****China        (域宽为10，空白处以“*”填充)
pi=3.14285714e+00 (指数形式输出，8位小数)
pi=3.1429e+00     (指数形式输出，4位小数)
pi=3.143          (小数形式输出，精度仍为4)
```

&emsp;&emsp;2. 用流对象的成员函数控制输出格式：除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数见下表。

流成员函数      | 与之作用相同的控制符 | 作用
---------------|--------------------|-----
`precision(n)` | `setprecision(n)`  | 设置实数的精度为`n`位
`width(n)`     | `setw(n)`          | 设置字段宽度为`n`位
`fill(c)`      | `setfill(c)`       | 设置填充宇符`c`
`setf()`       | `setiosflags()`    | 设置输出格式状态，括号中应给出格式状态，内容与控制符`setiosflags`括号中的内容相同，如下表所示
`unsetf()`     | `resetioflags()`   | 终止已设置的输出格式状态，在括号中应指定内容

&emsp;&emsp;流成员函数`setf`和控制符`setiosflags`括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类`ios`中被定义为枚举值，因此在引用这些格式标志时要在前面加上类名`ios`和域运算符`::`，格式标志见下表：

格式标志          | 作用
------------------|------
`ios::left`       | 输出数据在本域宽范围内向左对齐
`ios::right`      | 输出数据在本域宽范围内向右对齐
`ios::internal`   | 数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充
`ios::dec`        | 设置整数的基数为`10`
`ios::oct`        | 设置整数的基数为`8`
`ios::hex`        | 设置整数的基数为`16`
`ios::showbase`   | 强制输出整数的基数(八进制数以`0`打头，十六进制数以`0x`打头)
`ios::showpoint`  | 强制输出浮点数的小点和尾数`0`
`ios::uppercase`  | 在以科学记数法格式`E`和以十六进制输出字母时以大写表示
`ios::showpos`    | 对正数显示`+`号
`ios::scientific` | 浮点数以科学记数法格式输出
`ios::fixed`      | 浮点数以定点格式(小数形式)输出
`ios::unitbuf`    | 每次输出之后刷新所有的流
`ios::stdio`      | 每次输出之后清除`stdout`、`stderr`

代码如下：

``` cpp
#include <iostream>

using namespace std;

int main() {
    int a = 21;
    cout.setf ( ios::showbase );     /* 显示基数符号(0x或0) */
    cout << "dec:" << a << endl;     /* 默认以十进制形式输出a */
    cout.unsetf ( ios::dec );        /* 终止十进制的格式设置 */
    cout.setf ( ios::hex );          /* 设置以十六进制输出的状态 */
    cout << "hex:" << a << endl;     /* 以十六进制形式输出a */
    cout.unsetf ( ios::hex );        /* 终止十六进制的格式设置 */
    cout.setf ( ios::oct );          /* 设置以八进制输出的状态 */
    cout << "oct:" << a << endl;     /* 以八进制形式输出a */
    cout.unsetf ( ios::oct );        /* 终止八进制的格式设置 */
    char *pt = "China";              /* pt指向字符串"China" */
    cout.width ( 10 );               /* 指定域宽为10 */
    cout << pt << endl;              /* 输出字符串 */
    cout.width ( 10 );               /* 指定域宽为10 */
    cout.fill ( '*' );               /* 指定空白处以“*”填充 */
    cout << pt << endl;              /* 输出字符串 */
    double pi = 22.0 / 7.0;          /* 输出pi值 */
    cout.setf ( ios::scientific );   /* 指定用科学记数法输出 */
    cout << "pi=";                   /* 输出"pi=" */
    cout.width ( 14 );               /* 指定域宽为14 */
    cout << pi << endl;              /* 输出pi值 */
    cout.unsetf ( ios::scientific ); /* 终止科学记数法状态 */
    cout.setf ( ios::fixed );        /* 指定用定点形式输出 */
    cout.width ( 12 );               /* 指定域宽为12 */
    cout.setf ( ios::showpos );      /* 正数输出“+”号 */
    cout.setf ( ios::internal );     /* 数符出现在左侧 */
    cout.precision ( 6 );            /* 保留位小数 */
    cout << pi << endl;              /* 输出pi，注意数符“+”的位置 */
    return 0;
}
```

执行结果：

``` cpp
dec:21            (十进制形式)
hex:0x15          (十六进制形式，以“0x”开头)
oct:025           (八进制形式，以“0”开头)
         China    (域宽为10)
*****China        (域宽为10，空白处以“*”填充)
pi=**3.142857e+00 (指数形式输出，域宽14，默认6位小数)
+***3.142857      (小数形式输出，精度为6，最左侧输出数符“+”)
```

&emsp;&emsp;对程序的几点说明：
&emsp;&emsp;1. 成员函数`width(n)`和控制符`setw(n)`只对其后的第一个输出项有效：

``` cpp
cout.width ( 6 );
cout << 20 << 3.14 << endl;
```

在输出第一个输出项`20`时，域宽为`6`，因此在`20`前面有`4`个空格；在输出`3.14`时，`width(6)`已不起作用，此时按系统默认的域宽输出(按数据实际长度输出)。如果要求在输出数据时都按指定的同一域宽`n`输出，不能只调用一次`width(n)`，而必须在输出每一项前都调用一次`width(n)`。
&emsp;&emsp;2. 上表中的输出格式状态分为5组，每一组中同时只能选用一种(例如`dec`、`hex`和`oct`中只能选一，它们是互相排斥的)。在用成员函数`setf`和控制符`setiosflags`设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数`unsetf`(对应于成员函数`self`)或`resetiosflags`(对应于控制符`setiosflags`)，先终止原来设置的状态，然后再设置其他状态。程序在开始虽然没有用成员函数`self`和控制符`setiosflags`设置用`dec`输出格式状态，但系统默认指定为`dec`，因此要改变为`hex`或`oct`，应当先用`unsetf`函数终止原来的设置。
&emsp;&emsp;3. 用`setf`函数设置格式状态时，可以包含两个或多个格式标志。由于这些格式标志在`ios`类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符`|`组合多个格式标志：

``` cpp
cout.setf ( ios::internal | ios::showpos ); /* 包含两个状态标志，用“|”组合 */
```

&emsp;&emsp;4. 可以看到，对输出格式的控制，既可以用控制符，也可以用`cout`流的有关成员函数，二者的作用是相同的。控制符是在头文件`iomanip`中定义的，因此用控制符时，必须包含`iomanip`头文件。`cout`流的成员函数是在头文件`iostream`中定义的，因此只需包含头文件`iostream`，不必包含`iomanip`。许多程序人员感到使用控制符方便简单，可以在一个`cout`输出语句中连续使用多种控制符。

---

&emsp;&emsp;`I/O`的书写格式：`I/0`流是输入或输出的一系列字节，当程序需要在屏幕上显示输出时，可以使用插入操作符`<<`向`cout`输出流中插入字符：

``` cpp
cout << "This is a program.\n";
```

当程序需要执行键盘输入时，可以使用抽取操作符`>>`从`cin`输人流中抽取字符。

``` cpp
int myAge;
cin >> myAge;
```

不管把什么基本数据类型的名字或值传给流，它都能懂。例下面的函数输出字符串和整数：

``` cpp
#include "iostream.h"

void main() {
    cout << "My name is Jone\n";
    cout << "the ID is";
    cout << 2;
    cout << endl;
}
```

上面的输出也可以在同一行中串连，下面的输出语句与上例输出同样内容：

``` cpp
cout << "My name is Jone\n" << "the ID is" << 2 << endl;
```

也可以分在几行，提高可读性：

``` cpp
cout << "My name is Jone n" /* 行末无分号 */
     << "the ID is"
     << 2
     << endl;
```

&emsp;&emsp;使用控制符：流的默认格式输出有时不能满足特殊要求：

``` cpp
double average = 9.400067;
cout << average << endl;
```

希望显示的是`9.40`，即保留两位小数，可是却显示了`9.40007`，默认显示`6`位有效位。用控制符(`manipulators`)可以对`I/O`流的格式进行控制。控制符是在头文件`iomanip.h`中定义的对象，可以直接将控制符插入流中。常用控制符如下表所列：

控制符                         | 描述
-------------------------------|-----
`dec`                          | 设置基数为`10`
`hex`                          | 设置基数为`16`
`oct`                          | 设置基数为`8`
`setfill(c)`                   | 设置填充字符为`c`
`setdivcision(n)`              | 设置显示小数精度为`n`位
`setw(n)`                      | 设置域宽为`n`个字符
`setiosflags(ios::fixed)`      | 固定的浮点显示
`setiosflags(ios::scientific)` | 指数表示
`setiosflags(ios::left)`       | 左对齐
`setiosflags(ios::right)`      | 右对齐
`setiosflags(ios::skipws)`     | 忽略前导空白
`setiosflags(ios::uppercase)`  | `16`进制数大写输出
`setiosflags(ios::lowercase)`  | `16`进制数小写输出

使用控制符时，要在程序的头上加头文件`iomanip.h`。
&emsp;&emsp;控制浮点数值显示：使用`setdivcision(n)`可控制输出流显示浮点数的数字个数，`C++`默认的流输出数值有效位是`6`。如果`setdivcision(n)`与`setiosflags(ios::fixed)`合用，可以控制小数点右边的数字个数。`setiosflags(ios::fixed)`是用定点方式表示实数。如果与`setiosnags(ios::scientific)`合用，可以控制指数表示法的小数位数。`setiosflags(ios::scientific)`是用指数方式表示实数。下面的代码分别用浮点、定点和指数方式表示一个实数：

``` cpp
#include <iostream.h>
#include <iomanip.h>

void main ( void ) {
    double amount = 22.0 / 7;
    cout << amount << endl;
    cout << setdivcision ( 0 ) << amount << endl
         << setdivcision ( 1 ) << amount << endl
         << setdivcision ( 2 ) << amount << endl
         << setdivcision ( 3 ) << amount << endl
         << setdivcision ( 4 ) << amount << endl;
    cout << setiosflags ( ios::fixed );
    cout << setdivcision ( 8 ) << amount << endl;
    cout << setiosflags ( ios::scientific )
         << amount << endl;
    cout << setdivcision ( 6 ); /* 重新设置成默认设置 */
}
```

运行结果为：

``` cpp
3.14286
3
3
3.1
3.14
3.143
3.14285714
3.14285714e+00
```

该程序在`32`位机器上运行通过。
&emsp;&emsp;在用浮点表示的输出中，`setdivcision(n)`表示有效位数。第`1`行输出数值之前没有设置有效位数，所以用流的有效位数默认设置值`6`；第`2`个输出设置了有效位数`0`，而`C++`最小的有效位数为`1`，所以作为有效位数设置为`1`来看待；第`3`至`6`行输出按设置的有效位数输出。第`7`行输出是与`setiosflags(ios::fixed)`合用，所以`setdivcision(8)`设置的是小数点后面的位数，而非全部数字个数。在用指数形式输出时，`setdivcision(n)`表示小数位数，第`8`行输出用`setiosflags(ios::scientific)`来表示指数表示的输出形式，其有效位数沿用上次的设置值`8`。小数位数截短显示时，进行`4`舍`5`入处理。
&emsp;&emsp;设置值的输出宽度：除了使用空格来强行控制输出间隔外，还可以用`setw(n)`控制符。如果一个值需要比`setw(n)`确定的字符数更多的字符，则该值将使用它所需要的所有字符：

``` cpp
float amount = 3.14159;
cout << setw ( 4 ) << amount << endl;
```

其运行结果为`3.14159`。它并不按`4`位宽度，而是按实际宽度输出。如果一个值的字符数比`setw(n)`确定的字符个数更少，则在数字字符前显示空白。不同于其他控制符，`setw(n)`仅仅影响下一个数值输出，换句话说，使用`setw`设置的间隔方式并不保留其效力：

``` cpp
cout << setw ( 8 ) << 10 << 20 << endl;
```

运行结果为`-------1020`，运行结果中的下横线表示空格，整数`20`并没有按宽度`8`输出。`setw`的默认值为宽度`0`，即`setw(0)`，意思是按输出数值的表示宽度输出，所以`20`就紧挨`10`了。若要每个数值都有宽度`8`，则每个值都要设置：

``` cpp
cout << setw ( 8 ) << 10 << setw ( 8 ) << 20 << endl;
```

&emsp;&emsp;输出`8`进制和`16`进制数：`3`个常用的控制符是`hex`、`oct`和`dec`，它们分别对应`16`进制、`8`进制和`10`进制数的显示。这`3`个控制符在`iostream.h`头文件中定义。

``` cpp
#include <iostream.h>

void main() {
    int number = 1001;
    cout << "Decimal:" << dec << number << endl
         << "Hexadecimal:" << hex << number << endl
         << "Octal:" << oct << number << endl;
}
```

执行结果：

``` cpp
Decimal：1001
Hexadecimal：3e9
Octal：1751
```

`1001`是一个`10`进制数，不能把它理解成`16`进制或`8`进制数，因为它不是以`0x`或`0`开头。但在输出时，流根据控制符进行过滤，使其按一定的进制来显示。
&emsp;&emsp;用头文件`iomanip.h`中的`setiosflags(ios::uppercase)`可以控制`16`进制数大写输出。例如，上例中增加一个头文件，对`16`进制数进行大写控制：

``` cpp
#include <iostream.h>
#include <iomanip.h>

cout << "Hexadecimal:" << hex
     << setiosftags ( ios::uppercase )
     << number << endl;
```

便能得到`16`进制数的大写表示，即`Hexadecimal：3E9`。
&emsp;&emsp;设置填充字符：`setw`可以用来确定显示的宽度。默认时，流使用空格符来保证字符间的正确间隔。用`setfill`控制符可以确定一个非空格的别的字符。`Setfill`在头文件`iomanip.h`中定义。

``` cpp
#include <iostream.h>
#include <iomanip.h>

void main() {
    cout << setfill ( '*' )
         << setw ( 2 ) << 21 << endl
         << setw ( 3 ) << 21 << endl
         << setw ( 4 ) << 21 << endl;
    cout << setfill ( ' ' ); /* 恢复默认设置 */
}
```

执行结果：

``` cpp
21
*21
**21
```

&emsp;&emsp;左右对齐输出：默认情况下，`I/O`流左对齐显示的内容。使用头文件`iomanip.h`中的`setiosflags(ios::left)`和`(ios::right)`标志，可以控制输出对齐：

``` cpp
#include <iostream.h>
#include <iomanip.h>

void main() {
    cout << setiosflags ( ios::right )
         << setw ( 5 ) << 1
         << setw ( 5 ) << 2
         << setw ( 5 ) << 3 << endl;
    cout << setiosflags ( ios::left )
         << setw ( 5 ) << 1
         << setw ( 5 ) << 2
         << setw ( 5 ) << 3 << endl;
}
```

执行结果：

``` cpp
-----1-----2-----3
1-----2-----3-----
```

&emsp;&emsp;强制显示小数点和符号：当程序输出下面的代码时：

``` cpp
cout << 10.0 / 5 << endl;
```

默认的`I/0`流会简单地显示`2`，而非`2.0`，因为除法的结果是精确的。当需要显示小数点时，可以用`iso::showpoint`标志：

``` cpp
#include <iostream.h>
#include <iomanip.h>

void main() {
    cout << 10.0 / 5 << endl;
    cout << setiosflags ( ios::showpoint )
         << 10.0 / 5 << endl;
}
```

执行结果：

``` cpp
2
2.00000
```

默认情况下，`I/O`流仅在负数之前显示值的符号，根据程序的用途，有时也需要在正数之前加上正号，可以用`ios::showpos`标志。

``` cpp
#include <iostream.h>
#include <iomanip.h>

void main() {
    cout << 10 << " " << -20 << endl;
    cout << setiosflags ( ios::showpos )
         << 10 << " " << -20 << endl;
}
```

执行结果：

``` cpp
10 -20
+10 -20
```