---
title: 异常处理
categories: C++语法详解
abbrlink: 28877bf
date: 2019-02-06 11:02:39
---
&emsp;&emsp;异常是程序在执行期间产生的问题。`C++`异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式，`C++`异常处理涉及到三个关键字：`try`、`catch`、`throw`。<!--more-->

- `throw`：当问题出现时，程序会抛出一个异常，这是通过使用`throw`关键字来完成的。
- `catch`：在您想要处理问题的地方，通过异常处理程序捕获异常，`catch`关键字用于捕获异常。
- `try`：`try`块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个`catch`块。

&emsp;&emsp;如果有一个块抛出一个异常，捕获异常的方法会使用`try`和`catch`关键字。`try`块中放置可能抛出异常的代码，其中的代码被称为保护代码。

``` cpp
try {
    /* 保护代码 */
} catch ( ExceptionName e1 ) {
    /* catch块1 */
} catch ( ExceptionName e2 ) {
    /* catch块2 */
} catch ( ExceptionName eN ) {
    /* catch块3 */
}
```

如果`try`块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个`catch`语句，用于捕获不同类型的异常。
&emsp;&emsp;您可以使用`throw`语句在代码块中的任何地方抛出异常。`throw`语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。以下是尝试除以零时抛出异常的实例：

``` cpp
double division ( int a, int b ) {
    if ( b == 0 ) {
        throw "Division by zero condition!";
    }
​
    return ( a / b );
}
```

`catch`块跟在`try`块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由`catch`关键字后的括号内的异常声明决定的。

``` cpp
try {
    /* 保护代码 */
} catch ( ExceptionName e ) {
    /* 处理ExceptionName异常的代码 */
}
```

上面的代码会捕获一个类型为`ExceptionName`的异常。如果您想让`catch`块能够处理`try`块抛出的任何类型的异常，则必须在异常声明的括号内使用`...`：

``` cpp
try {
    /* 保护代码 */
} catch ( ... ) {
    /* 能处理任何异常的代码 */
}
```

抛出一个除以零的异常，并在`catch`块中捕获该异常：

``` cpp
#include <iostream>
​
using namespace std;
​
double division ( int a, int b ) {
    if ( b == 0 ) {
        throw "Division by zero condition!";
    }
​
    return ( a / b );
}
​
int main () {
    int x = 50;
    int y = 0;
    double z = 0;
​
    try {
        z = division ( x, y );
        cout << z << endl;
    } catch ( const char *msg ) {
        cerr << msg << endl;
    }
​
    return 0;
}
```

由于我们抛出了一个类型为`const char *`的异常，因此当捕获该异常时，我们必须在`catch`块中使用`const char *`。执行结果：

``` cpp
Division by zero condition!
```

---

&emsp;&emsp;代码如下：

``` cpp
#include <iostream>
​
using namespace std;
​
int main() {
    try {
        throw 100;
        throw "error";
    } catch ( char *str ) {
        cout << str << endl;
    } catch ( int i ) {
        cout << i << endl;
    }
​
    return 0;
}
```

程序输出为`100`。也可以自己定义异常类来进行处理：

``` cpp
#include <iostream>
#include <exception>
​
using namespace std;
​
/* 可以自己定义Exception */
class myexception: public exception {
    virtual const char *what() const throw() {
        return "My exception happened";
    }
} myex;
​
int main () {
    try {
        if ( true ) { /* 如果真，则抛出异常 */
            throw myex;
        }
    } catch ( exception &e ) {
        cout << e.what() << endl;
    }
​
    return 0;
}
```

继承`exception`覆盖`what`函数。执行结果：

``` cpp
My exception happened
```

可以使用枚举来定义出现的错误：

``` cpp
#include <iostream>
​
using namespace std;
​
enum index {underflow, overflow};
​
int array_index ( int *A, int n, int index );
​
int main() {
    int *A = new int[10];
​
    for ( int i = 0; i < 10; i++ ) {
        A[i] = i;
    }
​
    try {
        cout << array_index ( A, 10, 5 ) << endl;
        cout << array_index ( A, 10, -1 ) << endl;
        cout << array_index ( A, 10, 15 ) << endl;
    } catch ( index e ) {
        if ( e == underflow ) {
            cout << "index underflow!" << endl;
            exit ( -1 );
        }
​
        if ( e == overflow ) {
            cout << "index overflow!" << endl;
            exit ( -1 );
        }
    }
​
    return 0;
}
​
int array_index ( int *A, int n, int index ) {
    if ( index < 0 ) {
        throw underflow;
    }
​
    if ( index > n - 1 ) {
        throw overflow;
    }
​
    return A[index];
}
```

本例展示了一个数组越界的异常捕获程序。`array_index`函数用于返回数组`index`下标的数值，如果出现异常则将其抛出。程序定义了一个全局的枚举类型变量`index`，并且定义了两个值，分别为`underflow`和`overflow`，这两个值作为抛出异常的返回值。当在主函数要求输出越界的数组值时，调用`array_index`函数，一旦有预定异常抛出，则通过`try`捕获并根据`catch`语句针对异常情况作出处理。
&emsp;&emsp;如果`new`或`new[]`不能成功分配所请求的，将会抛出一个`bad_alloc`异常，而不是返回`NULL`。在使用`new`或`new[]`操作符分配动态内存，可以通过如下方式检测并捕获存储空间分配失败的异常：

``` cpp
int *p;
​
try {
    p = new int[10];
} catch ( bad_alloc ) {
    cerr << "allocate failure!" << endl;
    exit ( -1 );
}
```

&emsp;&emsp;**补充说明**：在公有派生的情况下，基类可以引用派生类的对象，程序中第一次抛掷派生类异常时，被基类的`catch`捕获。因此要注意，在安排`catch`语句顺序时，要将基类的处理放在派生类的后面。