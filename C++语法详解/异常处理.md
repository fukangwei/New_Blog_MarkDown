---
title: 异常处理
categories: C++语法详解
date: 2019-02-06 11:02:39
---
### 捕获异常

&emsp;&emsp;异常是程序在执行期间产生的问题。`C++`异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
&emsp;&emsp;异常提供了一种转移程序控制权的方式，`C++`的异常处理使用如下关键字：<!--more-->

- `throw`：当问题出现时，程序会抛出一个异常，这是通过使用`throw`关键字来完成的。
- `catch`：在想要处理问题的地方，通过异常处理程序捕获异常，`catch`关键字用于捕获异常。
- `try`：`try`块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个`catch`块。

&emsp;&emsp;如果有一个块抛出一个异常，捕获异常的方法会使用`try`和`catch`关键字。`try`块中放置可能抛出异常的代码，其中的代码被称为`保护代码`。

``` cpp
try {
    /* 保护代码 */
} catch ( ExceptionName e1 ) {
    /* catch块1 */
} catch ( ExceptionName e2 ) {
    /* catch块2 */
} catch ( ExceptionName eN ) {
    /* catch块3 */
}
```

如果`try`块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个`catch`语句，用于捕获不同类型的异常。
&emsp;&emsp;可以使用`throw`语句在代码块中的任何地方抛出异常。`throw`语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。以下是尝试除以零时抛出异常的实例：

``` cpp
double division ( int a, int b ) {
    if ( b == 0 ) {
        throw "Division by zero condition!";
    }

    return ( a / b );
}
```

`catch`块跟在`try`块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由`catch`关键字后的括号内的异常声明决定的。

``` cpp
try {
    /* 保护代码 */
} catch ( ExceptionName e ) {
    /* 处理ExceptionName异常的代码 */
}
```

上面的代码会捕获一个类型为`ExceptionName`的异常。如果您想让`catch`块能够处理`try`块抛出的任何类型的异常，则必须在异常声明的括号内使用`...`：

``` cpp
try {
    /* 保护代码 */
} catch ( ... ) {
    /* 能处理任何异常的代码 */
}
```

抛出一个除以零的异常，并在`catch`块中捕获该异常：

``` cpp
#include <iostream>

using namespace std;

double division ( int a, int b ) {
    if ( b == 0 ) {
        throw "Division by zero condition!";
    }

    return ( a / b );
}

int main () {
    int x = 50;
    int y = 0;
    double z = 0;

    try {
        z = division ( x, y );
        cout << z << endl;
    } catch ( const char *msg ) {
        cerr << msg << endl;
    }

    return 0;
}
```

由于我们抛出了一个类型为`const char *`的异常，因此当捕获该异常时，我们必须在`catch`块中使用`const char *`。执行结果：

``` cpp
Division by zero condition!
```

---

&emsp;&emsp;代码如下：

``` cpp
#include <iostream>

using namespace std;

int main() {
    try {
        throw 100;
        throw "error";
    } catch ( char *str ) {
        cout << str << endl;
    } catch ( int i ) {
        cout << i << endl;
    }

    return 0;
}
```

程序输出为`100`。

### bad_alloc

&emsp;&emsp;如果`new`或`new[]`不能成功分配所请求的，将会抛出一个`std::bad_alloc`异常，而不是返回`NULL`。在使用`new`或`new[]`操作符分配动态内存，可以通过如下方式检测并捕获存储空间分配失败的异常：

``` cpp
int *p;

try {
    p = new int[10];
} catch ( bad_alloc ) {
    cerr << "allocate failure!" << endl;
    exit ( -1 );
}
```