---
title: 虚函数
categories: C++语法详解
abbrlink: dcffa0c0
date: 2019-02-07 16:14:37
---
&emsp;&emsp;接口描述了类的行为和功能，而不需要完成类的特定实现。`C++`接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。`virtual`在`C++`中的意思是`可以在今后由这个类所派生的类里重新定义`。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用`= 0`来指定的，派生类必须将该函数重新实现：<!--more-->

``` cpp
class Box {
public:
    virtual double getVolume() = 0; /* 纯虚函数 */

private:
    double length;  /* 长度 */
    double breadth; /* 宽度 */
    double height;  /* 高度 */
};
```

设计抽象类(通常称为`ABC`)目的是为了给其他类提供一个可以继承的适当的基类。抽象类不能用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。因此，如果一个`ABC`的子类需要被实例化，则必须实现每个虚函数，这也意味着`C++`支持使用`ABC`声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。
&emsp;&emsp;请看下面的实例，基类`Shape`提供了一个接口`getArea`，在两个派生类`Rectangle`和`Triangle`中分别实现了`getArea`：

``` cpp
#include <iostream>
​
using namespace std;
​
class Shape { /* 基类 */
public:
    virtual int getArea() = 0; /* 提供接口框架的纯虚函数 */

    void setWidth ( int w ) {
        width = w;
    }

    void setHeight ( int h ) {
        height = h;
    }
​
protected:
    int width;
    int height;
};
​
class Rectangle: public Shape { /* 派生类 */
public:
    int getArea() {
        return ( width * height );
    }
};
​
class Triangle: public Shape {
public:
    int getArea() {
        return ( width * height ) / 2;
    }
};
​
int main ( void ) {
    Rectangle Rect;
    Triangle  Tri;

    Rect.setWidth ( 5 );
    Rect.setHeight ( 7 );
    cout << "Total Rectangle area: " << Rect.getArea() << endl; /* 输出对象的面积 */

    Tri.setWidth ( 5 );
    Tri.setHeight ( 7 );
    cout << "Total Triangle area: " << Tri.getArea() << endl; /* 输出对象的面积 */
    return 0;
}
```

---

&emsp;&emsp;虚函数是`C++`用于实现多态(`polymorphism`)的机制，核心理念就是通过基类访问派生类定义的函数。假设有下面的类层次：

``` cpp
class A {
public:
    virtual void foo() {
        cout << "A::foo() is called" << endl;
    }
};
​
class B: public A {
public:
    virtual void foo() {
        cout << "B::foo() is called" << endl;
    }
};
```

那么在使用的时候，我们可以这样写：

``` cpp
A *a = new B();
a->foo(); /* a虽然是指向A的指针，但是被调用的函数foo却是B的 */
```

虚函数的`虚`就在于所谓的`推迟联编`或者`动态联编`上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为`虚`函数。
&emsp;&emsp;虚函数只能借助于指针或者引用来达到多态的效果，如果是下面这样的代码，虽然是虚函数，但它不是多态的：

``` cpp
class A {
public:
    virtual void foo();
};
​
class B: public A {
    virtual void foo();
};
​
void bar() {
    A a;
    a.foo(); /* “A::foo”被调用 */
}
```

&emsp;&emsp;在了解虚函数的含义之后，再考虑多态就很容易了。仍然针对上面的类层次，但是使用的方法变得稍微复杂了：

``` cpp
void bar ( A *a ) {
    a->foo();
}
```

因为`foo`是个虚函数，所以在`bar`这个函数中，只根据这段代码无从确定被调用的是`A::foo`还是`B::foo`，但是可以肯定地说，如果`a`指向的是`A`类的实例，则`A::foo`被调用；如果`a`指向的是`B`类的实例，则`B::foo`被调用。这种同一代码可以产生不同效果的特点，被称为`多态`。
&emsp;&emsp;在面向对象的编程中，首先会针对数据进行抽象(确定基类)和继承(确定派生类)，构成类层次。这个类层次的使用者在使用它们时，如果仍然在需要基类的时候写针对基类的代码，在需要派生类的时候写针对派生类的代码，就等于类层次完全暴露在使用者面前。如果这个类层次有任何的改变(增加了新类)，都需要使用者`知道`(针对新类写代码)。这样就增加了类层次与其使用者之间的耦合，有人把这种情况列为程序中的`bad smell`之一，而多态可以使程序员脱离这种窘境。再回头看看上面的例子，`bar`函数作为`A-B`这个类层次的使用者，它并不知道这个类层次中有多少个类，每个类都叫什么，但是一样可以很好地工作。当有一个`C`类从`A`类派生出来后，`bar`函数也不需要`知道`(修改)。这完全归功于多态，编译器针对虚函数产生了可以在运行时刻确定被调用函数的代码。
&emsp;&emsp;编译器是如何针对虚函数产生可以在运行时刻确定被调用函数的代码呢？也就是说，虚函数实际上是如何被编译器处理的呢？`Lippman`在`深度探索C++对象模型`中的不同章节讲到了几种方式，这里把`标准的`方式简单介绍一下。
&emsp;&emsp;我所说的`标准`方式，也就是所谓的`VTABLE`机制。编译器发现一个类中有被声明为`virtual`的函数，就会为其产生一个虚函数表，也就是`VTABLE`。`VTABLE`实际上是一个函数指针的数组，每个虚函数占用这个数组的一个`slot`。一个类只有一个`VTABLE`，不管它有多少个实例。派生类有自己的`VTABLE`，但是派生类的`VTABLE`与基类的`VTABLE`有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置上。在创建类实例的时候，编译器还会在每个实例的内存布局中增加一个`vptr`字段，该字段指向本类的`VTABLE`。通过这些手段，编译器在看到一个虚函数调用的时候，就会将这个调用改写。针对上面的例子：

``` cpp
void bar ( A *a ) {
    a->foo();
}
```

会被改写为：

``` cpp
void bar ( A *a ) {
    ( a->vptr[1] ) ();
}
```

因为派生类和基类的`foo`函数具有相同的`VTABLE`索引，而它们的`vptr`又指向不同的`VTABLE`，因此通过这样的方法可以在运行时刻决定调用哪个`foo`函数。
&emsp;&emsp;虚函数总是在派生类中被改写，这种改写被称为`override`。`override`是指派生类重写基类的虚函数，就像我们前面`B`类中重写了`A`类中的`foo`函数。重写的函数必须有一致的参数表和返回值(`C++`标准允许返回值不同的情况，但是很少编译器支持这个`feature`)。`overload`是指编写一个与已有函数同名但是参数表不同的函数，例如一个函数即可以接受整型数作为参数，也可以接受浮点数作为参数。
&emsp;&emsp;虚函数的标志是`virtual`关键字。考虑下面的类层次：

``` cpp
class A {
public:
    virtual void foo();
};
​
class B: public A {
public:
    void foo(); /* 没有virtual关键字 */
};
​
class C: public B { /* 从B继承，不是从A继承 */
public:
    void foo(); /* 也没有virtual关键字 */
};
```

这种情况下，`B::foo`是虚函数，`C::foo`也同样是虚函数。因此可以说，基类声明的虚函数在派生类中也是虚函数，即使不再使用`virtual`关键字。
&emsp;&emsp;如下声明表示一个函数为纯虚函数：

``` cpp
class A {
public:
    virtual void foo() = 0; /* “=0”标志一个虚函数为纯虚函数 */
};
```

纯虚函数的意思是：我是一个抽象类，不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的`接口`。它告诉使用者：我的派生类都会有这个函数。
&emsp;&emsp;析构函数也可以是虚的，甚至是纯虚的：

``` cpp
class A {
public:
    virtual ~A() = 0; /* 纯虚析构函数 */
};
```

当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。考虑下面的例子：

``` cpp
class A {
public:
    A() {
        ptra_ = new char[10];
    }

    ~A() {
        delete[] ptra_; /* 非虚析构函数 */
    }

private:
    char *ptra_;
};
​
class B: public A {
public:
    B() {
        ptrb_ = new char[20];
    }

    ~B() {
        delete[] ptrb_;
    }

private:
    char *ptrb_;
};
​
void foo() {
    A *a = new B;
    delete a;
}
```

在这个例子中，程序也许不会像你想象的那样运行，在执行`delete a`时，实际上只有`A::~A`被调用了，而`B`类的析构函数并没有被调用。如果将上面`A::~A`改为`virtual`类型，就可以保证`B::~B`也在`delete a`时被调用了，因此基类的析构函数都必须是`virtual`的。
&emsp;&emsp;纯虚的析构函数并没有什么作用，通常只有在希望将一个类变成抽象类(不能实例化的类)，而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。
&emsp;&emsp;对于`private`的虚函数，考虑下面的例子：

``` cpp
class A {
public:
    void foo() {
        bar();
    }

private:
    virtual void bar() {
        /* ... */
    }
};
​
class B: public A {
private:
    virtual void bar() {
        /* ... */
    }
};
```

虽然`bar`在`A`类中是`private`的，但是仍然可以出现在派生类中，并仍然可以与`public`或者`protected`的虚函数一样产生多态的效果。并不会因为它是`private`的，就发生`A::foo`不能访问`B::bar`的情况，也不会发生`B::bar`对`A::bar`的`override`不起作用的情况。这种写法的意思是：`A`告诉`B`，你最好`override`我的`bar`函数，但是你不要管它如何使用，也不要自己调用这个函数。
&emsp;&emsp;一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了。也就是说，不能在构造函数和析构函数中让自己`多态`：

``` cpp
class A {
public:
    A() {
        foo(); /* 在这里，无论如何都是A::foo被调用 */
    }

    ~A() {
        foo(); /* 同上 */
    }

    virtual void foo();
};
​
class B: public A {
public:
    virtual void foo();
};
​
void bar() {
    A *a = new B;
    delete a;
}
```

如果你希望`delete a`的时候，会导致`B::foo`被调用，那么你就错了。同样，在`new B`的时候，`A`的构造函数被调用，但是在`A`的构造函数中，被调用的是`A::foo`而不是`B::foo`。
&emsp;&emsp;在你设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。以设计模式中`Factory Method`模式为例，`Creator`的`factoryMethod`就是虚函数，派生类`override`这个函数后，产生不同的`Product`类，被产生的`Product`类被基类的`AnOperation`函数使用。基类的`AnOperation`函数针对`Product`类进行操作，当然`Product`类一定也有多态(虚函数)。
&emsp;&emsp;另外一个例子就是集合操作，假设你有一个以`A`类为基类的类层次，又用了一个`std::vector<A *>`来保存这个类层次中不同类的实例指针，那么你一定希望在对这个集合中的类进行操作的时候，不要把每个指针再`cast`回到它原来的类型(派生类)，而是希望对它们进行同样的操作，那么就应该将这个`一样的操作`声明为`virtual`。

&emsp;&emsp;**补充说明**：
&emsp;&emsp;1. 若派生类中没有重定义基类的虚函数，当调用这种派生类对象的虚函数时，则调用其基类的虚函数。
&emsp;&emsp;2. 构造函数不能是虚的。
&emsp;&emsp;3. 虚函数和普通的成员函数相比，调用时的执行速度要慢一些。
&emsp;&emsp;4. 含有虚函数的类一定是抽象类，不能产生对象，但可以定义抽象类类型的指针和引用。
&emsp;&emsp;5. 如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。这句话也可以反过来说：`如果你发现基类提供了虚函数，那么你最好override它`。