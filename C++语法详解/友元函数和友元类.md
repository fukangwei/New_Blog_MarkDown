---
title: 友元函数和友元类
categories: C++语法详解
abbrlink: a233feb3
date: 2019-03-10 18:08:08
---
&emsp;&emsp;类的友元函数是定义在类外部，但有权访问类的所有私有(`private`)成员和保护(`protected`)成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。
&emsp;&emsp;友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。
&emsp;&emsp;如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字`friend`：

``` cpp
class Box {
private:
    double width;

public:
    friend void printWidth ( Box box );
    void setWidth ( double wid );
};
```

声明类`ClassTwo`的所有成员函数作为类`ClassOne`的友元，需要在类`ClassOne`的定义中放置如下声明：

``` cpp
friend class ClassTwo;
```

请看下面的程序：

``` cpp
#include <iostream>
​
using namespace std;
​
class Box {
private:
    double width;

public:
    friend void printWidth ( Box box );
    void setWidth ( double wid );
};
​
void Box::setWidth ( double wid ) { /* 成员函数定义 */
    width = wid;
}
​
void printWidth ( Box box ) { /* 请注意，printWidth不是任何类的成员函数 */
    /* 因为printWidth是Box的友元，它可以直接访问该类的任何成员 */
    cout << "Width of box : " << box.width << endl;
}
​
int main() {
    Box box;
    box.setWidth ( 10.0 ); /* 使用成员函数设置宽度 */
    printWidth ( box ); /* 使用友元函数输出宽度 */
    return 0;
}
```

执行结果：

``` cpp
Width of box : 10
```

---

### C++中的友元函数和友元类

&emsp;&emsp;友元函数是指某些虽然不是类成员却能够访问类的所有成员的函数。类授予它的友元特别的访问权。通常情况下，同一个开发者会出于技术和非技术的原因，控制类的友元和成员函数(则当你想更新你的类时，还要征得其它部分的拥有者的同意)。
&emsp;&emsp;为什么会有友元函数？结合着类的特性和类中一般成员函数，我们可以这样理解：类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将数据成员都定义为公有的，这又破坏了隐藏的特性。另外，在某些情况下，特别是在对某些成员函数多次调用时，由于参数传递、类型检查和安全性检查等都需要时间开销，影响了程序的运行效率。
&emsp;&emsp;为了解决上述问题，提出一种使用友元的方案。友元是一种定义在类外部的普通函数，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字`friend`。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

``` cpp
#include <iostream>
#include <cmath>
​
using namespace std;
​
class Point {
private:
    double x, y;

public:
    Point ( double xx, double yy ) {
        x = xx;
        y = yy;
    }
​
    void Getxy();
​
    friend double Distance ( Point &a, Point &b );
};
​
void Point::Getxy() {
    cout << "(" << x << "," << y << ")" << endl;
}
​
double Distance ( Point &a, Point &b ) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt ( dx * dx + dy * dy );
}
​
int main() {
    Point p1 ( 3.0, 4.0 ), p2 ( 6.0, 8.0 );
    p1.Getxy();
    p2.Getxy();
    double d = Distance ( p1, p2 );
    cout << "Distance is " << d << endl;
    return 0;
}
```

### 全局函数作友元

&emsp;&emsp;要使用全局函数作友元函数，也就是说全局函数中要使用当前这个类的实例，因此全局函数的定义必须放在这个类的后面，否则编译时这个类的实例就成了未定义的数据类型了。

``` cpp
#include <iostream>
#include <string>
​
using namespace std;
​
class ca {
private:
    string id;
    void setId ( string s ) {
        id = s;
    }

protected:
    string name;
    void setName ( string s ) {
        name = s;
    }

public:
    void print() {
        cout << id << "  " << name << "  " << endl;
    }

    friend void fun ( ca &a ); /* 声明全局函数作友元，允许它访问私有保护成员 */
};
​
class derive : public ca { /* ca类的派生类 */
};
​
void fun ( ca &a ) {     /* 作友元的函数要定义在那个类的后面 */
    a.id = "987";        /* 这是ca类的私有成员              */
    a.setName ( "xyz" ); /* 这是ca类的保护成员              */
}
​
int main() {
    ca a;
    // a.fun(...); /* 友元函数不是当前类的成员函数，所以这句编译出错 */
    fun ( a );
    a.print();
    derive d;
    fun ( d ); /* 作参数时，类型转换为ca类 */
    d.print();
    return 0;
}
```

### 其它类的成员函数作友元

&emsp;&emsp;别的类的成员函数作友元，也就是说这`2`个类相互调用，这样无论谁定义在前在后，编译时都有冲突。解决方法如下：

``` cpp
#include <iostream>
#include <string>
​
using namespace std;
​
class ca; /* 事先声明ca类，确保cb类的定义不出错 */
​
class cb { /* 在ca类之前定义cb类，确保在ca类里声明cb的test作友元时不出错 */
public:
    void test ( ca &a ); /* 由于ca类事先声明，这里不出错 */
};
​
class ca {
private:
    string id;
    void setId ( string s ) {
        id = s;
    }

protected:
    string name;
    void setName ( string s ) {
        name = s;
    }

public:
    void print() {
        cout << id << "  " << name << "  " << endl;
    }
​
    friend void cb::test ( ca &a ); /* 声明cb类的test函数作友元，允许它访问私有保护成员 */
};
​
void cb::test ( ca &a ) { /* 作友元的成员函数的实现必须在ca类的后面，否则ca类的成员就未定义了 */
    a.id = "123";         /* 这是ca类的私有成员                                           */
    a.setName ( "abc" );  /* 这是ca类的保护成员                                           */
}
​
int main() {
    ca a;
    cb b;
    b.test ( a );
    a.print();
    return 0;
}
```

### 运算符重载中使用友元

&emsp;&emsp;操作符重载由类的函数改为全局函数，也就是说这个运算符不是这个类的，而是正常使用的操作符。改为友元方式其实并没有必要，纯粹是为了讲解`友元`的用法。并不是所有操作符都可以定义成`友元`，例如`=`就不能用`友元`方式重载。

``` cpp
#include <iostream>
#include <string>
​
using namespace std;
​
class rect {
private:
    int x1, y1, x2, y2; /* 矩形坐标 */

public:
    rect() {
        x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    }
​
    rect ( int m1, int n1, int m2, int n2 ) {
        x1 = m1, y1 = n1, x2 = m2, y2 = n2;
    }
​
    void print() {
        cout << "  x1=" << x1;
        cout << "  y1=" << y1;
        cout << "  x2=" << x2;
        cout << "  y2=" << y2;
        cout << endl;
    }

    // rect operator++(); /* 这是类的运算符的重载 */
    friend rect operator++ ( rect &ob ); /* 这是全局运算符的重载 */
};
​
rect operator++ ( rect &ob ) {
    ob.x1++, ob.y1++;
    ob.x2++, ob.y2++;
    return ob;
}
​
int main() {
    rect r ( 12, 20, 50, 40 );
    r.print();
    rect obj;
    obj = ++r;
    obj.print();
    return 0;
}
```

### 友元类

&emsp;&emsp;除了前面讲过的函数以外，友元还可以是类，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数。使用友元类时注意：

- 友元关系不能被继承，因为友元函数不是类的成员函数。
- 友元关系是单向的，不具有交换性。若类`B`是类`A`的友元，类`A`不一定是类`B`的友元，要看在类中是否有相应的声明(简单地说，我把你当朋友，你可以拿我的东西)。
- 友元关系不具有传递性。若类`B`是类`A`的友元，类`C`是`B`的友元，类`C`不一定是类`A`的友元，同样要看类中是否有相应的声明。

``` cpp
#include <iostream>
​
using namespace std;
​
class CObj {
public:
    CObj() : mX ( 0 ), mY ( 0 ) {}
    friend class CFriend;
​
private:
    void PrintData() const {
        cout << "mX = " << mX << endl
             << "mY = " << mY << endl;
    }

    int mX;
    int mY;
};
​
class CFriend {
public:
    CFriend ( int x, int y ) {
        mObj.mX = x; /* 直接调用类CObj的私有数据成员 */
        mObj.mY = y;
    }

    void ShowData() const {
        mObj.PrintData(); /* 直接调用类CObj的私有成员函数 */
    }
​
private:
    CObj mObj;
};
​
int main() {
    CFriend one ( 3, 4 );
    one.ShowData();
    return 0;
}
```