---
title: 希尔排序
categories: 数据结构
date: 2019-02-09 00:50:40
---
### 基本原理

&emsp;&emsp;希尔排序的基本原理：<!--more-->

1. 取一个整数`gap`作为间隔，而`gap`要小于数组的元素数量。
2. 将全部元素分为`gap`个子序列，所有距离为`gap`的元素放在同一个子序列中。
3. 在每一个子序列中分别施行插入排序，然后缩小间隔`gap`，例如取`gap = gap / 2`。
4. 重复上述的子序列划分和排序工作，直到最后取`gap = 1`，将所有记录放在同一个序列中排序为止。

### 排序实例

&emsp;&emsp;以`n = 10`的数组`[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]`为例，第一次取`gap = 10 / 2 = 5`：

| 49   | 38   | 65   | 97   | 26   | 13   | 27   | 49   | 55   | 4    |
|------|------|------|------|------|------|------|------|------|------|
| `1A` |      |      |      |      | `1B` |      |      |      |      |
|      | `2A` |      |      |      |      | `2B` |      |      |      |
|      |      | `3A` |      |      |      |      | `3B` |      |      |
|      |      |      | `4A` |      |      |      |      | `4B` |      |
|      |      |      |      | `5A` |      |      |      |      | `5B` |

- `[1A, 1B]`、`[2A, 2B]`等是分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素。
- 一共分成了`5`组，即`(49, 13)`、`(38, 27)`、`(65, 49)`、`(97, 55)`和`(26, 4)`。
- 每次对同一组的数据进行插入排序，于是就变成了`(13, 49)`、`(27, 38)`、`(49, 65)`、`(55, 97)`和`(4, 26)`。

&emsp;&emsp;第二次`gap = 5/2 = 2`，排序后如下：

| 13   | 27   | 49   | 55   | 4    | 49   | 38   | 65   | 97   | 26   |
|------|------|------|------|------|------|------|------|------|------|
| `1A` |      | `1B` |      | `1C` |      | `1D` |      | `1E` |      |
|      | `2A` |      | `2B` |      | `2C` |      | `2D` |      | `2E` |

&emsp;&emsp;第三次`gap = 2/2 = 1`，排序后如下：

4    | 26   | 13   | 27   | 38   | 49   | 49   | 55   | 97   | 65
-----|------|------|------|------|------|------|------|------|----
`1A` | `1B` | `1C` | `1D` | `1E` | `1F` | `1G` | `1H` | `1I` | `1J`

&emsp;&emsp;第四次`gap = 1/2 = 0`，排序后如下：

<table>
    <tr>
        <th>4</th><th>13</th><th>26</th><th>27</th><th>38</th>
        <th>49</th><th>49</th><th>55</th><th>65</th><th>97</th>
    </tr>
</table>

### 代码实例

&emsp;&emsp;代码如下：

``` cpp
void shell_sort ( int v[], int n ) {
    int gap, i, j, temp;

    for ( gap = n / 2; gap > 0; gap /= 2 ) {
        // 将a[i]插入到a[i - gap]、a[i - 2 * gap]、a[i - 3 * gap]...之中
        for ( i = gap; i < n; i++ ) {
            for ( j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap ) {
                temp = v[j];
                v[j] = v[j + gap];
                v[j + gap] = temp;
            }
        }
    }
}
```