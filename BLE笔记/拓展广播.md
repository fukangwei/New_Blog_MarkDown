---
title: 拓展广播
date: 2020-11-21 12:43:53
categories: BLE笔记
---
&emsp;&emsp;根据不同`BLE`的版本，`ADV`分为`2`类：

1. `Legacy ADV`：`BLE 4.2`版本的`ADV`。
2. `Extend ADV`：`BLE 5.x`版本的`ADV`。

&emsp;&emsp;`Legcay ADV`有如下几种：

- `ADV_IND`
- `ADV_DIRECT_IND`
- `ADV_NONCONN_IND`
- `ADV_SCAN_IND`

&emsp;&emsp;`Extended ADV`有如下几种：

- `ADV_EXT_IND`
- `AUX_ADV_IND`
- `AUX_SCAN_RSP`
- `AUX_SYNC_IND`
- `AUX_CHAIN_IND`
- `AUX_CONNECT_RSP`

&emsp;&emsp;在`BLE 4.2`时代，所有的`ADV`都在`37`、`38`、`39`上进行发送和接收，这里我们称`Channel 37`、`38`、`39`为`Primary Advertising Physical Channel`。
&emsp;&emsp;到了`BLE 5.0`时代，`ADV`也可以在其他频道上搞事情了。`BLE 5.0`对`ADV`进行了扩展，新来的`ADV`叫做`Extended ADV`，也就是`扩展广播`。扩展广播就是在`Primary Advertising Physical Channel`上发一个叫做`EXT_ADV`的数据报文，该数据报文携带了一些信息，信息中包含了下一个和它关联的数据报文所在地(`Secondary Advertising Physical Channel`)，这个所在地就不是`Channel 37`、`38`、`39`了，而是其他的`37`个通道中的一个。具体是哪个，由这个`EXT_ADV`的包来决定。
&emsp;&emsp;`Extended ADV`中有一个`Common Extended Advertising Payload Format`：

- `Extended Header Length`：代表了`Extended Header`域的长度。
- `AdvMode`：代表了不同`ADV`的模式，代表是否可连接，是否可扫描以及它们的组合。
- `Extended Header`：`Extended Header`域是变长的。
- `AdvData`：携带的数据，其长度是动态的。长度计算方法为：用`PDU Header`的`Length`减去这个`Extended Header Length`，再减去`1`个字节(`Extended Header Length + AdvMode = 8 bits`)。

### AdvMode

&emsp;&emsp;`AdvMode`使用`2`个`bits`，表示这个包是否能被连接，是否能被扫描：

### Extended Header

&emsp;&emsp;这个域是一个可变长度，它的结构稍微复杂：

&emsp;&emsp;`Extended Header Flags`：由`1`个`Byte`构成，它代表了后面的域是否存在：

&emsp;&emsp;如果这个`Extended Header Flags`为`00000011b`，则代表后面的`AdvA`和`TargetA`是有货的，其他几个域不包含在这个`Payload`里面。
&emsp;&emsp;`AdvA`和`TargetA`：都是`48 bit`，代表本机地址和对端地址。
&emsp;&emsp;`AdvDataInfo`：分为`Advertising Data ID`和`Advertising Set ID`：

1. `Advertising Data ID`：广播可能发送不同的数据(例如周期性广播，并不是每次都发送的同样的数据)，为了让对端知道当前的数据是什么(或者说是第几个数据报文)，就要对数据进行编号。
2. `Advertising Set ID`：一个蓝牙只有一个地址，但是可以开启多个广播，本机肯定知道当前使用的是哪个广播(用`Handle`区分)，但是其他空中的设备不知道。所以，`Advertising Set ID`就用于其他设备区分同一个设备发送的多个广播。

### AuxPtr

&emsp;&emsp;`Extended Adv`的行为是，首先在`Primary Advertising Physical Channel`上发送一个`Extended ADV`，然后在`Secondary Advertising Physical Channel`上发送一些具体的信息。所以，`AuxPtr`就是描述在`Secondary Advertising Physical Channel`上的信息。

&emsp;&emsp;例如，对方在`Scanning`的时候，在`Primary Advertising Physical Channel`上收到了`Extended ADV`。为了更好地知道你的情况，它需要继续在`Secondary Advertising Physical Channel`上继续收包。既然是`Secondary Advertising Physical Channel`，咱们就需要在`Primary`上写给别人：你要在哪个频道上去准备收包(`Channel Index`)，什么时候去收包(`Offset Unites and AUX Offset`)，在哪个`PHY`上去收(`AUX PHY`)。

- `Channel Index`：描述了需要在哪个`Secondary Advertising Physical Channel`上去接收`AUX`包。
- `Offset Units`：`Offset`的单位。
- `AUX Offset`：收包的时间点是距离现在时间多少个`Offset Units`。
- `AUX PHY`：使用哪个`PHY`来收包(`1M/2M/Coded`)。
- `CA`：代表了`Clock`的精度。

### ADV_EXT_IND

&emsp;&emsp;它发送在`Primary Advertising Physical Channel`上，目的是为了引出后续的`Secondary Advertising Physical Channel`包。绝大多数的扩展广播包，都是以`ADV_EXT_IND(Primary) + AUX_ADV_IND(Secondary)`的形式来组织的，扫描端想要知道这个扩展广播的含义，必须要收到`ADV_EXT_IND`后，接着去收`AUX_ADV_IND`，然后完成数据解析，才知道这个到底是个啥。
&emsp;&emsp;广播分为可连接、可扫描、不可连接、不可扫描的组合，以及是否带数据。依据这种分类方式，`ADV_EXT_IND`的组成分为了几类：

&emsp;&emsp;如果你想发送这个包，则需要：

1. `AdvMode`设置成为`01b`。
2. `ADV_EXT_IND`包中不含`AdvA`。
3. `ADV_EXT_IND`包中不含`TargetA`。
4. `ADV_EXT_IND`包中一定要有`ADI`。
5. `ADV_EXT_IND`包中一定要有`AuxPtr`。
6. `ADV_EXT_IND`包中不含`SyncInfo`。
7. `ADV_EXT_IND`包中可选含`Tx Power`。
8. `ADV_EXT_IND`包中不含`ACDA`。
9. `ADV_EXT_IND`包中不含`AdvData`。

&emsp;&emsp;可能有人会问：你发送一个可连接的扩展广播，怎么都不带地址信息？这是因为这种可连接的包的组织形式是：

``` cpp
ADV_EXT_IND(Primary) + AUX_ADV_IND(Secondary)
```

&emsp;&emsp;在`ADV_EXT_IND`中强制加上了`AuxPtr`，也就是一定要有`AUX_ADV_IND`，地址信息被放在这个里面了。

### AUX_ADV_IND

&emsp;&emsp;`AUX_ADV_IND`和`ADV_EXT_IND`是好基友，一起组成了扩展广播：

&emsp;&emsp;这里`Connectable Undirected`的`AdvA`是强制的(`M`)，而`TargetA`是没有的，因为它是不指向性的包，所以没有`TargetA`；如果是指向性的扩展广播，`TargetA`就是强制的(`M`)。

### AUX_SYNC_IND

&emsp;&emsp;这个数据报文专门用于周期性广播。当建立起周期性广播后，会按照周期发送这个报文：

&emsp;&emsp;注意一下，周期性广播报文只能是非连接，不能扫描。也就是说，对端只需要安安静静地听我发的东西就好了，别给我回复，因为我也不会回复你。

### AUX_CHAIN_IND

&emsp;&emsp;`ADV`数据最多发送`251`个`Bytes`，如果我想发更多的数据怎么办？可以使用`AUX_CHAIN_IND`，你可以把它理解为链表。
&emsp;&emsp;`AUX_CHAIN_IND`的上级`PDU`是`AUX_ADV_IND`、`AUX_SYNC_IND`、`AUX_SCAN_RSP`或另一个`AUX_CHAIN_IND PDU`。如果存在`ADI`字段，则其值应与上级`PDU`中的字段相同。注意，`ADI`字段可用于检测冲突。

&emsp;&emsp;`AUX_ADV_IND`的某些类型和`AUX_SYNC_IND`类型的`AuxPtr`为可选的(`O`)，意思是后面还可以跟数据报文。`AuxPtr`像指针一样，指向了下一个关联的包。
&emsp;&emsp;也就是说，一个`ADV_EXT_IND`跟一个`AUX_ADV_IND`，如果再有数据发送，那么后面跟的就是`AUX_CHAIN_IND`了。如果跟一个`AUX_CHAIN_IND`不够怎么办，当然是这个`AUX_CHAIN_IND`后面继续跟`AUX_CHAIN_IND`(`AuxPtr`可选)。当然也不可能无限跟`AUX_CHAIN_IND`，这个和具体的`BLE`硬件资源是紧密联系的。

### AUX_SCAN_REQ

&emsp;&emsp;`AUX_SCAN_REQ`是专门针对`Extended Advertising`的交互，包体的内容和`SCAN_REQ`一样，只不过针对对象不一样。`Scanner`收到`Extended Advertising的Primary Advertising Physical Channel`上的`EXT_ADV_IND`，然后再到`Secondary Advertising Physical Channel`上收到了`AUX`包，最后回复了`AUX_SCAN_REQ`。

### AUX_CONNECT_RSP

&emsp;&emsp;与`Legacy`不一样的是，`Extended`在上建立连接上，还多了一个步骤。
&emsp;&emsp;`Legacy`是`Initiating`端直接发送`CONNECT_IND`，然后其进入`Connection`状态，并不知道对端是否收到了这个`CONNECT_IND`。
&emsp;&emsp;`Extended`在发送`AUX_CONNECT_REQ`后，还等待`Advertising`端回复一个`AUX_CONNECT_RSP`包，双方握手完成，正式进入`Connection`状态：