---
title: 安全机制之白名单
date: 2020-12-05 15:36:04
categories: BLE笔记
---
### 安全机制之LL Privacy

&emsp;&emsp;试想一下如下这种场景：<!--more-->
&emsp;&emsp;`A`设备表示只信任`B`、`C`、`D`设备，因此就把它们的地址加入到了自己的白名单中，表示只愿意和它们沟通。与此同时，`E`设备对它们的沟通非常感兴趣，但`A`对自己不信任啊，怎么办？`E`想出一个坏主意：把自己的地址伪装成`B`、`C`、`D`中任意一个就行了(这个还是很容易办到的，随便扫描一下就得到它们的地址了)。
&emsp;&emsp;那么问题来了，怎么摆脱`E`设备的偷听呢？不着急，我们还有手段 -- 链路层的`Privacy`(隐私)机制。

### LL Privacy机制

&emsp;&emsp;总结来说，`LL Privacy`机制是白名单(`White List`)机制的进阶和加强，它在白名单的基础上，将设备地址转变成`Private Addresses`地址，以降低E设备窃取设备地址进而进行伪装的概率。
&emsp;&emsp;`LL Privacy`机制的本质是：通过`Resolvable Private Addresses`，将数据包的设备地址加密，让`E`设备无法窃得，从而增加其伪装的难度。

### Resolving List

&emsp;&emsp;和白名单机制上的`White List`类似，如果设备需要使用`LL Privacy`机制，则需要在`Controller`端保存一个`Resolving List`，其思路为：

&emsp;&emsp;1. `BLE`设备配置并使能白名单机制，把那些受信任设备的地址(这里为`Identity Address`)加入到自己的白名单中，并采用合适的白名单策略。
&emsp;&emsp;2. 如果设备使用`LL Privacy`策略，则需要将自己(`Local`)和对方(`Peer`)的地址和加密`Key`保存在一个称作`Resolving List`的列表中。
&emsp;&emsp;3. `Resolving List`的每一个条目都保存了一对`BLE`设备的`Key/Address`信息：

- `Local IRK`：本地的`IRK`，用于将本地设备的`Identity Address`转换为`Resolvable Private Address`。可以为`0`，表示本地地址直接使用`Identity Address`。
- `Peer IRK`：对端的`IRK`，用于将对端设备的`Resolvable Private Address`解析回`Identity Address`。可以为`0`，表示对端地址是`Identity Address`。
- `Peer Device Identity Address`、`Address Type`：对端设备的`Identity Address`以及类型，用于和解析回的`Identity Address`进行比对。

&emsp;&emsp;4. `Resolving List`是`Host`通过`HCI Comand`提供给`Controller`的，`Controller`的`LL`负责如下事项：

&emsp;&emsp;发送数据包时：如果有`AdvA`需要填充，则判断`Resolving List`是否有`非0`的`Local IRK`。如果有，则使用`Local IRK`将`Identity Address`加密为`Resolvable Private Address`，填充到`AdvA`中。否则，直接填充`Identity Address`。
&emsp;&emsp;同理，如果有`InitA`需要填充，则判断`Resolving List`是否有匹配的、`非0`的`Peer IRK`。如果有，则使用`Peer IRK`将对端的`Identity Address`加密为`Resolvable Private Address`，填充到`InitA`中。否则，直接填充`Identity Address`。
&emsp;&emsp;接收数据包时：如果数据包中的`AdvA`或者`InitA`为普通的`Identity Address`，则直接做后续的处理；如果它们为`Resolvable Private Address`，则会遍历`Resolving List`中所有的`IRK | Identity Address`条目，使用`IRK`解出`Identity Address`，和条目中的进行对比。如果匹配，则地址解析成功，可以做进一步处理；如果不匹配，并使能了白名单和`LL Privacy`策略，则会直接丢弃。
&emsp;&emsp;5. `Controller`和`Host`之间所有的事件交互(除了`Resolving List`操作之外)，均使用`Identity Address`。也就是说，设备地址的加密、解密、比对等操作，都是在`Controller`中完成的，对上层实体(`HCI`之上)是透明的。

### 使用场景说明

#### 设备处于广播状态(Advertising State)

&emsp;&emsp;处于广播状态的`BLE`设备，根据需要可发送`ADV_IND`、`ADV_DIRECT_IND`、`ADV_NONCONN_IND`和`ADV_SCAN_IND`这`4`种类型的广播包，也就是说有`4`种不同的广播状态，它们的`LL privacy`策略有稍微的不同。

&emsp;&emsp;1) `ADV_IND`
&emsp;&emsp;设备(`Advertiser`)发送`ADV_IND`时，其`PDU`(`Connectable Undirected Advertising Event PDU`)有一个`AdvA`字段，该字段的填充策略为(由`Controller`的`LL`执行)：检查`Resolving List`，查看是否存在`非0`的`Local IRK`条目。如果有，则使用`Local IRK`将自己的`Identity Address`加密为`Resolvable Private Addresses`，并填充到`AdvA`中。否则，直接使用`Identity Address`。
&emsp;&emsp;`Advertiser`收到连接请求时，请求者的地址会包含在`PDU`的`InitA`中。该字段的解析策略为(由`Controller`的`Link Layer`执行)：如果`InitA`是`Resolvable Private Addresses`，且当前使能了地址解析功能，`Link Layer`会遍历`Resolving List`中所有的`Peer IRK | Peer Device Identity Address | Address Type`条目，使用`Peer IRK`解析出`Identity Address`后，和`Peer Device Identity Address`做比对。如果匹配，则解析成功，再基于具体的白名单策略，决定是否接受连接。如果解析不成功，则无法建立连接。如果`InitA`不是`Resolvable Private Addresses`，则走正常的连接过程。
&emsp;&emsp;`Advertiser`收到扫描请求时，对`ScanA`的处理策略和`InitA`类似。

&emsp;&emsp;2) `ADV_DIRECT_IND`
&emsp;&emsp;设备(`Advertiser`)发送`ADV_DIRECT_IND`时，其`PDU`(`Connectable Directed Advertising Event PDU`)包含`AdvA`和`InitA`两个地址，它们的填充策略如下(由`Controller`的`LL`执行)：
&emsp;&emsp;检查`Resolving List`，查看是否存在`非0`的`Local IRK`条目。如果有，则使用`Local IRK`将自己的`Identity Address`加密为`Resolvable Private Addresses`，并填充到`AdvA`中。否则，直接使用`Identity Address`。
&emsp;&emsp;检查`Resolving List`，查看是否存在`非0`、和`InitA`的`Identity Address`匹配的`Peer IRK`条目。如果有，则使用`Peer IRK`将`InitA`的`Identity Address`加密为`Resolvable Private Addresses`，并填充到`InitA`中。否则，直接使用`Identity Address`。
&emsp;&emsp;`Advertiser`收到连接请求时，请求者的地址会包含在`PDU`的`InitA`中，该字段的解析策略和上面`ADV_IND`类似。

&emsp;&emsp;3) `ADV_NONCONN_IND & ADV_SCAN_IND`

&emsp;&emsp;这两个状态下，`AdvA`的填充策略和上面`1`和`2`一样。当`Advertiser`收到`Scan`请求时，对`ScanA`的处理策略和`(1)`中`InitA`类似。

#### 设备处于扫描状态(Scanning State)

&emsp;&emsp;处于`Scanning`状态的设备(`Scanner`)在接收到`Advertiser`发送的`Scannable`的广播包时，需要按照`Advertising State`中解析`InitA`的方法，解析广播包中的`AdvA`，并根据当前的白名单策略，进行过滤。
&emsp;&emsp;`Scanner`发送`Scan`请求时，需要指定`ScanA`和`AdvA`两个地址。其实`ScanA`的填充策略和`Advertising State`中的`AdvA`类似。而`AdvA`需要和接收到的广播包的`AdvA`完全一样，不能有改动。

#### 设备处于连接状态(Initiating State)

&emsp;&emsp;处于`Initiating`状态的设备(`Initiator`)在接收到`Advertising`发送的`Connectable`的广播包时，需要按照`Advertising State`中解析`InitA`的方法，解析广播包中的`AdvA`，并根据当前的白名单策略，进行过滤。
&emsp;&emsp;同理，`Initiator`发送连接请求时，需要指定`InitA`和`AdvA`两个地址。其实`InitA`的填充策略和`Advertising`中的`AdvA`类似。而`AdvA`需要和接收到的广播包的`AdvA`完全一样，不能有改动。
&emsp;&emsp;最后，`Initiator`在接收到`Advertising`发送的`Directed Connectable`广播包时，除了要解析`AdvA`，如果`InitA`是`Resolvable Private Addresses`，则需要使用`Local IRK`解析`InitA`。