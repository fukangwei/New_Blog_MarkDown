---
title: 设计一个不能被继承的类
date: 2018-12-16 12:36:15
categories: C++应用代码
---
&emsp;&emsp;使用友元、私有构造函数、虚继承等方式可以使一个类不能被继承：

``` cpp
#include <iostream>
​
using namespace std;
​
template <typename T> class Base {
    friend T;
  private:
    Base() {
        cout << "base" << endl;
    }
    ~Base() {}
};
​
/* 一定注意，必须是虚继承 */
class B: virtual public Base<B> {
  public:
    B() {
        cout << "B" << endl;
    }
};
​
class C: public B {
  public:
    C() {} /* 继承时报错，无法通过编译 */
};

int main() {
    B b; /* B类无法被继承 */
    // C c;
    return 0;
}
```

&emsp;&emsp;`B`类继承于`Base`类，`Base`类为虚基类。因为`B`类是`Base`类的友元类，所以它可以访问`Base`类的私有构造函数以及析构函数，编译运行时是正确的。
&emsp;&emsp;为什么必须是虚继承(`virtual`)呢？通常每个类只初始化自己的直接基类，但是在虚继承的时候这个情况发生了变化，可能导致虚基类被多次初始化，这显然不是我们想要的(例如，`AA`和`AB`都是类`A`的派生类，然后类`C`又继承自`AA`和`AB`，如果按照之前的方法会导致`C`里面`A`被初始化两次，也会存在两份数据)。为了解决重复初始化的问题，从虚基类继承的类在初始化时进行了特殊处理。在虚派生中，由最低层次的派生类的构造函数初始化虚基类。上面的例子就是由C的构造函数来控制如何进行虚基类的初始化。
&emsp;&emsp;为什么`B`类不能被继承？因为`B`是`Base`的友元，所以`B`对象可以正常创建，但由于`B`使用了虚继承，所以如果要创建`C`对象，那么`C`类的构造函数就要负责虚基类(`Base`)的构造。但是`Base`的构造函数是私有的，`C`没有访问的权限(友元关系不能被继承的)，所以`C`类在编译时就会报错，这样`B`类就不能被继承了。