---
title: 设计一个不能被继承的类
date: 2018-12-16 12:36:15
categories: C++应用代码
---

&emsp;&emsp;使用友元、私有构造函数、虚继承等方式可以使一个类不能被继承，代码如下所示：

``` cpp
#include <iostream>
​
using namespace std;
​
template <typename T> class Base {
    friend T;
  private:
    Base() {
        cout << "base" << endl;
    }
    ~Base() {}
};
​
/* 一定注意，必须是虚继承 */
class B: virtual public Base<B> {
  public:
    B() {
        cout << "B" << endl;
    }
};
​
class C: public B {
  public:
    C() {} /* 继承时报错，无法通过编译 */
};

int main() {
    B b; /* B类无法被继承 */
    //C c;
    return 0;
}
```

&emsp;&emsp;B类继承于Base类，Base类为虚基类。因为B类是Base类的友元类，所以它可以访问Base类的私有构造函数以及析构函数，编译运行时是正确的。
&emsp;&emsp;为什么必须是虚继承(virtual)呢？通常每个类只初始化自己的直接基类，但是在虚继承的时候这个情况发生了变化，可能导致虚基类被多次初始化，这显然不是我们想要的(例如，AA和AB都是类A的派生类，然后类C又继承自AA和AB，如果按照之前的方法会导致C里面A被初始化两次，也会存在两份数据)。为了解决重复初始化的问题，从虚基类继承的类在初始化时进行了特殊处理。在虚派生中，由最低层次的派生类的构造函数初始化虚基类。上面的例子就是由C的构造函数来控制如何进行虚基类的初始化。
&emsp;&emsp;为什么B类不能被继承？因为B是Base的友元，所以B对象可以正常创建，但由于B使用了虚继承，所以如果要创建C对象，那么C类的构造函数就要负责虚基类(Base)的构造。但是Base的构造函数是私有的，C没有访问的权限(友元关系不能被继承的)，所以C类在编译时就会报错，这样B类就不能被继承了。