---
title: CC2530基础实验
categories: CC2530和zigbee笔记
abbrlink: 11e569eb
date: 2019-02-05 16:27:20
---
### 流水灯实验

&emsp;&emsp;`CC2530`的`IO`口配置我们需要配置三个寄存器`P0SEL`、`P0DIR`、`P0INP`。`IO`口功能如下表：

寄存器        | 说明
--------------|----
`P0SEL(0XF3)` | 端口`0`功能选择寄存器(`P0.7`到`P0.0`功能选择)，`0`为通用`I/O`，`1`为外设功能
`P0INP(0x8F)` | 端口`0`输入模式寄存器(`P0.7`到`P0.0`的`I/O`输入模式)，`0`为上拉/下拉，`1`为三态
`P0(0X80)`    | `P0`可位寻址的`I/O`寄存器
`P0DIR(0XFD)` | `P0`口输入输出设置寄存器(`P0.7`到`P0.0`的`I/O`方向)，`0`为输入，`1`为输出

``` cpp
#include <ioCC2530.h>
​
#define LED1 P1_0 /* 定义P1.0口为LED1控制端 */
​
void delay ( unsigned int n ) { /* 延时函数 */
    unsigned int i, j;
​
    for ( j = 0; j < n; j++ )
        for ( i = 0; i < 200; i++ );
}
​
void IO_Init ( void ) {
    P1SEL &= ~0x01; /* P1.0作为普通IO口 */
    P1DIR |= 0x01; /* P1.0定义为输出 */
    P1INP |= 0X01; /* 打开三态 */
}
​
void main ( void ) {
    IO_Init();
​
    while ( 1 ) {
        LED1 = !LED1; /* LED1闪烁 */
        delay ( 500 );
    }
}
```

### 按键实验

&emsp;&emsp;代码如下：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0 /* LED1为P1.0口控制 */
#define KEY1 P0_0 /* KEY1为P0.0口控制 */
​
void Delayms ( uint );
void InitLed ( void );
void KeyInit();
uchar KeyScan();
​
void Delayms ( uint xms ) { /* 延时xms毫秒 */
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x01;
    P1INP |= 0X01;
    LED1 = 0;
}
​
void InitKey() {
    P0SEL &= ~0X01; /* 设置P0.0为普通IO口 */
    P0DIR &= ~0X01; /* 按键在P0.0口，设置为输入模式 */
    P0INP &= ~0x01;
}
​
uchar KeyScan ( void ) {
    if ( KEY1 == 0 ) {
        Delayms ( 10 );
​
        if ( KEY1 == 0 ) {
            while ( !KEY1 ); /* 松手检测 */
​
            return 1; /* 有按键按下 */
        }
    }
​
    return 0; /* 无按键按下 */
}
​
void main ( void ) {
    InitLed();
    InitKey();
​
    while ( 1 ) {
        if ( KeyScan() ) {
            LED1 = ~LED1;
        }
    }
}
```

### 外部中断

&emsp;&emsp;`CC2530`的外部中断我们需要配置三个寄存器`P0IEN`、`PICTL`、`P0IFG`、`IEN1`。

寄存器        | 说明
--------------|-----
`P0IEN(0xAB)` | 端口`0`中断屏蔽(端口`P0.7`到`P0.0`中断使能)，`0`为中断禁用，`1`为中断使能
`PICTL(0X8C)` | 中断触发控制寄存器。`Bit0`为`P0.0`到`P0.7`输入模式下的中断配置。该位为所有端口`0`的输入选择中断请求条件，`0`为输入的上升沿引起中断，`1`为输入的下降沿引起中断
`P0IFG(0x89)` | 端口`0`中断状态标志。`P0.0`至`P0.7`输入中断状态标志，当输入端口出现中断信号时，其相应的标志位将置`1`
`IEN1(0xB8)`  | 中断使能`1`。`Bit5`为端口`0`中断使能，`0`为中断禁止，`1`为中断使能
`P0IF`        | 端口`0`中断标志，为`0`表示无中断未决，为`1`表示有中断未决

中断未决指的是中断请求已经产生，但是还未得到`CPU`的处理。

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
#define KEY1 P0_0
​
void Delayms ( uint );
void InitLed ( void );
void KeyInit();
uchar KeyValue = 0;
​
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x01;
    P1INP |= 0X01;  
    LED1 = 0; /* LED1灯熄灭 */
}
​
void InitKey() {
    P0IEN |= 0X01; /* P0.0设置为中断方式 */
    PICTL |= 0x01; /* 下降沿触发 */
    IEN1 |= 0X20; /* 允许P0口中断 */
    P0IFG = 0x00; /* 初始化中断标志位 */
    EA = 1;
}
​
/* 中断处理函数 */
/* 格式：“#pragma vector = 中断向量”，紧接着是中断处理程序 */
#pragma vector = P0INT_VECTOR
__interrupt void P0_ISR ( void ) {
    Delayms ( 100 ); /* 去除抖动 */
    LED1 = ~LED1; /* 改变LED1状态 */
    P0IFG = 0; /* 清中断标志 */
    P0IF = 0; /* 清中断标志 */
}
​
void main ( void ) {
    InitLed();
    InitKey();
​
    while ( 1 );
}
```

### 定时器实验

&emsp;&emsp;对`CC2530`的`T1`定时器(`16`位)，我们需要配置三个寄存器`T1CTL`、`T1STAT`和`IRCON`：

- `T1CTL(0XE4)`：`Timer1`控制寄存器，`Bit3`和`Bit2`是定时器时钟分频倍数选择，`00`为不分频，`01`为`8`分频，`10`为`32`分频，`11`为`128`分频。`Bit1`和`Bit0`定时器模式选择：`00`为暂停，`01`为自动重装`0x0000`至`0xFFFF`，`10`为模模式，比较计数`0x0000`至`T1CC0`，`11`为正计数/倒计数，从`0x0000`到`T1CC0`反复计数并且从`T1CC0`倒计数到`0x0000`。
- `T1STAT(0XAF)`：`Timer1`状态寄存器，`Bit5`是`OVFIF`，即定时器溢出中断标志，在计数器达到计数终值时置位`1`；`Bit4`是定时器`1`通道`4`中断标志位；`Bit3`是定时器`1`通道`3`中断标志位；`Bit2`是定时器`1`通道`2`中断标志位；`Bit1`是定时器`1`通道`1`中断标志位；`Bit0`是定时器`1`通道`0`中断标志位。
- `IRCON(0xC0)`：中断标志`4`，`Bit1`为`T1IF`，它是定时器`1`中断标志。当定时器`1`中断发生时设为`1`，并且当`CPU`向量指向中断服务例程时清除，`0`为无中断未决，`1`为中断未决。

&emsp;&emsp;定时器`1`的查询工作方式如下：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
​
void InitLed ( void );
void InitT1();
​
void InitLed ( void ) {
    P1DIR |= 0x01;
    P1INP |= 0X01;
    LED1 = 0;
}
​
/* 定时器初始化 */
void InitT1() { /* 系统不配置工作时钟时默认是2分频，即16MHz */
    T1CTL = 0x0d; /* 128分频，自动重装0x0000至0xFFFF */
}
​
void main ( void ) {
    uchar count;
    InitLed();
    InitT1();
​
    while ( 1 ) {
        if ( ( IRCON & 0x02 ) != 0 ) { /* 当定时器1中断发生时 */
            IRCON = 0;
​
            if ( ++count >= 1 ) { /* 约1s周期性闪烁 */
                count = 0;
                LED1 = !LED1;
            }
        }
    }
}
```

系统在不配置工作频率时默认为`2`分频，即`32M/2 = 16M`，所以定时器每次溢出时`T = 1 / (16M / 128) * 65536 = 0.5s`，所以总时间`Ta = T * count = 0.5 * 1 = 0.5s`切换`1`次状态，所以看起来是`1s`闪烁`1`次。
&emsp;&emsp;定时器`3`的中断方式如下(定时器`3`是`8`位的)：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0  
​
void InitLed ( void );  
void InitT3();
​
uint count = 0; /* 用于定时器计数 */
​
void InitLed ( void ) {
    P1DIR |= 0x01;
    P1INP |= 0X01;
    LED1 = 0;
}
​
void InitT3() {
    T3CTL |= 0x08;  /* 开溢出中断 */
    T3IE = 1;       /* 开T3中断 */
    T3CTL |= 0XE0;  /* 128分频，128/16000000*N = 0.5s，N = 65200 */
    T3CTL &= ~0X03; /* 自动重装00 -> 0xff，65200/256 = 254(次) */
    T3CTL |= 0X10;  /* 启动 */
    EA = 1;         /* 开总中断 */
}
​
void main ( void ) {
    InitLed();
    InitT3();
​
    while ( 1 );
}
​
#pragma vector = T3_VECTOR /* 定时器T3 */
__interrupt void T3_ISR ( void ) {
    IRCON = 0x00; /* 清中断标志，也可由硬件自动完成 */
​
    if ( ++count > 254 ) { /* 254次中断后LED取反，闪烁一轮(约为0.5秒时间) */
        count = 0; /* 计数清零 */
        LED1 = ~LED1;
    }
}
```

### 串口发送和接收

&emsp;&emsp;查看`CC2530`的`datasheet`可知，`UART0`对应的外部设备`IO`引脚关系为：`P0_2`是`RX`，`P0_3`是`TX`；`UART1`对应的外部设备`IO`引脚关系为：`P0_5`是`RX`，`P0_4`是`TX`。在`CC2530`中，`USART0`和`USART1`是串行通信接口，它们能够分别运行于异步`USART`模式或者同步`SPI`模式。两个`USART`的功能是一样的，可以通过设置在单独的`IO`引脚上。`USART`模式的操作具有下列特点：

- `8`位或者`9`位负载数据。
- 奇校验、偶校验或者无奇偶校验。
- 配置起始位和停止位电平。
- 配置`LSB`或者`MSB`首先传送。
- 独立收发中断。
- 独立收发`DMA`触发。

&emsp;&emsp;`CC2530`配置串口的一般步骤：

1. 配置`IO`，使用外部设备功能。此处配置`P0_2`和`P0_3`用作串口`UART0`。
2. 配置相应串口的控制和状态寄存器。此处配置`UART0`的工作寄存器。
3. 配置串口工作的波特率。此处配置为波特率为`115200`。

本次实验串口相关的寄存器或者标志位有：`U0CSR`、`U0GCR`、`U0BAUD`、`U0DBUF`、`UTX0IF`。串口发送代码如下：

``` cpp
#include <ioCC2530.h>
#include <string.h>
​
#define uint  unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
#define LED2 P1_1
​
void Delay_ms ( uint );
void initUART ( void );
void UartSend_String ( char *Data, int len );
​
char Txdata[14]; /* 存放“HELLO WEBEE   ”共14个字符串 */
​
void Delay_ms ( uint n ) {
    uint i, j;
​
    for ( i = 0; i < n; i++ ) {
        for ( j = 0; j < 1774; j++ );
    }
}
​
void IO_Init() {
    P1DIR = 0x03;
    P1INP |= 0X03;
    LED1 = 0;
    LED2 = 0;
}
​
void InitUART ( void ) { /* 串口初始化函数 */
    PERCFG = 0x00; /* (外设控制寄存器)USART_0的I/O位置为备用位置0 */
    P0SEL = 0x0c; /* P0_2和P0_3用作串口(外部设备功能) */
    P2DIR &= ~0XC0; /* (端口2方向和端口0外设优先级控制)P0优先作为UART0 */
    U0CSR |= 0x80; /* 设置为UART模式 */
    U0GCR |= 8; /* 波特率指数值，BAUD_E和BAUD_M决定了UART波特率 */
    U0BAUD |= 59; /* 波特率设为9600 */
    UTX0IF = 0; /* UART0的TX中断标志初始设置为0 */
}
​
/* 串口发送字符串函数 */
void UartSend_String ( char *Data, int len ) {
    int j;
​
    for ( j = 0; j < len; j++ ) {
        U0DBUF = *Data++;
​
        while ( UTX0IF == 0 ); /* 当UTX0IF为1时表示发送完成 */
​
        UTX0IF = 0;
    }
}
​
void main ( void ) {
    CLKCONCMD &= ~0x40; /* 设置系统时钟源为32MHz晶振 */
​
    while ( CLKCONSTA & 0x40 ); /* 等待晶振稳定为32M */
​
    CLKCONCMD &= ~0x47; /* 设置系统主时钟频率为32MHz */
    IO_Init();
    InitUART();
    strcpy ( Txdata, "HELLO WEBEE   " ); /* 将发送内容copy到Txdata */
​
    while ( 1 ) {
        UartSend_String ( Txdata, sizeof ( "HELLO WEBEE   " ) ); /* 串口发送数据 */
        Delay_ms ( 500 );
        LED1 = !LED1;
    }
}
```

&emsp;&emsp;串口发送与接收的代码如下：

``` cpp
#include <ioCC2530.h>
#include <string.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
#define LED2 P1_1
​
void Delayms ( uint xms );
void InitLed ( void );
void InitUart();
void Uart_Send_String ( char *Data, int len );
​
char Rxdata[50];
uchar RXTXflag = 1;
char temp;
uchar  datanumber = 0;
​
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x03;
    LED1 = 0;
    LED2 = 0;
}
​
void InitUart() {
    CLKCONCMD &= ~0x40; /* 设置系统时钟源为32MHz晶振 */
​
    while ( CLKCONSTA & 0x40 ); /* 等待晶振稳定 */
​
    CLKCONCMD &= ~0x47; /* 设置系统主时钟频率为32MHz */

    PERCFG = 0x00;
    P0SEL = 0x0c; /* P0_2、P0_3用作串口，第二功能开启 */
    P2DIR &= ~0XC0;
    U0CSR |= 0x80;
    U0GCR |= 11;
    U0BAUD |= 216;
    UTX0IF = 0;
    U0CSR |= 0X40; /* 允许接收 */
    IEN0 |= 0x84; /* UART0接收中断开启 */
}
​
void Uart_Send_String ( char *Data, int len ) {
    int j;
​
    for ( j = 0; j < len; j++ ) {
        U0DBUF = *Data++;
​
        while ( UTX0IF == 0 );
​
        UTX0IF = 0;
    }
}
​
void main ( void ) {
    InitLed();
    InitUart();
​
    while ( 1 ) {
        if ( RXTXflag == 1 ) { /* 接收状态 */
            LED1 = 1; /* 接收状态指示 */
​
            if ( temp != 0 ) {
                /* “#”被定义为结束字符，最多能接收50个字符 */
                if ( ( temp != '#' ) && ( datanumber < 50 ) ) {
                    Rxdata[datanumber++] = temp;
                } else {
                    RXTXflag = 3; /* 进入发送状态 */
                    LED1 = 0; /* 关指示灯 */
                }
​
                temp  = 0;
            }
        }
​
        if ( RXTXflag == 3 ) { /* 发送状态 */
            LED2 = 1;
            U0CSR &= ~0x40; /* 禁止接收 */
            /* 发送已记录的字符串 */
            Uart_Send_String ( Rxdata, datanumber );
            U0CSR |= 0x40; /* 允许接收 */
            RXTXflag = 1; /* 恢复到接收状态 */
            datanumber = 0; /* 指针归0 */
            LED2 = 0; /* 关发送指示 */
        }
    }
}
​
/* 串口接收一个字符：一旦有数据从串口传至CC2530，
   则进入中断，将接收到的数据赋值给变量temp */
#pragma vector = URX0_VECTOR
__interrupt void UART0_ISR ( void ) {
    URX0IF = 0; /* 清中断标志 */
    temp = U0DBUF;
}
```

打开串口助手并进行连接，计算机发送`hello#`，将收到字符串`hello`。

### 内部温度传感器

&emsp;&emsp;`InitUART_Timer.h`如下：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
#define LED2 P1_1
#define LED3 P1_4
​
typedef unsigned char  BYTE;
typedef unsigned char  UINT8;
typedef unsigned char  INT8U;
typedef unsigned short UINT16;
typedef unsigned short INT16U;
typedef unsigned long  UINT32;
typedef unsigned long  INT32U;
typedef signed char    INT8;
typedef signed short   INT16;
typedef signed long    INT32;
​
#define DISABLE_ALL_INTERRUPTS() (IEN0 = IEN1 = IEN2 = 0x00)
​
void InitClock ( void ) {
    CLKCONCMD &= ~0x40;
​
    while ( CLKCONSTA & 0x40 );
​
    CLKCONCMD &= ~0x47;
}
​
void InitLed ( void ) {
    P1DIR |= 0x13;
    LED1 = 0;
    LED2 = 0;
    LED3 = 0;
}
​
void InitUART0 ( void ) {
    PERCFG = 0x00;
    P0SEL = 0x3c;
    P2DIR &= ~0XC0;
    U0CSR |= 0x80;
    U0GCR |= 11;
    U0BAUD |= 216;
    UTX0IF = 1;
    U0CSR |= 0X40;
    IEN0 |= 0x84;
}
​
void UartTX_Send_String ( char *Data, int len ) {
    int j;
​
    for ( j = 0; j < len; j++ ) {
        U0DBUF = *Data++;
​
        while ( UTX0IF == 0 );
​
        UTX0IF = 0;
    }
​
    U0DBUF = 0x0A; /* 换行 */
​
    while ( UTX0IF == 0 );
​
    UTX0IF = 0;
}
​
/* 延时xms毫秒(16M晶振时的大约数，32M需要修改，系统不修改默认使用内部16M) */
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
```

&emsp;&emsp;`main.c`如下：

``` cpp
#include <ioCC2530.h>
#include "InitUART_Timer.h" /* 注意在option里设置路径 */
#include "stdio.h"
​
void initTempSensor ( void ) { /* 温度传感器初始化函数 */
    DISABLE_ALL_INTERRUPTS(); /* 关闭所有中断 */
    InitClock(); /* 设置系统主时钟为32M */
    TR0 = 0X01; /* 设置为1来连接温度传感器到SOC_ADC */
    ATEST = 0X01; /* 使能温度传感器 */
}
​
float getTemperature ( void ) { /* 读取温度传感器AD值函数 */
    uint value;
    ADCCON3 = ( 0x3E ); /* 选择内部1.25V为参考电压；12位ENOB；对片内温度传感器进行采样 */
    ADCCON1 |= 0x30; /* 选择ADC的启动模式为手动(启动序列转换) */
    ADCCON1 |= 0x40; /* 启动AD转化(启动转换) */
​
    while ( ! ( ADCCON1 & 0x80 ) ); /* 等待AD转换完成 */
​
    /* ADCL寄存器低4位无效，ADC最高只能达到12位有效位 */
    value = ADCL >> 4;
    value |= ( ( ( UINT16 ) ADCH ) << 4 );
    /* 根据AD值，计算出实际的温度。芯片手册上有错误，温度系数应该是4.5/℃。
       进行温度校正，这里减去5℃(不同芯片根据具体情况校正) */
    return ( value - 1367.5 ) / 4.5 - 5;
}
​
void main ( void ) {
    char i;
    char TempValue[6];
    float AvgTemp;
    InitUART0();
    initTempSensor();
​
    while ( 1 ) {
        AvgTemp = 0;
​
        for ( i = 0 ; i < 64 ; i++ ) {
            AvgTemp += getTemperature();
            AvgTemp = AvgTemp / 2; /* 每次累加后除以2 */
        }
​
        /* 将温度转换成ASCII码发送 */
        TempValue[0] = ( unsigned char ) ( AvgTemp ) / 10 + 48; /* 十位 */
        TempValue[1] = ( unsigned char ) ( AvgTemp ) % 10 + 48; /* 个位 */
        TempValue[2] = '.'; /* 小数点 */
        TempValue[3] = ( unsigned char ) ( AvgTemp * 10 ) % 10 + 48; /* 十分位 */
        TempValue[4] = ( unsigned char ) ( AvgTemp * 100 ) % 10 + 48; /* 百分位 */
        TempValue[5] = '\0'; /* 字符串结束符 */
        UartTX_Send_String ( TempValue, 6 );
        Delayms ( 2000 ); /* 使用32M晶振，故这里2000约等于1s */
    }
}
```

### 睡眠唤醒

&emsp;&emsp;睡眠定时器用于设置系统进入和退出低功耗睡眠模式之间的周期。还用于当系统进入低功耗模式后，维持`MAC`定时器(`T2`)的定时。其特性如下：长达`24`位定时计数器，运行在`32.768KHz`的工作频率。`24`位的比较器具有中断和DMA触发功能，在`PM2`低功耗模式下运行系统。电源管理工作方式如下：

- `全功能模式`：高频晶振(`16M`或者`32M`)和低频晶振(`32.768K`的`RCOSC/XOSC`)全部工作，数字处理模块正常工作。
- `PM1`：高频晶振(`16M`或者`32M`)关闭，低频晶振(`32.768K`的`RCOSC/XOSC`)工作，数字核心模块正常工作。
- `PM2`：低频晶振(`32.768K`的`RCOSC/XOSC`)工作，数字核心模块关闭，系统通过`RESET`、外部中断或者睡眠计数器溢出唤醒。
- `PM3`：晶振全部关闭，数字处理核心模块关闭，系统只能通过`RESET`或外部中断唤醒，此模式下功耗最低。

&emsp;&emsp;`CC2530`需要配置的主要寄存器有`PCON`、`SLEEPCMD`：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED2 P1_1
#define KEY1 P0_0
​
void Delayms ( uint );
void InitLed ( void );
void SysPowerMode ( uchar sel );
​
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x02;
    P1INP |= 0X02;
    LED2 = 0;
    P0INP  &= ~0X01; /* 设置P0口输入电路模式为上拉/下拉 */
    P0IEN |= 0X01; /* P0.0设置为中断方式 */
    PICTL |= 0x01; /* 下降沿触发 */
}
​
/*-------------------------------
系统工作模式选择函数
* para1  0   1   2   3
* mode  PM0 PM1 PM2 PM3
-------------------------------*/
void SysPowerMode ( uchar mode ) {
    uchar i, j;
    i = mode;
​
    if ( mode < 4 ) {
        SLEEPCMD |= i; /* 设置系统睡眠模式 */
​
        for ( j = 0; j < 4; j++ );
​
        PCON = 0x01; /* 进入睡眠模式，通过中断打断 */
    } else {
        PCON = 0x00; /* 系统唤醒，通过中断打断 */
    }
}
​
void main ( void ) {
    uchar count = 0;
    InitLed();
    IEN1 |= 0X20; /* 开P0口总中断 */
    P0IFG |= 0x00; /* 清中断标志 */
    EA = 1; /* 开总中断 */
​
    while ( 1 ) {
        LED2 = ~LED2;
​
        if ( ++count >= 10 ) {
            count = 0;
            /* 5次闪烁后进入睡眠状态PM3，等待按键S1中断唤醒 */
            SysPowerMode ( 3 );
        }
​
        Delayms ( 500 );
    }
}
​
/* 中断处理函数(系统唤醒) */
#pragma vector = P0INT_VECTOR
__interrupt void P0_ISR ( void ) {
    if ( P0IFG > 0 ) {
        P0IFG = 0; /* 清标志位 */
    }
​
    P0IF = 0;
    SysPowerMode ( 4 ); /* 正常工作模式 */
}
```

### 定时器唤醒

&emsp;&emsp;`CC2530`睡眠定时器需要配置的寄存器主要有`ST0`、`ST1`、`ST2`，也就是`24bit`定时器：

- `ST0(0x95)`：睡眠计数器数据`Bit0`至`Bit7`。
- `ST1(0x96)`：睡眠计数器数据`Bit8`至`Bit15`。
- `ST2(0x97)`：睡眠计数器数据`Bit16`至`Bit23`。

配置唤醒时间寄存器有以下配置方法：

``` cpp
UINT32 sleepTimer = 0;
sleepTimer |= ST0;
sleepTimer |= (UINT32)ST1 << 8;
sleepTimer |= (UINT32)ST2 << 16;
sleepTimer += ((UINT32)sec * (UINT32)32768) /* 低速晶振 */
ST2 = (UINT8)(sleepTimer >> 16);
ST1 = (UINT8)(sleepTimer >> 8);
ST0 = (UINT8) sleepTimer;
```

配置完毕后，`sleepTimer`与`ST2 << 16 | ST1 << 8 | ST0`相差`sec`秒时间(低速晶振)。

``` cpp
/*--------------------------------------
  通过设置定时器在特定时间内进行唤醒，重
  新进入工作模式，每次唤醒LED2闪烁3下
---------------------------------------*/
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define UINT8 unsigned char
#define UINT16 unsigned int
#define UINT32 unsigned long
​
#define LED2 P1_1
​
void Delayms ( uint );
void InitLed ( void );
void SysPowerMode ( uchar sel );
​
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x02;
    P1INP |= 0X02;
    LED2 = 0;
}
​
void SysPowerMode ( uchar mode ) {
    uchar i, j;
    i = mode;
​
    if ( mode < 4 ) {
        SLEEPCMD |= i;
​
        for ( j = 0; j < 4; j++ );
​
        PCON = 0x01;
    } else {
        PCON = 0x00;
    }
}
​
/* 初始化“Sleep Timer”(设定后经过指定时间自行唤醒) */
void Init_SLEEP_TIMER ( void ) {
    ST2 = 0X00;
    ST1 = 0X00;
    ST0 = 0X00;
    EA = 1;
    STIE = 1; /* SleepTimerinterrupt enable */
    STIF = 0; /* SleepTimerinterrupt flag 还没处理的 */
}
​
void Set_ST_Period ( uint sec ) { /* 设置睡眠时间 */
    UINT32 sleepTimer = 0;
    sleepTimer |= ST0;
    sleepTimer |= ( UINT32 ) ST1 <<  8;
    sleepTimer |= ( UINT32 ) ST2 << 16;
    sleepTimer += ( ( UINT32 ) sec * ( UINT32 ) 32768 );
    ST2 = ( UINT8 ) ( sleepTimer >> 16 );
    ST1 = ( UINT8 ) ( sleepTimer >> 8 );
    ST0 = ( UINT8 ) sleepTimer;
}
​
void main ( void ) {
    uchar i;
    InitLed();
    Init_SLEEP_TIMER();
​
    while ( 1 ) {
        for ( i = 0; i < 6; i++ ) { /* 闪烁3下 */
            LED2 = ~LED2;
            Delayms ( 200 );
        }
​
        Set_ST_Period ( 3 ); /* 重新进入睡眠模式 */
        SysPowerMode ( 2 ); /* 进入PM2低频晶振模式 */
    }
}
​
/* 中断唤醒 */
#pragma vector = ST_VECTOR
__interrupt void ST_ISR ( void ) {
    STIF = 0; /* 清标志位 */
    SysPowerMode ( 4 ); /* 进入正常工作模式 */
}
```

### 看门狗

&emsp;&emsp;`CC2530`的看门狗只需要配置`1`个寄存器`WDCTL`：

``` cpp
#include <ioCC2530.h>
​
#define uint unsigned int
#define uchar unsigned char
​
#define LED1 P1_0
#define LED2 P1_1  
​
void Delayms ( uint xms );  
void InitLed ( void );  
​
void Delayms ( uint xms ) {
    uint i, j;
​
    for ( i = xms; i > 0; i-- )
        for ( j = 587; j > 0; j-- );
}
​
void InitLed ( void ) {
    P1DIR |= 0x03;
    P1INP |= 0X03;
    LED1 = 0;
    LED2 = 0;
}
​
void Init_Watchdog ( void ) {
    WDCTL = 0x00; /* 这是必须的，打开IDLE才能设置看门狗 */
    WDCTL |= 0x08; /* 时间间隔一秒，看门狗模式 */
}
​
void FeetDog ( void ) { /* 清除看门狗定时器，即喂狗 */
    WDCTL = 0xa0;
    WDCTL = 0x50;
}
​
void main ( void ) {
    InitLed();
    Init_Watchdog();
    LED1 = 1;
​
    while ( 1 ) {
        LED2 = ~LED2;
        Delayms ( 300 );
        LED1 = 0;
        FeetDog(); /* 喂狗 */
    }
}
```