---
title: 文件操作
categories: Python语法
abbrlink: 95495db
date: 2019-01-10 15:12:50
---
### 文件

&emsp;&emsp;文件打开模式如下：

打开模式 | 执行操作
--------|------------
`r`     | 以只读方式打开文件(默认)
`w`     | 以写入的方式打开文件，会覆盖已存在的文件
`x`     | 如果文件已经存在，使用此模式打开将引发异常
`a`     | 以写入模式打开，如果文件存在，则在末尾追加写入
`b`     | 以二进制模式打开文件
`t`     | 以文本模式打开(默认)
`+`     | 可读写模式(可添加到其他模式中使用)
`U`     | 通用换行符支持

&emsp;&emsp;文件对象方法如下：

文件对象方法                      | 执行操作
---------------------------------|--------
`f.close()`                      | 关闭文件
`f.read([size=-1])`              | 从文件中读取`size`个字符，当未给定`size`或给定负值时，读取剩余的所有字符，然后作为字符串返回
`f.readline([size=-1])`          | 从文件中读取并返回一行(包括行结束符)，如果`size`有定义，则返回`size`个字符
`f.write(str)`                   | 将字符串`str`写入文件
`f.writelines(seq)`              | 向文件写入字符串序列`seq`，`seq`应该是一个返回字符串的可迭代对象
`f.seek(offset, from)`           | 在文件中移动文件指针，从`from`(`0`代表文件起始位置，`1`代表当前位置，`2`代表文件末尾)偏移`offset`个字节
`f.tell()`                       | 返回当前文件指针在文件中的位置
`f.truncate([size=file.tell()])` | 截取文件到`size`个字节，默认是截取到文件指针当前位置

&emsp;&emsp;在`C`盘下有一个文件`test.txt`，其内容为：

``` python
0123456789
abcdefghij
ABCDEFGHIJ
```

在终端输入：

``` python
f = open("C:\\test.txt")
f  # 结果为<_io.TextIOWrapper name='C:\\test.txt' mode='r' encoding='cp936'>
f.read()  # 结果为“0123456789\nabcdefghij\nABCDEFGHIJ\n”
f.read()  # 结果为“”
f.close()  # 关闭文件
#-----------------------
f = open("C:\\test.txt")
f.read(5)  # 结果为“01234”
f.tell()  # 结果为5
f.seek(8, 0)  # 结果为8
f.readline()  # 结果为“89\n”
list(f)  # 结果为['abcdefghij\n', 'ABCDEFGHIJ\n']
f.seek(0, 0)  # 结果为0
lines = list(f)
​
for each_line in lines:  # 效率低的打印文本每一行文本的程序
    print(each_line)
​
for each_line in f:  # 效率高的打印文本每一行的语句
    print(each_line)
​
f.close()
​
f = open("C:\\test_1.txt", "w")  # 创建并向文件中写入数据
f.write("I love xinzi")  # 结果为12
f.close()
```

### close

&emsp;&emsp;`close`方法用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作，否则会触发`ValueError`错误。`close`方法允许调用多次。
&emsp;&emsp;当`file`对象被引用到操作另外一个文件时，`Python`会自动关闭之前的`file`对象。使用`close`方法关闭文件是一个好的习惯。`close`语法如下：

``` python
fileObject.close()
```

该方法没有返回值。

``` python
fo = open("runoob.txt", "wb")
print("文件名为:", fo.name)
fo.close()
```

### flush

&emsp;&emsp;`flush`方法用来刷新缓冲区，就是将缓冲区中的数据立刻写入文件，同时清空缓冲区。一般情况下，文件关闭后会自动刷新缓冲区，但有时需要在关闭前刷新它，这时就可以使用`flush`方法。`flush`语法如下：

``` python
fileObject.flush()
```

该方法没有返回值。

``` python
fo = open("runoob.txt", "wb")
print("文件名为:", fo.name)
fo.flush()  # 刷新缓冲区
fo.close()
```

### fileno

&emsp;&emsp;`fileno`方法返回一个整型的文件描述符，可用于底层操作系统的`I/O`操作。`fileno`语法如下：

``` python
fileObject.fileno()
```

实例如下：

``` python
fo = open("runoob.txt", "wb")
fd = fo.fileno()
print("文件描述符为:", fd)  # 输出“文件描述符为: 3”
fo.close()
```

### isatty

&emsp;&emsp;`isatty`方法检测文件是否连接到一个终端设备，如果是则返回`True`，否则返回`False`。`isatty`语法如下：

``` python
fileObject.isatty()
```

实例如下：

``` python
fo = open("runoob.txt", "wb")
ret = fo.isatty()
print("返回值:", ret)  # 输出“返回值: False”
fo.close()
```

### truncate

&emsp;&emsp;`truncate`方法用于从文件的首行首字符开始截断，截断文件为`size`个字符。`truncate`语法如下：

``` python
fileObject.truncate([size])
```

该方法没有返回值。假设文件`runoob.txt`的内容如下：

``` python
1:www.runoob.com
2:www.runoob.com
```

实例如下：

``` python
fo = open("runoob.txt", "r+")
fo.truncate(10)  # 截取10个字节
str = fo.read()
print("读取数据: %s" % str)  # 输出“读取数据: 1:www.runo”
fo.close()
```

### writelines

&emsp;&emsp;`writelines`方法用于向文件中写入一序列的字符串，这一序列字符串可以是由迭代对象产生的，例如一个字符串列表。如果需要换行，则加上换行符`\n`。`writelines`语法如下：

``` python
fileObject.writelines([str])
```

参数`str`是要写入文件的字符串序列。该方法没有返回值。

``` python
fo = open("test.txt", "w")
seq = ["first line\n", "second line"]
fo.writelines(seq)
fo.close()
```

执行上述代码，文件`test.txt`的内容如下：

``` python
first line
second line
```

### pickle

&emsp;&emsp;`Python`提供了一种更简便的方法来存储列表和对象，名为`pickle`。

``` python
import pickle
​
my_list = [123, 3.14, "小甲鱼", ["another list"]]
​
pickle_file = open("my_list.pkl", "wb")
pickle.dump(my_list, pickle_file)  # 将数据放进“pickle_file”中
pickle_file.close()
​
pickle_file = open("my_list.pkl", "rb")
my_list2 = pickle.load(pickle_file)  # 将数据从“pickle_file”中取出
print(my_list2)
```

### with

&emsp;&emsp;一些对象定义了标准的清理行为，一旦不需要该对象了，那么就需要执行这个标准的清理行为。示例如下：

``` python
for line in open("myfile.txt"):
    print(line, end="")
```

以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。关键词`with`就可以保证诸如文件之类的对象在使用完之后，一定会正确地执行它的清理方法：

``` python
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
```

以上代码执行完毕后，文件`f`总是会关闭。