---
title: 错误和异常
date: 2019-02-10 19:42:03
categories: Python语法
---
&emsp;&emsp;`Python`有两种错误很容易辨认：语法错误和异常。`Python`标准异常总结如下：

异常                    | 说明
------------------------|-----
`AssertionError`        | 断言语句(`assert`)失败
`AttributeError`        | 尝试访问未知的对象属性
`EOFError`              | 用户输入文件末尾标志`EOF`(`Ctrl + d`)
`FloatingPointError`    | 浮点计算错误
`GeneratorExit`         | `generator.close`方法被调用的时候
`ImportError`           | 导入模块失败的时候
`IndexError`            | 索引超出序列的范围
`KeyError`              | 字典中查找一个不存在的关键字
`KeyboardInterrupt`     | 用户输入中断键(`Ctrl + c`)
`MemoryError`           | 内存溢出(可通过删除对象释放内存)
`NameError`             | 尝试访问一个不存在的变量
`NotImplementedError`   | 尚未实现的方法
`OSError`               | 操作系统产生的异常(例如打开一个不存在的文件)
`OverflowError`         | 数值运算超出最大限制
`ReferenceError`        | 弱引用(`weak reference`)试图访问一个已经被垃圾回收机制回收了的对象
`RuntimeError`          | 一般的运行时错误
`StopIteration`         | 迭代器没有更多的值
`SyntaxError`           | `Python`的语法错误
`IndentationError`      | 缩进错误
`TabError`              | `Tab`和空格混合使用
`SystemError`           | `Python`编译器系统错误
`SystemExit`            | `Python`编译器进程被关闭
`TypeError`             | 不同类型间的无效操作
`UnboundLocalError`     | 访问一个未初始化的本地变量(`NameError`的子类)
`UnicodeError`          | `Unicode`相关的错误(`ValueError`的子类)
`UnicodeEncodeError`    | `Unicode`编码时的错误(`UnicodeError`的子类)
`UnicodeDecodeError`    | `Unicode`解码时的错误(`UnicodeError`的子类)
`UnicodeTranslateError` | `Unicode`转换时的错误(`UnicodeError`的子类)
`ValueError`            | 传入无效的参数
`ZeroDivisionError`     | 除数为零

&emsp;&emsp;以下是`Python`内置异常类的层次结构：

``` python
BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```

### 语法错误

&emsp;&emsp;`Python`的语法错误称之为`解析错误`：

``` python
>>> while True print('Hello world')
SyntaxError: invalid syntax
```

这个例子中，函数`print`被检查到有错误，是它前面缺少了一个冒号`:`。
&emsp;&emsp;即便`Python`程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为`异常`。大多数的异常都不会被程序处理，都以错误信息的形式展现在这里：

``` python
>>> 10 * (1/0)
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    10 * (1/0)
ZeroDivisionError: division by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<pyshell#8>", line 1, in <module>
    4 + spam*3
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    '2' + 2
TypeError: must be str, not int
```

&emsp;&emsp;异常以不同的类型出现，这些类型都作为信息的一部分打印出来，例子中的类型有`ZeroDivisionError`、`NameError`和`TypeError`。错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。

### 异常处理

&emsp;&emsp;以下示例让用户输入一个合法的整数，但是允许用户中断这个程序(使用`Ctrl - C`或者操作系统提供的方法)。用户的中断信息会引发一个`KeyboardInterrupt`异常：

``` python
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops! That was no valid number. Try again!")
```

&emsp;&emsp;`try`语句按照如下方式工作：

- 首先执行`try`子句(在关键字`try`和`except`之间的语句)。
- 如果没有异常发生，忽略`except`子句，`try`子句执行后结束。如果在执行`try`子句的过程中发生了异常，那么`try`子句余下的部分将被忽略。如果异常的类型和`except`之后的名称相符，那么对应的`except`子句将被执行。最后执行`try`语句之后的代码。
- 如果一个异常没有与任何的`except`匹配，那么这个异常将会传递给上层的`try`中。

&emsp;&emsp;一个`try`语句可能包含多个`except`子句，分别来处理不同的特定的异常，最多只有一个分支会被执行。处理程序将只针对对应的`try`子句中的异常进行处理，而不是其他的`try`的处理程序中的异常。一个`except`子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组：

``` python
except (RuntimeError, TypeError, NameError):
    pass
```

&emsp;&emsp;最后一个`except`子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。

``` python
import sys
​
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise
```

&emsp;&emsp;`try except`语句还有一个可选的`else`子句，如果使用这个子句，那么必须放在所有的`except`子句之后。这个子句将在`try`子句没有发生任何异常的时候执行：

``` python
import sys
​
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
```

使用`else`子句比把所有的语句都放在`try`子句里面要好，这样可以避免一些意想不到的，而`except`又没有捕获的异常。
&emsp;&emsp;异常处理并不仅仅处理那些直接发生在`try`子句中的异常，而且还能处理子句中调用的函数(甚至间接调用的函数)里抛出的异常：

``` python
def this_fails():
    x = 1 / 0
​
try:
    this_fails()
except ZeroDivisionError as err:
    print('Handling run-time error:', err)
```

上述代码抛出如下异常：

``` python
Handling run-time error: int division or modulo by zero
```

### 抛出异常

&emsp;&emsp;`Python`使用`raise`语句抛出一个指定的异常：

``` python
>>> raise NameError('HiThere')
Traceback (most recent call last):
  File "<pyshell#13>", line 1, in <module>
    raise NameError('HiThere')
NameError: HiThere
```

&emsp;&emsp;`raise`唯一的参数指定了要被抛出的异常，它必须是一个异常的实例或者是异常的类(也就是`Exception`的子类)。如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的`raise`语句就可以再次把它抛出：

``` python
try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
```

上述代码抛出如下异常：

``` python
Traceback (most recent call last):
  File "C:\Users\fukangwei\Desktop\work_space\test.py", line 2, in <module>
    raise NameError('HiThere')
NameError: HiThere
```

### 用户自定义异常

&emsp;&emsp;你可以通过创建一个新的`exception`类来拥有自己的异常。异常应该继承自`Exception`类：

``` python
class MyError(Exception):
    def __init__(self, value):
        self.value = value
​
    def __str__(self):
        return repr(self.value)
​
try:
    raise MyError(2 * 2)
except MyError as e:
    print('My exception occurred, value:', e.value)
```

执行结果：

``` python
My exception occurred, value: 4
```

在这个例子中，类`Exception`默认的`__init__`方法被覆盖。
&emsp;&emsp;当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类：

``` python
class Error(Exception):
    """ Base class for exceptions in this module """
    pass
​
class InputError(Error):
    """
    Exception raised for errors in the input. Attributes:
    expression -- input expression in which the error occurred
    message -- explanation of the error
    """
    def __init__(self, expression, message):
        self.expression = expression
        self.message = message
​
class TransitionError(Error):
    """
    Raised when an operation attempts a state transition that's not allowed. Attributes:
    previous -- state at beginning of transition
    next -- attempted new state
    message -- explanation of why the specific transition is not allowed
    """
    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
```

大多数异常的名字都以`Error`结尾，和标准的异常命名规则一样。

### 定义清理行为

&emsp;&emsp;`try`语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为：

``` python
try:
    raise KeyboardInterrupt
finally:
    print('Goodbye, world!')
```

执行结果：

``` python
Goodbye, world!
Traceback (most recent call last):
  File "C:/Users/fukangwei/PycharmProjects/untitled1/hello.py", line 2, in <module>
    raise KeyboardInterrupt
KeyboardInterrupt
```

以上示例不管`try`子句里面有没有发生异常，`finally`子句都会执行。
&emsp;&emsp;如果一个异常在`try`子句里(或者在`except`和`else`子句里)被抛出，而又没有任何的`except`把它截住，那么这个异常会在`finally`子句执行后再次被抛出。下面是一个更加复杂的例子(在同一个`try`语句里包含`except`和`finally`子句)：

``` python
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print("division by zero!")
    else:
        print("result is", result)
    finally:
        print("executing finally clause")
```

在终端输入：

``` python
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
```

### assert

&emsp;&emsp;`Python`的`assert`断言是声明其布尔值必须为真的判定，如果发生异常，就说明该表达示为假。可以理解`assert`断言语句为`raise-if-not`，用来测试表示式，其返回值为假时，就会触发异常。

``` python
assert expression [, arguments]
```

`assert`的异常参数其实就是在断言表达式后添加字符串信息，用来解释断言并更好地指明出现问题的位置。

``` python
assert len(lists) >= 5, '列表元素个数小于5'
assert 2 == 1, '2不等于1'
```