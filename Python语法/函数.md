---
title: 函数
date: 2019-01-08 21:02:34
categories: Python语法
---
&emsp;&emsp;在终端输入：

``` python
def MyFirstFunction():  # 定义函数
    print("I am here")
    print("I love you")
​
MyFirstFunction()  # 调用函数
```

执行结果：

``` bash
I am here
I love you
```

&emsp;&emsp;在终端输入：

``` python
MySecondFunction()  # 未定义函数体，结果为“出错”
​
def MySecondFunction(name):  # 定义函数
    print("I love " + name)
​
MySecondFunction("xinzi")  # 调用函数，结果为“I love xinzi”
```

&emsp;&emsp;在终端输入：

``` python
def add1(num1, num2):  # 定义函数
    result = num1 + num2
    print(result)
​
add1(1, 3)  # 调用函数，结果为4
# -----------------------------
def add2(num1, num2):  # 定义函数
    return (num1 + num2)
​
print(add2(2, 3))  # 结果为5
```

### 函数文档

&emsp;&emsp;在终端输入：

``` python
def MyFirstFunction():  # 定义函数
    " hello, This is my first function "
    print("First Function")
​
MyFirstFunction()  # 调用函数，结果为“First Function”
# 输出函数文档，结果为“hello, This is my first function”
MyFirstFunction.__doc__
help(MyFirstFunction)  # 输出MyFirstFunction的函数文档
```

最后一行的输出结果为：

``` python
Help on function MyFirstFunction in module __main__:
​
MyFirstFunction()
    hello, This is my first function
```

&emsp;&emsp;`print`函数文档为：

``` python
print.__doc__  # 输出print的函数文档
help(print)  # 输出print的函数文档
```

### 关键字参数

&emsp;&emsp;在终端输入：

``` python
def MyLove(me, you):  # 定义函数
    print(me + ' love ' + you)
​
MyLove("I", "xinzi")  # 调用函数，结果为“I love xinzi”
MyLove("xinzi", "I")  # 调用函数，结果为“xinzi love”
# 调用函数，结果为“I love xinzi”，使用关键字参数可以防止参数顺序的颠倒
MyLove(you="xinzi", me="I")
```

### 默认参数

&emsp;&emsp;在终端输入：

``` python
def MyLove(me="I", you="XinZi"):  # 定义函数
    print(me + ' love ' + you)
​
MyLove()  # 调用函数，结果为“I love XinZi”
MyLove("you")  # 调用函数，结果为“you love XinZi”
MyLove("We", "You")  # 调用函数，结果为“We love You”
```

默认参数必须放在最后面，否则会报出如下错误：

``` bash
SyntaxError: non-default argument follows default argument
```

### 收集参数

&emsp;&emsp;收集参数类似于`C`语言的不定参数函数。基本语法如下：

``` python
def functionname([formal_args, ] * var_args_tuple):
    " 函数_文档字符串 "
    function_suite
    return [expression]
```

加了星号`*`的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。

``` python
def printinfo(arg1, *vartuple):
    " 打印任何传入的参数 "
    print("输出: ")
    print(arg1)
    print("--------")

    for var in vartuple:
        print(var)

    return
​
printinfo(10)
printinfo(70, 60, 50)
```

执行结果：

``` python
输出:
10
--------
输出:
70
--------
60
50
```

在终端输入：

``` python
def MyLove(*params):  # 定义函数
    print("参数的长度是：", len(params))
    print("第二个参数是：", params[1])
​
MyLove(1, "hello", 3, 4, 5, 6, 7)  # 调用函数
```

执行结果：

``` python
参数的长度是：7
第二个参数是：hello
```

&emsp;&emsp;在终端输入：

``` python
def MyLove(*params, exp):  # 定义函数
    print("参数的长度是：", len(params), exp)
    print("第二个参数是：", params[1])
​
MyLove(1, "hello", 3, 4, 5, 6, 7, exp=8)  # 调用函数
```

执行结果：

``` python
参数的长度是：7 8
第二个参数是：hello
```

&emsp;&emsp;`Python`还提供另一种标识符`**`，在形式参数前添加参数`1`、`2`、`3`成为`args`元祖的元素。实际参数的赋值表达式生成字典。例如，下面的这段代码实现了在一个字典中匹配元祖的元素。定义函数时，设计两个参数：一个是待匹配的元祖，表示为`*t`；另一个是字典，表示为`**d`。函数调用时，实际参数分成两个部分：一部分参数是若干个数字或字符串，另一部分参数是赋值表达式。

``` python
def search(*t, **d):
    keys = d.keys()
    values = d.values()
    print(keys)
    print(values)

    for arg in t:
        for key in keys:
            if arg == key:
                print("find:", d[key])
​
search("one", "three", one="1", two="2", three="3")
```

执行结果：

``` python
dict_keys(['one', 'two', 'three'])
dict_values(['1', '2', '3'])
find: 1
find: 3
```

`search`参数`"one","three"`对应于`*t`，参数`one="1", two="2", three="3"`对应于`**d`。更简单的代码如下：

``` python
def func(country, province, **kwargs):
    print(country, province, kwargs)
​
# 输出“China Sichuan {'city': 'Chengdu', 'section': 'JingJiang'}”
func("China", "Sichuan", city="Chengdu", section="JingJiang")
```

### 过程

&emsp;&emsp;过程是简单的、特殊的并且没有返回值的函数。在终端输入：

``` python
def hello():  # 定义函数
    print("hello")
​
temp = hello()  # 结果为hello
temp  # 没有任何结果
print(temp)  # 结果为None
type(temp)  # 结果为<class 'NoneType'>
​
def hello():  # 定义函数
    return [1, "hello", 2]
​
hello()  # 结果为[1, 'hello', 2]
```

### 局部变量和全局变量

&emsp;&emsp;下面是计算打折物品价格的程序：

``` python
def discounts(price, rate):
    final_price = price * rate
    return final_price
​
old_price = float(input("请输入原价："))
rate = float(input("请输入折扣率："))
new_price = discounts(old_price, rate)
print("打折后的价格是：", new_price)
```

如下程序运用局部变量出现错误：

``` python
def discounts(price, rate):
    final_price = price * rate
    return final_price
​
old_price = float(input("请输入原价："))
rate = float(input("请输入折扣率："))
new_price = discounts(old_price, rate)
print("打折后的价格是：", new_price)
print("final_price is:", final_price)  # 注意，final_price是局部变量！
```

&emsp;&emsp;全局变量的范围很广，函数会访问全局变量：

``` python
def discounts(price, rate):
    final_price = price * rate
    print("这里试图打印全局变量old_price的值：", old_price)
    return final_price
​
old_price = float(input("请输入原价："))
rate = float(input("请输入折扣率："))
new_price = discounts(old_price, rate)
print("打折后的价格是：", new_price)
```

执行结果：

``` python
请输入原价：100
请输入折扣率：0.5
这里试图打印全局变量old_price的值：100.0
打折后的价格是：50.0
```

但是函数不能轻易地修改全局变量：

``` python
def discounts(price, rate):
    final_price = price * rate
    old_price = 50
    print("修改后的old_price值1：", old_price)
    return final_price
​
old_price = float(input("请输入原价："))
rate = float(input("请输入折扣率："))
new_price = discounts(old_price, rate)
print("修改后的old_price值2：", old_price)
print("打折后的价格是：", new_price)
```

执行结果：

``` python
请输入原价：100
请输入折扣率：0.8
修改后的old_price值1：50
修改后的old_price值2：100.0
打折后的价格是：80.0
```

如果函数试图修改全局变量，则`Python`会在函数内产生一个与全局变量同名的局部变量，两者互不影响。另外有一种特殊情况，假设下面这段代码被运行：

``` python
a = 10
​
def test():
    a = a + 1
    print(a)
​
test()
```

以上程序将会报错：

``` python
Traceback (most recent call last):
  File "test.py", line 7, in <module>
    test()
  File "test.py", line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
```

错误信息为局部作用域引用错误，因为`test`函数中的`a`是局部变量，并且是未定义的。
&emsp;&emsp;如果想修改全局变量，则需要`global`关键字：

``` python
count = 5
​
def MyFun():  # 定义函数
    count = 10
    print(count)
​
MyFun()  # 结果为10
count  # 结果为5，全局变量并未改变
#---------------------------------
def MyFun():  # 定义函数
    global count
    count = 10
    print(count)
​
MyFun()  # 结果为10
print(count)  # 结果为10，全局变量被改变
```

&emsp;&emsp;如果要修改嵌套作用域(外层非全局作用域，参考内嵌函数)中的变量，则需要`nonlocal`关键字：

``` python
def outer():
    num = 10
​
    def inner():
        nonlocal num  # nonlocal关键字声明
        num = 100
        print(num)  # 结果为100
​
    inner()
    print(num)  # 结果为100
​
outer()
```

### 内嵌函数

&emsp;&emsp;`Python`可以在函数内部产生函数，即内嵌函数。内嵌函数的作用域仅限它的父函数：

``` python
def fun1():  # 定义函数
    print("func1正在被调用")

    def fun2():
        print("func2正在被调用")
​
fun1()  # 结果为“func1正在被调用”
```

&emsp;&emsp;在终端输入：

``` python
def fun1():  # 定义函数
    print("func1正在被调用")

    def fun2():
        print("func2正在被调用")

    fun2()
​
fun1()  # 调用函数
```

执行结果：

``` python
func1正在被调用
func2正在被调用
```

### 闭包

&emsp;&emsp;`Python`的闭包机制：

``` python
def FunX(x):  # 定义函数
    def FunY(y):
        return x * y

    return FunY
​
i = FunX(8)
i  # 结果为<function FunX.<locals>.FunY at 0x024AB198>
type(i)  # 结果为<class 'function'>
i(5)  # 结果为40
FunX(8)(5)  # 结果为40
```

注意闭包机制的合理运用：

``` python
def fun1():
    x = 5

    def fun2():
        x *= x
        return x

    return fun2()

fun1()  # 结果为“出错”，fun1中的x类似于全局变量，Python对它有屏蔽机制
#-------------------------------
def fun1():
    x = [5]
​
    def fun2():
        x[0] *= x[0]
        return x[0]
​
    return fun2()
​
fun1()  # 结果为25
#-------------------------------
def fun1():
    x = 5

    def fun2():
        nonlocal x  # nonlocal关键字解除Python对x的屏蔽机制
        x *= x
        return x

    return fun2()
​
fun1()  # 结果为25
```

### 可更改(mutable)与不可更改(immutable)对象

&emsp;&emsp;在`python`中，`strings`、`tuples`和`numbers`是不可更改的对象，而`list`、`dict`等则是可以修改的对象。

- `不可变类型`：变量赋值`a = 5`后再赋值`a = 10`，这里实际是新生成一个`int`值对象`10`，再让`a`指向它，而`5`被丢弃，不是改变`a`的值，相当于新生成了`a`。
- `可变类型`：变量赋值`la = [1, 2, 3, 4]`后再赋值`la[2] = 5`，则是将`list la`的第`3`个元素值进行更改，`la`本身没有动，只是其内部的一部分值被修改了。

&emsp;&emsp;`python`函数的参数传递：

- `不可变类型`：类似`C++`的值传递，适用于`整数`、`字符串`、`元组`。例如`fun(a)`，传递的只是`a`的值，没有影响`a`对象本身。在`fun(a)`内部修改`a`的值，只是修改另一个复制的对象，不会影响`a`本身。
- `可变类型`：类似`C++`的引用传递，适用于`列表`、`字典`。例如`fun(la)`将`la`真正地传过去，对其修改后，`fun`外部的`la`也会受影响。

&emsp;&emsp;`python`中的一切都是对象，严格意义我们不能说值传递还是引用传递，应该说传不可变对象和传可变对象。
&emsp;&emsp;`python`传不可变对象实例：

``` python
def ChangeInt(a):
    a = 10
​
b = 2
ChangeInt(b)
print(b)  # 结果是“2”
```

实例中有`int`对象`2`，指向它的变量是`b`，在传递给`ChangeInt`函数时，按传值的方式复制了变量`b`，`a`和`b`都指向了同一个`int`对象。在`a = 10`时，新生成一个`int`值对象`10`，并让`a`指向它。
&emsp;&emsp;传可变对象实例：

``` python
def changeme(mylist):
    " 修改传入的列表 "
    mylist.append([1, 2, 3, 4])
    print("函数内取值:", mylist)
    return
​
mylist = [10, 20, 30]
changeme(mylist)
print("函数外取值:", mylist)
```

传入函数的和在末尾添加新内容的对象用的是同一个引用，因此执行结果为：

``` python
函数内取值: [10, 20, 30, [1, 2, 3, 4]]
函数外取值: [10, 20, 30, [1, 2, 3, 4]]
```

---

### Python函数返回不定数量的值

&emsp;&emsp;`Python`的函数可以`return`多个值，但其本质上还是返回单个值，只是利用了`tuple`的自动打包，将多个值打包成单个`tuple`返回：

``` python
def func_a():
    return 1, 2, 3, 4
​
if __name__ == '__main__':
    temp = func_a()
    print(type(temp))  # 输出“<class 'tuple'>”
```

稍微修改代码：

``` python
def func_a(*args):
    return 1, 2, 3, 4
​
if __name__ == '__main__':
    a, b, c, d = func_a()
    print(a, b, c, d)  # 输出“1 2 3 4”
```

代码利用了`tuple`的自动解包，将`tuple`的值分别赋值给了`a`、`b`、`c`和`d`四个变量，实现返回多个值。
&emsp;&emsp;既然知道`Python`返回多个值的本质是返回`tuple`，再自动解包赋值给`N`个变量，那么要实现返回任意多个值，只要手动返回一个`tuple`就可以了，`tuple`内元素的数量可以自定：

``` python
def func_a(*args):
    return tuple(arg * 2 for arg in args)
​
if __name__ == '__main__':
    a, b, c, d = func_a(1, 2, 3, 4)
    print(a, b, c, d)  # 输出“2 4 6 8”
```

上述代码中，将传入的参数值乘以`2`后，转换成`tuple`返回，再利用`tuple`的自动解包赋值给多个变量，从而实现函数返回不定数量的值。

---

### 递归

&emsp;&emsp;要合理地运用递归，否则有许多副作用！

``` python
def hello():
    return hello()
```

这个递归会产生一个死循环。
&emsp;&emsp;设置递归的层数：

``` python
import sys
sys.setrecursionlimit(100)
```

&emsp;&emsp;非递归求阶乘：

``` python
def factorial(n):
    result = n

    for i in range(1, n):
        result *= i
​
    return result
​
number = int(input("please input a number: "))
result = factorial(number)
print("%d 的阶乘是 %d" % (number, result))
```

&emsp;&emsp;递归求阶乘：

``` python
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)
​
number = int(input("please input a number: "))
result = factorial(number)
print("%d 的阶乘是 %d" % (number, result))
```

&emsp;&emsp;斐波那契数的非递归实现(效率高)：

``` python
def fab(n):
    n1 = 1
    n2 = 1
    n3 = 1
​
    if n < 1:
        print("输入出错！")
        return -1
​
    while (n - 2) > 0:
        n3 = n2 + n1
        n1 = n2
        n2 = n3
        n -= 1
​
    return n3
​
result = fab(20)
​
if result != -1:
    print("总共有%d小兔崽子诞生" % result)
```

斐波那契数的递归实现(效率低)：

``` python
def fab(n):
    if n < 1:
        print("输入有误")
​
    if (n == 1) or (n == 2):
        return 1
    else:
        return fab(n - 1) + fab(n - 2)
​
result = fab(20)

if result != -1:
    print("总共有%d小兔崽子诞生" % result)
```

递归运用的是分治思想！但是递归的效率很低，要注意！