---
title: 属性访问和描述符
categories: Python语法
abbrlink: 15f1dce0
date: 2019-02-10 09:34:43
---
### 属性访问

&emsp;&emsp;一些与类相关的`BIF`(`Build-In Function`)如下：
&emsp;&emsp;1. `issubclass`函数原型如下：

``` python
issubclass(class, classinfo)
```

- 一个类被认为是其自身的子类。
- `classinfo`可以是类对象组成的元组，只要`class`是其中任何一个候选类的子类，则返回`True`。

``` python
class A:
    pass
​
class B(A):
    pass
​
issubclass(B, A)  # 结果为True
issubclass(B, B)  # 结果为True
issubclass(B, object)  # 结果为True，object是所有类的基类
# ------------------------------
class C:
    pass
​
issubclass(B, C)  # 结果为False
```

&emsp;&emsp;2. `isinstance`函数原型如下：

``` python
isinstance(object, classinfo)
```

- 如果第一个参数不是对象，则永远返回`False`。
- 如果第二个参数不是类或由类对象组成的元组，会抛出一个`TypeError`异常。

``` python
b1 = B()
isinstance(b1, B)  # 结果为True
isinstance(b1, A)  # 结果为True
isinstance(b1, C)  # 结果为False
isinstance(b1, (A, B, C))  # 结果为True
```

&emsp;&emsp;3. `hasattr`函数原型如下：

``` python
hasattr(object, name)
```

`object`是对象，`name`是属性名。

``` python
class C:
    def __init__(self, x=0):
        self.x = x
​
c1 = C()
hasattr(c1, "x")  # 结果为True
hasattr(c1, x)  # 结果为“出错”
```

&emsp;&emsp;4. `getattr`函数原型如下：

``` python
getattr(object, name [, default])
```

在终端输入：

``` python
getattr(c1, "x")  # 结果为0
getattr(c1, "y")  # 结果为“出错”
getattr(c1, "y", "您访问的属性不存在...")  # 结果为“您访问的属性不存在...”
```

&emsp;&emsp;5. `setattr`函数原型如下：

``` python
setattr(object, name, value)
```

在终端输入：

``` python
setattr(c1, "y", "fool")
getattr(c1, "y", "您访问的属性不存在...")  # 结果为“fool”
```

&emsp;&emsp;6. `delattr`函数原型如下：

``` python
delattr(object, name)
```

在终端输入：

``` python
delattr(c1, "y")
delattr(c1, "y")  # 结果为“出错”
```

&emsp;&emsp;7. `property`函数原型如下：

``` python
property(fget=None, fset=None, fdel=None, doc=None)
```

在终端输入：

``` python
class C:
    def __init__(self, size=10):
        self.size = size
​
    def getValue(self):
        return self.size
​
    def setValue(self, value):
        self.size = value
​
    def delSize(self):
        del self.size
​
    x = property(getValue, setValue, delSize)
​
c1 = C()
c1.getValue()  # 结果为10
c1.x  # 结果为10
c1.x = 18
c1.x  # 结果为18
c1.size  # 结果为18
c1.getValue()  # 结果为18
del c1.x
c1.size  # 结果为“出错”
```

- `__getattr__(self, name)`：定义当用户试图获取一个不存在的属性时的行为。
- `__getattribute__(self, name)`：定义当类的属性被访问时的行为。
- `__setattr__(self, name, value)`：定义当一个属性被设置时的行为。
- `__delattr__(self, name)`：定义当一个属性被删除时的行为。

``` python
class C:
    def __getattr__(self, name):
        print("getattr")
​
    def __getattribute__(self, name):
        print("getattribute")
        return super().__getattribute__(name)
​
    def __setattr__(self, name, value):
        print("setattr")
        super().__setattr__(name, value)
​
    def __delattr__(self, name):
        print("delattr")
        super().__delattr__(name)
​
c = C()
c.x  # 结果为getattribute、getattr
c.x = 1  # 结果为setattr
c.x  # 结果为getattribute、1
del c.x  # 结果为delattr
```

&emsp;&emsp;写一个矩形类，默认有宽和高两个属性值；如果为一个叫`square`的属性赋值，那么说明这是一个正方形，值就是正方形的边长，此时宽和高都应该等于边长。

``` python
class Reactangle:
    def __init__(self, width=0, height=0):
        self.width = width
        self.height = height
​
    def __setattr__(self, name, value):
        if name == "square":
            self.width = value
            self.height = value
        else:
            # 如果写成“self.name = value”，则会进入无限递归
            super().__setattr__(name, value)
            # 将上一句改为“self.__dict__[name] = value”也是可以的
​
    def getArea(self):
        return self.width * self.height
​
r1 = Reactangle(4, 5)
r1.getArea()  # 结果为20
r1.height  # 结果为5
r1.width  # 结果为4
r1.square = 10
r1.height  # 结果为10
r1.width  # 结果为10
r1.getArea()  # 结果为100
```

---

### 描述符

&emsp;&emsp;描述符就是将某种特殊类型的类的实例指派给另一个类的属性。

- `__get__(self, instance, owner)`：用于访问属性，它返回属性的值。
- `__set__(self, instance, value)`：将在属性分配操作中调用，不返回任何内容。
- `__delete__(self, instance)`：控制删除操作，不返回任何内容。

``` python
class MyDecriptor:
    def __get__(self, instance, owner):
        print("getting...", self, instance, owner)
​
    def __set__(self, instance, value):
        print("setting...", self, instance, value)
​
    def __delete__(self, instance):
        print("deleting...", self, instance)
​
class Test:
    x = MyDecriptor()
​
test = Test()
test.x  # 结果为“getting... <__main__.MyDecriptor object> <__main__.Test object> <class '__main__.Test'>”
test.x = "X-man"  # 结果为“setting... <__main__.MyDecriptor object> <__main__.Test object> X-man”
del test.x  # 结果为“deleting... <__main__.MyDecriptor object> <__main__.Test object>”
```

&emsp;&emsp;自己实现`Python`的`property`：

``` python
class MyProperty:
    def __init__(self, fget=None, fset=None, fdel=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
​
    def __get__(self, instance, owner):
        return self.fget(instance)
​
    def __set__(self, instance, value):
        self.fset(instance, value)
​
    def __delete__(self, instance):
        self.fdel(instance)
​
class C:
    def __init__(self):
        self.__x = None
​
    def getX(self):
        return self.__x
​
    def setX(self, value):
        self.__x = value
​
    def delX(self):
        del self.__x
​
    x = MyProperty(getX, setX, delX)
​
c = C()
c.x = "X-man"
c.x  # 结果为“X-man”
c.__x  # 结果为“出错”，“__x”是c的私有变量
del c.x
```

&emsp;&emsp;先定义一个温度类，然后定义两个描述符类用于描述摄氏度和华氏度两个属性。要求两个属性会自动进行转换，也就是说你可以给摄氏度这个属性赋值，然后打印的华氏度属性是自动转换的结果。

``` python
class Celsius:
    def __init__(self, value=26.0):
        self.value = value
​
    def __get__(self, instance, owner):
        return self.value
​
    def __set__(self, instance, value):
        self.value = float(value)
​
class Fahrenheit:
    def __get__(self, instance, owner):
        return instance.cel * 1.8 + 32
​
    def __set__(self, instance, value):
        instance.cel = (float(value) - 32) / 1.8
​
class Temperture:
    cel = Celsius()
    fah = Fahrenheit()
​
temp = Temperture()
temp.cel  # 结果为26.0
temp.cel = 30
temp.fah  # 结果为86.0
temp.fah = 100
temp.cel  # 结果为37.77777777777778
```