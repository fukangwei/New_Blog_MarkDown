---
title: 按键驱动_杂项设备
categories: Linux驱动程序
abbrlink: 6b5ba47a
date: 2019-02-04 10:54:32
---
&emsp;&emsp;`button.c`如下：<!--more-->

``` cpp
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/poll.h>
#include <linux/irq.h>
#include <asm/irq.h>
#include <linux/interrupt.h> /* 中断有关的头文件，request_irq函数定义在此 */
#include <asm/uaccess.h>
#include <mach/regs-gpio.h>
#include <mach/hardware.h>
#include <linux/platform_device.h>
#include <linux/cdev.h>
#include <linux/miscdevice.h>
#include "linux/sched.h"
​
#define DEVICE_NAME "mybutton"

struct button_irq_desc { /* 定义按键中断结构体 */
    int irq;
    int pin;
    int pin_setting;
    int number;
    char *name;
};
​
#if !defined (CONFIG_QQ2440_BUTTONS)
    static struct button_irq_desc button_irqs [] = {
        {IRQ_EINT8,  S3C2410_GPG0,  S3C2410_GPG0_EINT8,   0, "KEY0"},
        {IRQ_EINT11, S3C2410_GPG3,  S3C2410_GPG3_EINT11,  1, "KEY1"},
        {IRQ_EINT13, S3C2410_GPG5,  S3C2410_GPG5_EINT13,  2, "KEY2"},
        {IRQ_EINT14, S3C2410_GPG6,  S3C2410_GPG6_EINT14,  3, "KEY3"},
        {IRQ_EINT15, S3C2410_GPG7,  S3C2410_GPG7_EINT15,  4, "KEY4"},
        {IRQ_EINT19, S3C2410_GPG11, S3C2410_GPG11_EINT19, 5, "KEY5"},
    };
#else /* means QQ */
    static struct button_irq_desc button_irqs [] = {
       {IRQ_EINT19, S3C2410_GPG11, S3C2410_GPG11_EINT19, 0, "KEY0"},
       {IRQ_EINT11, S3C2410_GPG3,  S3C2410_GPG3_EINT11,  1, "KEY1"},
       {IRQ_EINT2,  S3C2410_GPF2,  S3C2410_GPF2_EINT2,   2, "KEY2"},
       {IRQ_EINT0,  S3C2410_GPF0,  S3C2410_GPF0_EINT0,   3, "KEY3"},
       {       -1,            -1,                 -1,    4, "KEY4"},
       {       -1,            -1,                 -1,    5, "KEY5"},
    };
#endif

static volatile char key_values [] = {'0', '0', '0', '0', '0', '0'};
static DECLARE_WAIT_QUEUE_HEAD ( button_waitq ); /* 声明一个名为button_waitq的等待队列头 */
​/* 中断事件标志，中断服务程序将它置1，s3c2440_buttons_read将它清0。“ev_press = 1”表示按键按下，否则没有按下 */
static volatile int ev_press = 0;
​
static irqreturn_t buttons_interrupt ( int irq, void *dev_id ) { /* 按键中断服务程序 */
    struct button_irq_desc *button_irqs = ( struct button_irq_desc * ) dev_id;
    int down;
    down = !s3c2410_gpio_getpin ( button_irqs->pin ); /* 得到该pin的状态“0/1” */
​
    if ( down != ( key_values[button_irqs->number] & 1 ) ) {
        key_values[button_irqs->number] = '0' + down;
        ev_press = 1;
        wake_up_interruptible ( &button_waitq ); /* 唤醒休眠的进程 */
    }
​
    return IRQ_RETVAL ( IRQ_HANDLED );
}
​
/* 应用程序执行open系统调用时，s3c24xx_buttons_open函数将被调用，它用来注册6个按键的中断处理程序 */
static int s3c24xx_buttons_open ( struct inode *inode, struct file *file ) {
    int i;
    int err = 0;
​
    for ( i = 0; i < sizeof ( button_irqs ) / sizeof ( button_irqs[0] ); i++ ) {
        if ( button_irqs[i].irq < 0 ) {
            continue;
        }
​
        /* 注册中断服务程序：irq中断号、buttons_interrupt中断服务程序、
           IRQ_TYPE_EDGE_BOTH中断触发方式、name、中断名字 */
        err = request_irq ( button_irqs[i].irq, buttons_interrupt, IRQ_TYPE_EDGE_BOTH,
                            button_irqs[i].name, ( void * ) &button_irqs[i] ); /* 让dev_id唯一 */
​
        if ( err ) {
            break;
        }
    }
​
    if ( err ) { /* 如果发生错误，free掉所有的中断服务程序 */
        i--;
​
        for ( ; i >= 0; i-- ) {
            if ( button_irqs[i].irq < 0 ) {
                continue;
            }
​
            disable_irq ( button_irqs[i].irq );
            free_irq ( button_irqs[i].irq, ( void * ) &button_irqs[i] );
        }
​
        return -EBUSY;
    }
​
    ev_press = 1; /* 标志中断发生了 */
    return 0;
}
​
/* 应用程序对设备文件“/dev/buttons”执行close时，就会调用s3c24xx_buttons_close函数 */
static int s3c24xx_buttons_close ( struct inode *inode, struct file *file ) {
    int i;
​
    /* 设备关闭实际上就是free掉中断服务程序 */
    for ( i = 0; i < sizeof ( button_irqs ) / sizeof ( button_irqs[0] ); i++ ) {
        if ( button_irqs[i].irq < 0 ) {
            continue;
        }
​
        free_irq ( button_irqs[i].irq, ( void * ) &button_irqs[i] );
    }
​
    return 0;
}
​
/* 应用程序对设备文件“/dev/buttons”执行read时，就会调用s3c24xx_buttons_read函数 */
/* “__wait_event_interruptible”首先定义并初始化一个wait_queue_t变量__wait，其中数据为当前进程current，
   并把__wait入队。在无限循环中，“__wait_event_interruptible”将本进程置为可中断的挂起状态，反复检查
   condition是否成立，如果成立则退出，如果不成立则继续休眠；条件满足后，即把本进程运行状态置为运行态，
   并将__wait从等待队列中清除掉，从而进程能够调度运行。如果进程当前有异步信号(POSIX的)，则返回“-ERESTARTSYS” */
static int s3c24xx_buttons_read ( struct file *filp, char __user *buff, size_t count, loff_t *offp ) {
    unsigned long err;
​
    if ( !ev_press ) {
        if ( filp->f_flags & O_NONBLOCK ) {
            return -EAGAIN;
        } else {
            wait_event_interruptible ( button_waitq, ev_press );
        }
    }
​
    ev_press = 0;
    err = copy_to_user ( buff, ( const void * ) key_values, min ( sizeof ( key_values ), count ) );
    return err ? -EFAULT : min ( sizeof ( key_values ), count );
}
​
/* 应用程序对设备文件“/dev/buttons”执行select时，就会调用
   s3c24xx_buttons_poll函数，作用是判断设备的可读写状态 */
static unsigned int s3c24xx_buttons_poll ( struct file *file, struct poll_table_struct *wait ) {
    unsigned int mask = 0;
    poll_wait ( file, &button_waitq, wait );
​
    if ( ev_press ) {
        mask |= POLLIN | POLLRDNORM;
    }
​
    return mask;
}
​
/* 这个结构是字符驱动设备程序的核心，当应用程序操作设备文件时所调用的
   open、read、write等函数最终会调用这个结构中的对应函数 */
static struct file_operations dev_fops = { /* 定义dev_fops结构 */
    .owner   = THIS_MODULE, /* 这是一个宏，指向编译模块时自动创建的“__this_module”变量 */
    .open    = s3c24xx_buttons_open,
    .release = s3c24xx_buttons_close,
    .read    = s3c24xx_buttons_read,
    .poll    = s3c24xx_buttons_poll,
};
​
static struct miscdevice misc = { /* 定义名为misc的混杂设备 */
    .minor = MISC_DYNAMIC_MINOR,
    .name  = DEVICE_NAME,
    .fops  = &dev_fops,
};
​
static int __init dev_init ( void ) {
    int ret;
    ret = misc_register ( &misc ); /* 注册misc混杂设备 */
    printk ( DEVICE_NAME"\tinitialized\n" );
    return ret;
}

static void __exit dev_exit ( void ) {
    misc_deregister ( &misc ); /* 注销misc混杂设备 */
}
​
module_init ( dev_init );
module_exit ( dev_exit );
MODULE_LICENSE ( "GPL" );
```

&emsp;&emsp;`button_test.c`如下：

``` cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/select.h>
#include <sys/time.h>
#include <errno.h>
​
int main ( void ) {
    int buttons_fd;
    int key_value;
    buttons_fd = open ( "/dev/mybutton", 0 );
​
    if ( buttons_fd < 0 ) {
        perror ( "open device buttons" );
        exit ( 1 );
    }
​
    for ( ;; ) {
        fd_set rds;
        int ret;
        FD_ZERO ( &rds );
        FD_SET ( buttons_fd, &rds );
        ret = select ( buttons_fd + 1, &rds, NULL, NULL, NULL );
​
        if ( ret < 0 ) {
            perror ( "select" );
            exit ( 1 );
        }
​
        if ( ret == 0 ) {
            printf ( "Timeout.\n" );
        } else if ( FD_ISSET ( buttons_fd, &rds ) ) {
            int ret = read ( buttons_fd, &key_value, sizeof key_value );
​
            if ( ret != sizeof key_value ) {
                if ( errno != EAGAIN ) {
                    perror ( "read buttons\n" );
                }
​
                continue;
            } else {
                printf ( "buttons_value: %d\n", key_value + 1 );
            }
        }
    }
​
    close ( buttons_fd );
    return 0;
}
```

生成`button.ko`，下载进开发板，然后安装，再执行`app-button`可执行文件。