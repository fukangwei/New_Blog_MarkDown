---
title: IIC总线协议
categories: 硬件电路笔记
date: 2018-12-03 09:14:37
mathjax: true
---
&emsp;&emsp;`I2C`是`Philips`公司推出的芯片间串行传输总线，以两根连线(`SDA`和`SCL`)即可实现完善的全双工同步数据传送，具有规范完整、结构独立和使用简单等特点。`I2C`总线的时钟线`SCL`和数据线`SDA`均为双向传输线。数据线上每传输一位数据都要求时钟线上有`1`个时钟脉冲与其相对应。标准的`IIC`总线协议数据传输速率为`100 kbit/s`，`7`位设备地址。<!--more-->
&emsp;&emsp;`IIC`总线协议最重要的是起始信号、终止信号和应答信号。起始信号和终止信号由主机产生，应答信号是每次传输完成一个字节数据后必须有的，用于确认传输是否完成，主机向设备发一个字节数据后需要设备作应答，确认设备是否收到数据，主机收一个字节数据后需要向设备发一个应答信号，告诉设备数据是否收到。

- 起始信号：在时钟线保持高电平期间，数据线出现由高电平向低电平变化时启动`I2C`总线。
- 终止信号：在时钟线保持高电平期间，数据线出现由低电平向高电平变化时停止`I2C`总线。
- 应答信号：应答信号在第`9`个时钟位上出现，接收器输出低电平为应答信号$A$，输出高电平则为非应答信号$\bar{A}$。

&emsp;&emsp;`IIC`数据传输：`SCL`为高电平时将`SDA`上数据发走，所以`SDA`上数据必须在`SCL`为高电平期间保持稳定，`IIC`总线首先传输的是数据最高位，最后是最低位。在第`9`个时钟脉冲的时候，发送方不再发送数据，而是将数据总线释放，由接收方发送一个应答位(应答位一般保持低电平)。
&emsp;&emsp;设备地址：在起始信号后，需要向设备发送一个字节的设备地址，其中`高7位`为设备的地址，表示同哪个设备进行通信；`最低位`为数据传输方向，`1`表示读(接收)，`0`表示写(发送)。
&emsp;&emsp;`IIC`总线忙的状态：`IIC`总线正在进行通信。
&emsp;&emsp;当发送错误的时候，硬件自动地进行仲裁；当对方的应答信号没有发生时，我们有应答错误的标志；当检测到起始和停止错位，也有相应的应答错误标志。应答信号没有产生，可能是由于接收方没有地址，也可能是接收方正在忙。当接收方正在忙的时候，数据传输过来，它来不及应答，我们可以尝试再次发送数据过来。
&emsp;&emsp;1. 发送(写)一个字节数据流程：

``` bash
起始信号。
发送一个设备地址，这里为0，表示发送(写)，设备应答。
发送设备的写的基地址，设备应答。
发送数据到设备基地址，设备应答。
停止信号。
```

&emsp;&emsp;2. 接收(读)一个字节数据流程：

``` bash
起始信号。
发送一个设备地址，这里为0，表示发送(写)，设备应答。
发送从设备要读数据的基地址，设备应答。
起始信号。
发送一个设备地址，这里为1，表示接收(读)，设备应答。
从设备基地址处接收到一个字节的数据，主机应答。
停止信号。
```

从设备地址读或写一个字节数据后，设备读写地址会自动加1。
&emsp;&emsp;3. 连续发送(写)多个字节数据：

``` bash
起始信号。
发送一个设备地址，这里为0，表示发送(写)，设备应答。
发送设备的写的基地址，设备应答。
发送数据到设备基地址，设备应答。
发送数据到设备(基地址 + 1)，设备应答。
发送数据到设备(基地址 + 2)，设备应答。
发送数据到设备(基地址 + n)，设备应答。
停止信号。
```

&emsp;&emsp;4. 连续接收(读)多个字节数据：

``` bash
起始信号。
发送一个设备地址，这里为0，表示发送(写)，设备应答。
发送从设备要读数据的基地址，设备应答。
起始信号。
发送一个设备地址，这里为1，表示接收(读)，设备应答。
从设备基地址处接收到一个字节的数据，主机应答。
从设备(基地址处 + 1)接收到一个字节的数据，主机应答。
从设备(基地址处 + 2)接收到一个字节的数据，主机应答。
从设备(基地址处 + n)接收到一个字节的数据，主机应答。
停止信号。
```

&emsp;&emsp;读写`IIC`元器件数据的代码如下：

``` cpp
/* I2C从AT24C02读数据 */
void I2cRead ( uchar I2cAddress, uchar* I2cData, uchar Bytes ) {
    I2cStart(); /* 启动总线 */
    I2cWriteByte ( WriteDeviceAddress ); /* 发送器件地址 */
    WaitAck();
    I2cWriteByte ( I2cAddress ); /* 发送器件子地址 */
    WaitAck();
    I2cStart(); /* 启动总线。注意之前是写，结束后需要重新启动，然后才能读 */
    I2cWriteByte ( ReadDeviceAddress ); /* 发送器件地址 */
    WaitAck();

    while ( Bytes-- ) {
        *I2cData = I2cReadByte(); /* 读取数据 */
        I2cAck();
        I2cData++;
    }

    I2cNoAck();
    I2cStop();
}

/* I2C写数据到AT24C02 */
void I2cWrite ( uchar I2cAddress, uchar* I2cData, uchar Bytes ) {
    I2cStart(); /* 启动总线 */
    I2cWriteByte ( WriteDeviceAddress ); /* 发送器件地址 */
    WaitAck();
    I2cWriteByte ( I2cAddress ); /* 发送器件子地址 */
    WaitAck();

    while ( Bytes-- ) {
        I2cWriteByte ( *I2cData ); /* 发送数据 */
        WaitAck();
        I2cData++;
    }

    I2cStop();
    DelayMs ( 10 );
}
```