---
title: ModBus协议
date: 2018-12-03 21:27:06
categories: 硬件电路笔记
---
&emsp;&emsp;`Modbus`是由`Modicon`在`1979`年发明的，是全球第一个真正用于工业现场的总线协议。`ModBus`网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件也包括软件，可应用于各种数据采集和过程监控。`ModBus`网络只有一个主机，所有通信都由它发出。网络可支持`247`个远程从属控制器，但实际所支持的从机数要由所用通信设备决定。采用这个系统，各`PC`可以和中心主机交换信息而不影响各`PC`执行本身的控制任务。

### ModBus简介

&emsp;&emsp;`Modbus`协议是应用于电子控制器上的一种通用语言。通过此协议，控制器相互之间、控制器经由网络(例如以太网)和其它设备之间可以通信。它已经成为一通用工业标准，有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。此协议定义了一个控制器能认识使用的消息结构，而不管它们是经过何种网络进行通信的。它描述了控制器请求访问其它设备的过程，如何回应来自其它设备的请求以及怎样侦测错误并记录。它制定了消息域格局和内容的公共格式。
&emsp;&emsp;当在`Modbus`网络上通信时，此协议决定了每个控制器须要知道它们的设备地址，识别按地址发来的消息，决定要产生何种行动。如果需要回应，控制器将生成反馈信息并用`Modbus`协议发出。在其它网络上，包含了`Modbus`协议的消息转换为在此网络上使用的帧或包结构。这种转换也扩展了根据具体的网络解决节地址、路由路径及错误检测的方法。
&emsp;&emsp;此协议支持传统的`RS-232`、`RS-422`、`RS-485`和以太网设备。许多工业设备，包括`PLC`、`DCS`、智能仪表等都在使用`Modbus`协议作为他们之间的通讯标准。

### ModBus特点

&emsp;&emsp;`Modbus`具有以下几个特点：

- 标准、开放，用户可以免费、放心地使用`Modbus`协议，不需要交纳许可证费，也不会侵犯知识产权。
- `Modbus`可以支持多种电气接口，如`RS-232`、`RS-485`等，还可以在各种介质上传送，如双绞线、光纤、无线等。
- `Modbus`的帧格式简单、紧凑、通俗易懂。用户使用容易，厂商开发简单。

### Modbus网络传输

&emsp;&emsp;标准的`Modbus`口是使用`RS-232-C`兼容串行接口，它定义了连接口的针脚、电缆、信号位、传输波特率、奇偶校验。控制器能直接或经由`Modem`组网。
&emsp;&emsp;控制器通信使用主从技术，即仅需要一个设备(主设备)能初始化传输(查询)。其它设备(从设备)根据主设备查询提供的数据作出相应反应。典型的主设备：主机和可编程仪表；典型的从设备：可编程控制器。
&emsp;&emsp;主设备可单独和从设备通信，也能以广播方式和所有从设备通信。如果单独通信，从设备返回消息作为回应，如果是以广播方式查询的，则不作任何回应。`Modbus`协议建立了主设备查询的格式：设备(或广播)地址、功能代码、所有要发送的数据、错误检测域。从设备回应消息也由`Modbus`协议构成，包括确认要行动的域、任何要返回的数据和错误检测域。如果在消息接收过程中发生错误，或从设备不能执行其命令，从设备将建立错误消息并把它作为回应发送出去。

### 其它类型传输

&emsp;&emsp;在其它网络上，控制器使用对等技术通信，故任何控制器都能初始化和其它控制器的通信。这样在单独的通信过程中，控制器既可作为主设备也可作为从设备。提供的多个内部通道可允许同时发生的传输进程。
&emsp;&emsp;在消息位，`Modbus`协议仍提供了主从原则，尽管网络通信方法是`对等`。如果控制器发送消息，它只是作为主设备，并期望从从设备得到回应。同样，当控制器接收到消息，它将建立从设备回应格式并返回给发送的控制器。

### 查询回应周期

#### 查询

&emsp;&emsp;查询消息中的功能代码告之被选中的从设备要执行何种功能。数据段包含了从设备要执行功能的任何附加信息。例如功能代码`03`是要求从设备读保持寄存器并返回它们的内容。数据段必须包含要告之从设备的信息：从何寄存器开始读及要读的寄存器数量。错误检测域为从设备提供了一种验证消息内容是否正确的方法。

#### 回应

&emsp;&emsp;如果从设备产生正常的回应，在回应消息中的功能代码是在查询消息中的功能代码的回应。数据段包括了从设备收集的数据，例如寄存器值或状态。如果有错误发生，功能代码将被修改以用于指出回应消息是错误的，同时数据段包含了描述此错误信息的代码。错误检测域允许主设备确认消息内容是否可用。

### ModBus传输方式

&emsp;&emsp;在`ModBus`系统中有`2`种传输模式可选择。这`2`种传输模式与从机`PC`通信的能力是同等的。选择时应视所用`ModBus`主机而定，每个`ModBus`系统只能使用一种模式，不允许`2`种模式混用。一种模式是`ASCII`(美国信息交换码)，另一种模式是`RTU`(远程终端设备)。
&emsp;&emsp;用户选择想要的模式，包括串口通信参数(波特率、校验方式等)，在配置每个控制器的时候，在一个`Modbus`网络上的所有设备都必须选择相同的传输模式和串口参数。所选的`ASCII`或`RTU`方式仅适用于标准的`Modbus`网络，它定义了在这些网络上连续传输的消息段的每一位，以及决定怎样将信息打包成消息域和如何解码。在其它网络上(像`MAP`和`Modbus Plus`)`Modbus`消息被转成与串行传输无关的帧。

### 传输模式特性

&emsp;&emsp;`ASCII`可打印字符便于故障检测，而且对于用高级语言(如`Fortran`)编程的主计算机及主`PC`很适宜。`RTU`则适用于机器语言编程的计算机和`PC`主机。
&emsp;&emsp;用`RTU`模式传输的数据是`8`位二进制字符。如欲转换为`ASCII`模式，则每个`RTU`字符首先应分为高位和低位两部分，这两部分各含`4`位，然后转换成十六进制等量值。用以构成报文的`ASCII`字符都是十六进制字符。`ASCII`模式使用的字符虽是`RTU`模式的`2`倍，但`ASCII`数据的译码和处理更为容易一些。此外，用`RTU`模式时报文字符必须以连续数据流的形式传送；用`ASCII`模式，字符之间可产生长达`1s`的间隔，以适应速度较慢的机器。
&emsp;&emsp;控制器能设置为两种传输模式(`ASCII`或`RTU`)中的任何一种在标准的`Modbus`网络通信。

#### ASCII模式

&emsp;&emsp;当控制器设为在`Modbus`网络上以`ASCII`代模式通信，在消息中的每个`8Bit`字节都作为一个`ASCII`码(两个十六进制字符)发送。这种方式的主要优点是字符发送的时间间隔可达到`1`秒而不产生错误。代码系统如下：

- 十六进制，`ASCII`字符`0`至`9`，`A`至`F`。
- 消息中的每个`ASCII`字符都是一个十六进制字符组成。

&emsp;&emsp;每个字节的位：

- `1`个起始位。
- `7`个数据位，最小的有效位先发送。
- `1`个奇偶校验位，无校验则无。
- `1`个停止位(有校验时)，`2`个`Bit`(无校验时)。

&emsp;&emsp;错误检测域：

- `LRC`(纵向冗长检测)。

#### RTU模式

&emsp;&emsp;当控制器设为在`Modbus`网络上以`RTU`(远程终端单元)模式通信，在消息中的每个`8Bit`字节包含两个`4Bit`的十六进制字符。这种方式的主要优点是：在同样的波特率下，可比`ASCII`方式传送更多的数据。代码系统如下：

- `8`位二进制，十六进制数`0`至`9`，`A`至`F`。
- 消息中的每个`8`位域都是一或两个十六进制字符组成。

&emsp;&emsp;每个字节的位：

- `1`个起始位。
- `8`个数据位，最小的有效位先发送。
- `1`个奇偶校验位，无校验则无。
- `1`个停止位(有校验时)，`2`个`Bit`(无校验时)。

### ModBus数据校验方式

#### CRC

&emsp;&emsp;`CRC`校验方法如下：

```cpp
#include "stdio.h"

#define uint8  unsigned char
#define uint16 unsigned short

const uint8 auchCRCHi[] = { /* CRC高位字节值表 */
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
};

const uint8 auchCRCLo[] = { /* CRC低位字节值表 */
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
    0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
    0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
    0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
    0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
    0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
    0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
    0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
    0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
    0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
    0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
    0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
    0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
    0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

/* puchMsg为要进行CRC校验的消息，usDataLen为消息中字节数 */
uint16 crc16 ( uint8* puchMsg, uint16 usDataLen ) {
    uint8 uchCRCHi = 0xFF; /* 高CRC字节初始化 */
    uint8 uchCRCLo = 0xFF; /* 低CRC字节初始化 */
    uint16 uIndex; /* CRC循环中的索引 */

    while ( usDataLen-- ) { /* 传输消息缓冲区 */
        uIndex = uchCRCHi ^ *puchMsg++; /* 计算CRC */
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
        uchCRCLo = auchCRCLo[uIndex];
    }

    return ( uchCRCLo << 8 | uchCRCHi );
}

int main() { /* 校验“01 03 04 00 00 00 00 FA 33” */
    uint8 test[] = {1, 3, 4, 0, 0, 0, 0};
    uint16 result =  crc16 ( test, 7 );
    printf ( "result is %x\r\n", result );
}
```

#### LRC

&emsp;&emsp;`LRC`错误校验用于`ASCII`模式。这个错误校验是一个`8`位二进制数，可作为`2`个`ASCII`十六进制字节传送。把十六进制字符转换成二进制，加上无循环进位的二进制字符和二进制补码结果生成`LRC`错误校验。这个`LRC`在接收设备进行核验，并与被传送的LRC进行比较，冒号`:`、回车符号`CR`、换行字符`LF`和置入的其他任何非`ASCII`十六进制字符在运算时忽略不计。