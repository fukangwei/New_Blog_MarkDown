---
title: 目录操作函数
categories: Linux系统编程
date: 2019-02-03 11:35:33
---
&emsp;&emsp;`opendir`函数原型如下：<!--more-->

``` cpp
#include <sys/types.h>
#include <dirent.h>
DIR *opendir ( const char *path );
```

获取`path`目录下的所有文件和目录的列表，如果`path`是个文件，则返回值为`NULL`。
&emsp;&emsp;`DIR`结构体的原型为`struct _dirstream`：

``` cpp
typedef struct __dirstream DIR;

struct __dirstream {
    void *__fd;                     /* 'struct hurd_fd' pointer for descriptor */
    char *__data;                   /* Directory block                         */
    int __entry_data;               /* Entry number '__data' corresponds to    */
    char *__ptr;                    /* Current pointer into the block          */
    int __entry_ptr;                /* Entry number '__ptr' corresponds to     */
    size_t __allocation;            /* Space allocated for the block           */
    size_t __size;                  /* Total valid data in the block           */
    __libc_lock_define ( , __lock ) /* Mutex lock for this structure           */
};
```

&emsp;&emsp;`readdir`函数原型如下：

``` cpp
#include <dirent.h>
struct dirent *readdir ( DIR *dir_handle );
```

该函数返回参数`dir_handle`目录流的下个目录进入点。如果发生错误或者达到目录尾，函数则返回`NULL`。如果在`readdir`函数扫描目录的时候，还有其他进程在该目录里创建或删除文件，`readdir`不保证能够列出该目录里的所有文件和目录。`dirent`结构体成员如下：

``` cpp
struct dirent {
    long d_ino;                 /* inode number 索引节点号                        */
    off_t d_off;                /* offset to this dirent 在目录文件中的偏移        */
    unsigned short d_reclen;    /* length of this d_name 文件名长                 */
    unsigned char d_type;       /* the type of d_name 文件类型                    */
    char d_name [NAME_MAX + 1]; /* file name (null-terminated) 文件名，最长255字符 */
}
```

&emsp;&emsp;`closedir`函数原型如下：

``` cpp
#include <sys/types.h>
#include <dirent.h>
int closedir ( DIR *dir );
```

`closedir`函数关闭与指针`dir`相联系的目录流，关闭后，目录流描述符`dir`不再可用。成功时返回`0`，失败时返回`-1`，并设置相应的错误代码`errno`。
&emsp;&emsp;`chdir`和`fchdir`函数原型如下：

``` cpp
#include <unistd.h>
int chdir ( const char *path );
int fchdir ( int fd );
```

`chdir`函数改变当前工作目录为`path`指定的目录；`fchdir`函数与`chdir`功能一样，唯一的区别是`fchdir`所要改变成的工作目录由打开的文件描述符指定。成功时返回`0`，失败时返回`-1`，并设置相应的错误代码`errno`。
&emsp;&emsp;`telldir`函数原型如下：

``` cpp
#include <dirent.h>
off_t telldir ( DIR *dir );
```

`telldir`返回参数`dir`目录流目前的读取位置。此返回值代表距离目录文件开头的偏移量返回值返回下个读取位置，有错误发生时返回`-1`。错误代码为`EBADF`表示参数`dir`为无效的目录流。

``` cpp
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include "stdio.h"

int main() {
    DIR *dir;
    struct dirent *ptr;
    int offset;
    dir = opendir ( "/home" );

    while ( ( ptr = readdir ( dir ) ) != NULL ) {
        offset = telldir ( dir );
        printf ( "d_name: %s offset: %d\n", ptr->d_name, offset );
    }

    closedir ( dir );
}
```

执行结果：

``` cpp
d_name: . offset: -511331578
d_name: fuxinzi offset: 134193159
d_name: .. offset: -1
```

&emsp;&emsp;`seekdir`函数原型如下：

``` cpp
#include <dirent.h>
void seekdir ( DIR *dir, off_t offset );
```

`seekdir`用来设置参数`dir`目录流目前的读取位置，在调用`readdir`时便从此新位置开始读取，参数`offset`代表距离目录文件开头的偏移量。错误代码为`EBADF`表示参数`dir`为无效的目录流。

``` cpp
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include "stdio.h"

int main() {
    DIR *dir;
    struct dirent *ptr;
    int offset, offset_5, i = 0;
    dir = opendir ( "/dev" );

    while ( ( ptr = readdir ( dir ) ) != NULL ) {
        offset = telldir ( dir );

        if ( ++i == 5 ) {
            offset_5 = offset;
        }

        printf ( "d_name: %s offset: %d\n", ptr->d_name, offset );
    }

    seekdir ( dir, offset_5 );
    printf ( "Readdir again!\n" );

    while ( ( ptr = readdir ( dir ) ) != NULL ) {
        offset = telldir ( dir );
        printf ( "d_name: %s offset: %d\n", ptr->d_name, offset );
    }

    closedir ( dir );
}
```

&emsp;&emsp;在编写程序的时候，有时候需要得到当前路径。`C`库函数提供了`getcwd`来解决这个问题：

``` cpp
char *getcwd ( char *buffer, size_t size );
```

我们提供一个`size`大小的`buffer`，`getcwd`会把当前的路径名`copy`到`buffer`中。如果`buffer`太小，函数会返回`-1`。

``` cpp
#include<unistd.h>
#include "stdio.h"

int main() {
    char buf[80];
    getcwd ( buf, sizeof ( buf ) );
    printf ( "current working directory : %s\n", buf );
    return 0;
}
```

&emsp;&emsp;创建新目录的函数是`mkdir`：

``` cpp
#include <sys/stat.h>
int mkdir ( char *dir, int mode );
```

返回值为`0`表示成功，`-1`表示出错。
&emsp;&emsp;简易目录扫描程序如下：

``` cpp
#include "stdio.h"
#include "unistd.h"
#include "dirent.h"
#include "string.h"
#include "sys/stat.h"
#include "stdlib.h"

void printdir ( char *dir, int depth ) {
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;

    if ( ( dp = opendir ( dir ) ) == NULL ) {
        fprintf ( stderr, "can not open directory: %s\n", dir );
        return ;
    }

    chdir ( dir );

    while ( ( entry = readdir ( dp ) ) != NULL ) {
        lstat ( entry->d_name, &statbuf );

        if ( S_ISDIR ( statbuf.st_mode ) ) {
            if ( strcmp ( ".", entry->d_name ) == 0 || strcmp ( "..", entry->d_name ) == 0 ) {
                continue;
            }

            printf ( "%*s%s/\n", depth, " ", entry->d_name );
            printdir ( entry->d_name, depth + 4 );
        } else {
            printf ( "%*s%s\n", depth, " ", entry->d_name );
        }
    }

    chdir ( ".." );
    closedir ( dp );
}

int main ( int argc , char *argv[] ) {
    char *topdir = ".";

    if ( argc >= 2 ) {
        topdir = argv[1];
    }

    printf ( "Directory scan of %s \n", topdir );
    printdir ( topdir, 0 );
    printf ( "done. \n" );
    exit ( 0 );
}
```