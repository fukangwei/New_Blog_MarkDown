---
title: 守护进程
categories: Linux系统编程
date: 2019-02-03 16:15:02
---
&emsp;&emsp;代码如下：<!--more-->

``` cpp
#include "unistd.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "stdlib.h"
#include "stdio.h"
#include "time.h"

void init_daemon ( void );

int main() {
    FILE *fp;
    time_t t;
    init_daemon();

    while ( 1 ) { /* 每隔2秒钟向test.log报告运行状态 */
        sleep ( 2 );

        if ( ( fp = fopen ( "test.log", "a" ) ) != NULL ) {
            t = time ( 0 );
            fprintf ( fp, "I am here at %s\n", asctime ( localtime ( &t ) ) );
            fclose ( fp );
        }
    }

    return 0;
}

void init_daemon ( void ) { /* 守护进程初始化函数 */
    int pid;
    int i;

    if ( pid = fork() ) { /* 是父进程，则结束父进程 */
        exit ( 0 );
    } else if ( pid < 0 ) { /* fork失败，退出 */
        exit ( -1 );
    }

    setsid(); /* 第一子进程成为新的会话组长和进程组长，并与控制终端分离 */

    if ( pid = fork() ) { /* 是第一子进程，则结束第一子进程 */
        exit ( 0 );
    } else if ( pid < 0 ) { /* fork失败，退出 */
        exit ( 1 );
    }

    /* 第二子进程不再是会话组长 */
    for ( i = 0; i < getdtablesize(); i++ ) { /* 关闭打开的文件描述符 */
        close ( i );
    }

    chdir ( "/tmp" ); /* 改变工作目录到/tmp */
    umask ( 0 ); /* 重设文件创建掩膜 */
    return;
}
```

程序运行后，查看`/tmp`目录下的`test.log`文件，会看到信息不断写进文件，直到守护进程被`kill`或内核重启。通过`ps -ef`命令能看到进程运行情况。

---

### 守护进程及其特性

&emsp;&emsp;守护进程最重要的特性是后台运行。守护进程必须与其运行前的环境隔离开来，这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程(特别是`shell`)中继承下来的。最后，守护进程的启动方式有其特殊之处。它可以在`Linux`系统启动时从启动脚本`/etc/rc.d`中启动，可以由作业规划进程`crond`启动，还可以由用户终端(通常是`shell`)执行。
&emsp;&emsp;总之，除了这些特殊性以外，守护进程与普通进程基本上没有什么区别。因此，编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。

### 守护进程的编程要点

&emsp;&emsp;前面讲过，不同`Unix`环境下守护进程的编程规则并不一致。所幸的是守护进程的编程原则其实都一样，区别在于具体的实现细节不同。这个原则就是要满足守护进程的特性。同时，`Linux`是基于`Syetem V`的`SVR4`并遵循`Posix`标准，实现起来与`BSD4`相比更方便。编程要点如下所示：
&emsp;&emsp;1. 在后台运行。为避免挂起，控制终端将`Daemon`放入后台执行。方法是在进程中调用`fork`使父进程终止，让`Daemon`在子进程中后台执行：

``` cpp
if ( pid = fork() ) { /* 是父进程，结束父进程，子进程继续 */
    exit ( 0 );
}
```

&emsp;&emsp;2. 脱离控制终端、登录会话和进程组。有必要先介绍一下`Linux`中的进程与控制终端、登录会话和进程组之间的关系：进程属于一个进程组，进程组号`GID`就是进程组长的进程号`PID`。登录会话可以包含多个进程组，这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端、登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第一点的基础上，调用`setsid`使进程成为会话组长。`setsid`函数用于创建一个新的会话，并担任该会话组的组长。
&emsp;&emsp;调用`setsid`有下面`3`个作用：让进程摆脱原会话的控制；让进程摆脱原进程组的控制；让进程摆脱原控制终端的控制。也就是说由于在调用了`fork`函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此这还不是真正意义上的独立开来，而`setsid`函数能够使进程完全独立出来，从而摆脱其他进程的控制。
&emsp;&emsp;注意，当进程是会话组长时，`setsid`调用失败，但第一点已经保证进程不是会话组长。`setsid`调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。
&emsp;&emsp;3. 禁止进程重新打开控制终端。现在进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：

``` cpp
if ( pid = fork() ) { /* 结束第一子进程，第二子进程继续(第二子进程不再是会话组长) */
    exit ( 0 );
}
```

很多读者就会问，为什么要创建两次进程呢？这是因为第二步结束后，进程创建了一个新的会话组，并成为会话组长，而会话组长可能获得控制终端。如果获得了控制终端，那么这个进程就不是守护进程了。所以添加了这几句代码，让进程失去会话组长的身份，从而没有获得控制终端的权限。
&emsp;&emsp;4. 关闭打开的文件描述符。同文件权限码一样，用`fork`函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。
&emsp;&emsp;在上面的第二步之后，守护进程已经与所属的控制终端失去了联系，因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法(如`printf`)输出的字符也不可能在终端上显示出来。所以文件描述符为`0`、`1`和`2`的`3`个文件已经失去了存在的价值，也应被关闭。通常按如下方式关闭文件描述符：

``` cpp
for ( i = 0; i < MAXFILE; i++ ) {
    close ( i );
}
```

&emsp;&emsp;5. 改变当前工作目录。使用`fork`创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统(如`/mnt/usb`)是不能卸载的，这对以后的使用会造成诸多的麻烦(比如系统由于某种原因要进入单用户模式)。因此，通常的做法是让`/`作为守护进程的当前工作目录，这样就可以避免上述的问题。当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如`/tmp`。改变工作目录的常见函数是`chdir`。
&emsp;&emsp;6. 重设文件创建掩模。进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除，使用语句`umask(0);`。
&emsp;&emsp;7. 处理`SIGCHLD`信号。处理`SIGCHLD`信号并不是必须的，但对于某些进程特别是服务器进程往往在请求到来时，生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程(`zombie`)从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在`Linux`下可以简单地将`SIGCHLD`信号的操作设为`SIG_IGN`。

``` cpp
signal ( SIGCHLD, SIG_IGN );
```

这样，内核在子进程结束时不会产生僵尸进程。这一点与`BSD4`不同，`BSD4`下必须显式等待子进程结束才能释放僵尸进程。因为`Linux`里的进程都属于一颗树，树的根结点是`linux`系统初始化结束阶段时启动的`init`进程，这个进程的`pid`是`1`，所有的其他进程都是它的子孙。除了`init`，任何进程一定有他的父进程，而父进程会负责分配(`fork`)、回收(`wait4`)它申请的进程资源。这个树状关系也比较健壮，当某个进程还在运行时，它的父进程却退出了，这个进程却没有成为孤儿进程，因为`linux`有一个机制，`init`进程会接管它，成为它的父进程。这也是守护进程的由来了，因为守护进程的其中一个要求就是希望`init`成为守护进程的父进程。
&emsp;&emsp;如果某个进程自身终止了，在调用`exit`清理完相关的内容文件等资源后，它就会进入`ZOMBIE`状态，它的父进程会调用`wait4`来回收这个`task_struct`。但是，如果父进程一直没有调用`wait4`去释放子进程的`task_struct`，问题就来了，这个`task_struct`谁来回收呢？永远没有人，除非父进程终止后，被`init`进程接管这个`ZOMBIE`进程，然后调用`wait4`来回收进程描述符。如果父进程一直在运行着，这个`ZOMBIE`会永远的占用系统资源，用`KILL`发任何信号量也不能释放它。这是很可怕的，因为服务器上可能会出现无数`ZOMBIE`进程导致机器挂掉。
&emsp;&emsp;8. 守护进程退出处理。当用户需要外部停止守护进程运行时，往往会使用`kill`命令停止该守护进程。所以，守护进程中需要编码来实现`kill`发出的`signal`信号处理，达到进程的正常退出。

``` cpp
signal ( SIGTERM, sigterm_handler );

void sigterm_handler ( int arg ) {
    _running = 0;
}
```

这样，一个简单的守护进程就建立起来了。