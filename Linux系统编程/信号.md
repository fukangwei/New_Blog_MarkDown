---
title: 信号
date: 2019-03-13 14:20:36
categories: Linux系统编程
---
### 信号通信

&emsp;&emsp;信号(`signal`)机制是`Unix`系统中最为古老的进程间通信机制，很多条件可以产生一个信号：

- 当用户按某些按键时，产生信号。
- 硬件异常产生信号：除数为`0`、无效的存储访问等等。这些情况通常由硬件检测到，将其通知内核，然后内核产生适当的信号通知进程，例如内核对正访问一个无效存储区的进程产生一个`SIGSEGV`信号。
- 进程用`kill`函数将信号发送给另一个进程。
- 用户可用`kill`命令将信号发送给其他进程。

### 信号类型

&emsp;&emsp;下面是几种常见的信号：

- `SIGHUP`：从终端上发出的结束信号。
- `SIGINT`：来自键盘的中断信号(`Ctrl-C`)。
- `SIGKILL`：该信号结束接收信号的进程。
- `SIGTERM`：`kill`命令发出的信号。
- `SIGCHLD`：标识子进程停止或结束的信号。
- `SIGSTOP`：来自键盘(`Ctrl-Z`)或调试程序的停止执行信号。
- `SIGQUIT`：来自键盘的退出信号(`Ctrl-\`)。
- `SIGFPE`：浮点异常信号(例如浮点运算溢出)。
- `SIGALRM`：进程的定时器到期，发送该信号。
- `SIGSEGV`：非法存储器访问，如访问不存在的内存单元。

### 信号处理

&emsp;&emsp;当某信号出现时，将按照下列`3`种方式中的一种进行处理：

- 忽略此信号：大多数信号都按照这种方式进行处理，但有两种信号却决不能被忽略，它们是`SIGKILL`和`SIGSTOP`。这两种信号不能被忽略的原因是：它们向超级用户提供了一种终止或停止进程的方法。
- 执行用户希望的动作：通知内核在某种信号发生时，调用一个用户函数。在用户函数中，执行用户希望的处理。
- 执行系统默认动作：对大多数信号的系统默认动作是终止该进程。

### 信号发送

&emsp;&emsp;发送信号的主要函数有`kill`和`raise`。它们的区别是：`Kill`既可以向自身发送信号，也可以向其他进程发送信号。与`kill`函数不同的是，`raise`函数是向进程自身发送信号。

``` cpp
#include <sys/types.h>
#include <signal.h>
int kill ( pid_t pid, int signo ); /* 向进程号为pid的参数发送signo信号 */
int raise ( int signo );
```

&emsp;&emsp;`kill`的`pid`参数有四种不同的情况：

- `pid > 0`：将信号发送给进程`ID`为`pid`的进程。
- `pid = 0`：将信号发送给同组的进程。
- `pid < 0`：将信号发送给其进程组`ID`等于`pid`绝对值的进程。
- `pid = -1`：将信号发送给所有进程(除了进程号最大的那个进程)。

&emsp;&emsp;`raise`函数的使用如下：

``` cpp
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/wait.h"
#include "stdlib.h"
​
int main() {
    pid_t pid;
​
    if ( ( pid = fork() ) < 0 ) {
        perror ( "fork" );
        exit ( 1 );
    }
​
    if ( pid == 0 ) {
        raise ( SIGSTOP );
        printf ( "child process exit.\n" );
        exit ( 0 );
    } else {
        printf ( "pid = %d\n", pid );
​
        if ( ( waitpid ( pid, NULL, WNOHANG ) ) == 0 ) {
            sleep ( 1 );
            kill ( pid, SIGKILL );
            printf ( "kill %d\n", pid );
        }
​
        exit ( 0 );
    }
}
```

### Alarm

&emsp;&emsp;使用`alarm`函数可以设置一个时间值(闹钟时间)，当所设置的时间到了时，产生`SIGALRM`信号。如果不捕捉此信号，则默认动作是终止该进程。

``` cpp
#include <unistd.h>
unsigned int alarm ( unsigned int seconds );
```

参数`seconds`为经过了指定的`seconds`秒后会产生信号`SIGALRM`。
&emsp;&emsp;每个进程只能有一个闹钟时间。如果在调用`alarm`时，以前已为该进程设置过闹钟时间，而且它还没有超时，以前登记的闹钟时间则被新值代换。如果有以前登记的尚未超过的闹钟时间，而这次`seconds`值是`0`，则表示取消以前的闹钟，其余留数仍作为函数的返回值。

``` cpp
#include "unistd.h"
#include "stdio.h"
#include "stdlib.h"
#include "signal.h"
​
void alarm_handler ( int sign_no ) {
    printf ( "Alarm handler launched\n" );
}
​
int main() {
    signal ( SIGALRM, alarm_handler );
    alarm ( 5 );
    pause();
    signal ( SIGALRM, SIG_DFL );
    alarm ( 2 );
    pause();
    return 0;
}
```

### Pause

&emsp;&emsp;`pause`函数使调用进程挂起直至捕捉到一个信号。

``` cpp
#include <unistd.h>
int pause ( void );
```

只有执行了一个信号处理函数后，挂起才结束。

### 信号的处理

&emsp;&emsp;当系统捕捉到某个信号时，可以忽略该信号或是使用指定的处理函数来处理该信号，或者使用系统默认的方式。信号处理的主要方法有两种，一种是使用简单的`signal`函数，另一种是使用信号集函数组。

### signal

``` cpp
#include <signal.h>
typedef void ( *sighandler_t ) ( int );
sighandler_t signal ( int signum, sighandler_t handler );
```

函数执行成功则返回处理函数指针，失败则返回`SIG_ERR`。`handler`可能的值是：

- `SIG_IGN`：忽略此信号。
- `SIG_DFL`：按系统默认方式处理。
- 信号处理函数名：使用该函数处理。

&emsp;&emsp;对信号进行处理：

``` cpp
#include "signal.h"
#include "stdio.h"
#include "stdlib.h"
​
void myfunc ( int sign_no ) {
    if ( sign_no == SIGINT ) {
        printf ( "I have get SIGINT\n" );
    } else if ( sign_no == SIGQUIT ) {
        printf ( "I have get SIGQUIT\n" );
    }
}

int main() {
    /* 为信号SIGINT和SIGQUIT注册信号处理函数，
       如果没有信号过来，则程序一直等在那个地方 */
    printf ( "Waiting for signal\n" );
    signal ( SIGINT,  myfunc );
    signal ( SIGQUIT,  myfunc );
    pause(); /* 等待信号过来 */
    return 0;
}
```

查看进程号命令`ps -aux`，发送`SIGQUIT`信号`kill -s SIGQUIT 进程号`。

### sigaction

&emsp;&emsp;`sigaction`函数的功能是用于改变进程接收到特定信号后的行为。`sigaction`检查或修改与指定信号相关联的处理动作，该函数取代了`signal`函数。因为`signal`函数在信号未决时接收信号可能出现问题，所以使用`sigaction`更安全。

``` cpp
int sigaction ( int sig, const struct sigaction *act, struct sigaction *oact );
```

- `sig`：它是信号的值，可以为除了`SIGKILL`及`SIGSTOP`外的任何一个特定有效的信号(因为这两个信号定义了自己的处理函数，将导致信号安装错误)。
- `act`：它是指向`sigaction`一个实例的指针。在`sigaction`的实例中，指定了对特定信号的处理，可以为`NULL`，进程会以缺省方式对信号处理。
- `oact`：它指向的对象用来保存原来对相应信号的处理，可以为`NULL`。

函数执行成功返回`0`，失败则返回`-1`。函数关键部分是`sigaction`结构体：

``` cpp
struct sigaction {
    void ( * ) ( int ) sa_handle;
    sigset_t sa_mask;
    int sa_flags;
}
```

其成员变量说明如下所示：`sa_handler`字段包含一个信号捕捉函数的地址；`sa_mask`字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加进进程的信号屏蔽字中，仅当从信号捕捉函数返回时，再将进程的信号屏蔽字复位为原先值。`sa_flags`的取值如下表，取`0`表示选用所有默认选项：

- `SA_NOCLDSTOP`：用于表示信号`SIGCHLD`，当子进程被中断时，不产生此信号，当且仅当子进程结束时产生此信号。
- `SA_NOCLDWATI`：当信号为`SIGCHLD`时，可避免子进程僵死。
- `SA_NODEFER`：当信号处理函数正在进行时，不堵塞对于信号处理函数自身信号功能。
- `SA_NOMASK`：同`SA_NODEFER`。
- `SA_ONESHOT`：当用户注册的信号处理函数被执行过一次后，该信号的处理函数被设为系统默认的处理函数。
- `SA_RESETHAND`：同`SA_ONESHOT`。
- `SA_RESTART`：是本来不能重新于运行的系统调用自动重新运行。
- `SA_SIGINFO`：表明信号处理函数是由`SA_SIGACTION`指定的，而不是由`SA_HANDLER`指定的，它将显示更多的信号处理函数信息。

``` cpp
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
​
void show_handler ( int sig ) {
    printf ( "I got signal %d\n", sig );
    int i;
​
    for ( i = 0; i < 5; i++ ) {
        printf ( "i = %d\n", i );
        sleep ( 1 );
    }
}
​
int main ( void ) {
    int i = 0;
    struct sigaction act, oldact;

    act.sa_handler = show_handler;
    sigaddset ( &act.sa_mask, SIGQUIT );
    act.sa_flags = SA_RESETHAND | SA_NODEFER;
    sigaction ( SIGINT, &act, &oldact );
​
    while ( 1 ) {
        sleep ( 1 );
        printf ( "sleeping %d\n", i );
        i++;
    }
}
```

---

### linux信号集

&emsp;&emsp;信号集被定义为一种数据类型：

``` cpp
typedef struct {
    unsigned long sig[_NSIG_WORDS];
} sigset_t;
```

信号集用来描述信号的集合，每个信号占用一位。`Linux`所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。下面是为信号集操作定义的相关函数：

``` cpp
#include <signal.h>
/* 初始化由set指定的信号集，信号集里面的所有信号被清空，相当于64位置0 */
sigemptyset ( sigset_t *set );
/* 调用该函数后，set指向的信号集中将包含linux支持的64种信号，相当于64位都置1 */
sigfillset ( sigset_t *set );
/* 在set指向的信号集中加入signum信号，相当于将给定信号所对应的位置1 */
sigaddset ( sigset_t *set, int signum );
/* 在set指向的信号集中删除signum信号，相当于将给定信号所对应的位置0 */
sigdelset ( sigset_t *set, int signum );
/* 判定信号signum是否在set指向的信号集中，相当于检查给定信号所对应的位是0还是1 */
sigismember ( const sigset_t *set, int signum );
```

示例代码如下：

``` cpp
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
​
void print_sigset ( sigset_t *set );
​
int main ( void ) {
    sigset_t myset;

    sigemptyset ( &myset );
    sigaddset ( &myset, SIGINT );
    sigaddset ( &myset, SIGQUIT );
    sigaddset ( &myset, SIGUSR1 );
    sigaddset ( &myset, SIGRTMIN );
    print_sigset ( &myset );
    return 0;
}
​
void print_sigset ( sigset_t *set ) {
    int i;
​
    for ( i = 1; i < NSIG; ++i ) {
        if ( sigismember ( set, i ) ) {
            printf ( "1" );
        } else {
            printf ( "0" );
        }
    }
​
    putchar ( '\n' );
}
```

---

### 信号生命周期

&emsp;&emsp;对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个重要的阶段，这三个阶段由四个重要事件来刻画：信号诞生；信号在进程中注册完毕；信号在进程中的注销完毕；信号处理函数执行完毕。相邻两个事件的时间间隔构成信号生命周期的一个阶段。

<img src="./信号/1.png">

&emsp;&emsp;下面阐述四个事件的实际意义：

- 信号诞生。信号的诞生指的是触发信号的事件发生(如检测到硬件异常、定时器超时以及调用信号发送函数`kill`或`sigqueue`等)。
- 信号在目标进程中注册。进程的`task_struct`结构中有关于本进程中未决信号的数据成员：

``` cpp
struct sigpending pending;
​
struct sigpending {
    struct sigqueue *head, * *tail;
    sigset_t signal;
};
```

第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个`sigqueue`类型的结构链(称之为`未决信号信息链`)的首尾，信息链中的每个`sigqueue`结构刻画一个特定信号所携带的信息，并指向下一个`sigqueue`结构：

``` cpp
struct sigqueue {
    struct sigqueue *next;
    siginfo_t info;
}
```

信号在进程中注册指的就是信号值加入到进程的未决信号集中(`sigpending`结构的第二个成员`sigset_t signal`)，并且信号所携带的信息被保留到未决信号信息链的某个`sigqueue`结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞。
&emsp;&emsp;当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号不会丢失，实时信号又叫做`可靠信号`。这意味着同一个实时信号可以在同一个进程的未决信号信息链中占有多个`sigqueue`结构(进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，并把该结构添加在未决信号链尾，即所有诞生的实时信号都会在目标进程中注册)。
&emsp;&emsp;当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册，则该信号将被丢弃，造成信号丢失。因此，非实时信号又叫做`不可靠信号`。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个`sigqueue`结构(一个非实时信号诞生后：如果发现相同的信号已经在目标结构中注册，则不再注册，对于进程来说，相当于不知道本次信号发生，信号丢失；如果进程的未决信号中没有相同信号，则在进程中注册自己。

- 信号在进程中的注销。在目标进程执行过程中，会检测是否有信号等待处理(每次从系统空间返回到用户空间时都做这样的检查)。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。是否将信号从进程未决信号集中删除对于实时与非实时信号是不同的。对于非实时信号来说，由于在未决信号信息链中最多只占用一个`sigqueue`结构，因此该结构被释放后，应该把信号在进程未决信号集中删除(信号注销完毕)；而对于实时信号来说，可能在未决信号信息链中占用多个`sigqueue`结构，因此应该针对占用`sigqueue`结构的数目区别对待：如果只占用一个`sigqueue`结构(进程只收到该信号一次)，则应该把信号在进程的未决信号集中删除(信号注销完毕)。否则，不应该在进程的未决信号集中删除该信号(信号注销完毕)。进程在执行信号相应处理函数之前，首先要把信号在进程中注销。
- 信号生命终止。进程注销信号后，立即执行相应的信号处理函数，执行完毕后，信号的本次发送对进程的影响彻底结束。

&emsp;&emsp;注意如下事项：

- 信号注册与否，与发送信号的函数(如`kill`或`sigqueue`等)以及信号安装函数(`signal`及`sigaction`)无关，只与信号值有关(信号值小于`SIGRTMIN`的信号最多只注册一次，信号值在`SIGRTMIN`及`SIGRTMAX`之间的信号，只要被进程接收到就被注册)。
- 在信号被注销到相应的信号处理函数执行完毕这段时间内，如果进程又收到同一信号多次，则对实时信号来说，每一次都会在进程中注册；而对于非实时信号来说，无论收到多少次信号，都会视为只收到一个信号，只在进程中注册一次。

### 信号编程注意事项

&emsp;&emsp;1. 防止不该丢失的信号丢失。如果对信号生命周期理解深刻的话，很容易知道信号会不会丢失，以及在哪里丢失。
&emsp;&emsp;2. 程序的可移植性：考虑到程序的可移植性，应该尽量采用`POSIX`信号函数，`POSIX`信号函数主要分为两类：

- `POSIX 1003.1`信号函数：`kill`、`sigaction`、`sigaddset`、`sigdelset`、`sigemptyset`、`sigfillset`、`sigismember`、`sigpending`、`sigprocmask`、`sigsuspend`。
- `POSIX 1003.1b`信号函数：`POSIX 1003.1b`在信号的实时性方面对`POSIX 1003.1`做了扩展，包括以下三个函数：`sigqueue`、`sigtimedwait`、`sigwaitinfo`。其中，`sigqueue`主要针对信号发送，而`sigtimedwait`及`sigwaitinfo`主要用于取代`sigsuspend`函数。

``` cpp
#include <signal.h>
int sigwaitinfo ( sigset_t *set, siginfo_t *info );
```

该函数与`sigsuspend`类似，阻塞一个进程直到特定信号发生，但信号到来时不执行信号处理函数，而是返回信号值。因此为了避免执行相应的信号处理函数，必须在调用该函数前，使进程屏蔽掉`set`指向的信号，因此调用该函数的典型代码是：

``` cpp
sigset_t newmask;
int rcvd_sig;
siginfo_t info;

sigemptyset ( &newmask );
sigaddset ( &newmask, SIGRTMIN );
sigprocmask ( SIG_BLOCK, &newmask, NULL );
rcvd_sig = sigwaitinfo ( &newmask, &info );

if ( rcvd_sig == -1 ) {
    /* user code */
}
```

调用成功返回信号值，否则返回`-1`。`sigtimedwait`功能相似，只不过增加了一个进程等待的时间。
&emsp;&emsp;为了增强程序的稳定性，在信号处理函数中应使用可重入函数。信号处理程序中应当使用可再入(可重入)函数。因为进程在收到信号后，就将跳转到信号处理函数去接着执行。如果信号处理函数中使用了不可重入函数，那么信号处理函数可能会修改原来进程中不应该被修改的数据，这样进程从信号处理函数中返回接着执行时，可能会出现不可预料的后果。不可再入函数在信号处理函数中被视为不安全函数。满足下列条件的函数多数是不可再入的：

- 使用静态的数据结构，如`getlogin`、`gmtime`、`getgrgid`、`getgrnam`、`getpwuid`以及`getpwnam`等等。
- 函数实现时，调用了`malloc`或者`free`函数。
- 实现时使用了标准`I/O`函数的。

&emsp;&emsp;`The Open Group`视下列函数为可再入的：`_exit`、`access`、`alarm`、`cfgetispeed`、`cfgetospeed`、`cfsetispeed`、`cfsetospeed`、`chdir`、`chmod`、`chown`、`close`、`creat`、`dup`、`dup2`、`execle`、`execve`、`fcntl`、`fork`、`fpathconf`、`fstat`、`fsync`、`getegid`、`geteuid`、`getgid`、`getgroups`、`getpgrp`、`getpid`、`getppid`、`getuid`、`kill`、`link`、`lseek`、`mkdir`、`mkfifo`、`open`、`pathconf`、`pause`、`pipe`、`raise`、`read`、`rename`、`rmdir`、`setgid`、`setpgid`、`setsid`、`setuid`、`sigaction`、`sigaddset`、`sigdelset`、`sigemptyset`、`sigfillset`、`sigismember`、`signal`、`sigpending`、`sigprocmask`、`sigsuspend`、`sleep`、`stat`、`sysconf`、`tcdrain`、`tcflow`、`tcflush`、`tcgetattr`、`tcgetpgrp`、`tcsendbreak`、`tcsetattr`、`tcsetpgrp`、`time`、`times`、`umask`、`uname`、`unlink`、`utime`、`wait`、`waitpid`、`write`。
&emsp;&emsp;即使信号处理函数使用的都是`安全函数`，同样要注意进入处理函数时，首先要保存`errno`的值，结束时，再恢复原值。因为信号处理过程中，`errno`值随时可能被改变。另外，`longjmp`以及`siglongjmp`没有被列为可再入函数，因为不能保证紧接着两个函数的其它调用是安全的。

### 信号应用实例

&emsp;&emsp;`Linux`下的信号应用并没有想象的那么恐怖，程序员所要做的最多只有三件事情：

- 安装信号，推荐使用`sigaction`。
- 实现信号处理函数`handler(int signal, struct siginfo *info, void *)`。
- 发送信号，推荐使用`sigqueue`。

实际上，对有些信号来说，只要安装信号就足够了(信号处理方式采用缺省或忽略)。其他可能要做的无非是与信号集相关的几种操作。
&emsp;&emsp;1. 信号发送及处理：实现一个信号接收程序`sigreceive`，其中信号安装由`sigaction`实现：

``` cpp
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include "stdio.h"
#include "stdlib.h"
​
void new_op ( int, siginfo_t *, void * );
​
int main ( int argc, char **argv ) {
    struct sigaction act;
    int sig;
    sig = atoi ( argv[1] );
    sigemptyset ( &act.sa_mask );
    act.sa_flags = SA_SIGINFO;
    act.sa_sigaction = new_op;
​
    if ( sigaction ( sig, &act, NULL ) < 0 ) {
        printf ( "install sigal error\n" );
    }
​
    while ( 1 ) {
        sleep ( 2 );
        printf ( "wait for the signal\n" );
    }
}
​
void new_op ( int signum, siginfo_t *info, void *myact ) {
    printf ( "receive signal %d", signum );
    sleep ( 5 );
}
```

命令行参数为信号值，后台运行`sigreceive signo &`，可获得该进程的`ID`，假设为`pid`，然后在另一终端上运行`kill -s signo pid`验证信号的发送接收及处理。同时，可验证信号的排队问题。
&emsp;&emsp;2. 信号传递附加信息：主要包括两个实例：

- 向进程本身发送信号，并传递指针参数：

``` cpp
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
​
void new_op ( int, siginfo_t *, void * );
​
int main ( int argc, char **argv ) {
    struct sigaction act;
    union sigval mysigval;
    int i;
    int sig;
    pid_t pid;
    char data[10];
    memset ( data, 0, sizeof ( data ) );
​
    for ( i = 0; i < 5; i++ ) {
        data[i] = '2';
    }
​
    mysigval.sival_ptr = data;
    sig = atoi ( argv[1] );
    pid = getpid();
    sigemptyset ( &act.sa_mask );
    act.sa_sigaction = new_op; /* 三参数信号处理函数 */
    act.sa_flags = SA_SIGINFO; /* 信息传递开关 */
​
    if ( sigaction ( sig, &act, NULL ) < 0 ) {
        printf ( "install sigal error\n" );
    }
​
    while ( 1 ) {
        sleep ( 2 );
        printf ( "wait for the signal\n" );
        sigqueue ( pid, sig, mysigval ); /* 向本进程发送信号，并传递附加信息 */
    }
}
​
void new_op ( int signum, siginfo_t *info, void *myact ) { /* 三参数信号处理函数的实现 */
    int i;
​
    for ( i = 0; i < 10; i++ ) {
        printf ( "%c\n ", ( * ( ( char * ) ( ( *info ).si_ptr ) + i ) ) );
    }
​
    printf ( "handle signal %d over;", signum );
}
```

这个例子中，信号实现了附加信息的传递，信号究竟如何对这些信息进行处理则取决于具体的应用。

- 不同进程间传递整型参数：把`1`中的信号发送和接收放在两个程序中，并且在发送过程中传递整型参数。信号接收程序如下：

``` cpp
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include "stdio.h"
#include "stdlib.h"
​
void new_op ( int, siginfo_t *, void * );
​
int main ( int argc, char **argv ) {
    struct sigaction act;
    int sig;
    pid_t pid;
    pid = getpid();
    sig = atoi ( argv[1] );
    sigemptyset ( &act.sa_mask );
    act.sa_sigaction = new_op;
    act.sa_flags = SA_SIGINFO;
​
    if ( sigaction ( sig, &act, NULL ) < 0 ) {
        printf ( "install sigal error\n" );
    }
​
    while ( 1 ) {
        sleep ( 2 );
        printf ( "wait for the signal\n" );
    }
}
​
void new_op ( int signum, siginfo_t *info, void *myact ) {
    printf ( "the int value is %d\n", info->si_int );
}
```

信号发送程序：命令行第二个参数为信号值，第三个参数为接收进程`ID`。

``` cpp
#include "stdio.h"
#include "stdlib.h"
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/types.h>
​
int main ( int argc, char **argv ) {
    pid_t pid;
    int signum;
    union sigval mysigval;
    signum = atoi ( argv[1] );
    pid = ( pid_t ) atoi ( argv[2] );
    mysigval.sival_int = 8; /* 不代表具体含义，只用于说明问题 */
​
    if ( sigqueue ( pid, signum, mysigval ) == -1 ) {
        printf ( "send error\n" );
    }
​
    sleep ( 2 );
}
```

实例`2`的两个例子侧重点在于用信号来传递信息，目前关于在`linux`下通过信号传递信息的实例非常少。
&emsp;&emsp;3. 信号阻塞及信号集操作：

``` cpp
#include "signal.h"
#include "unistd.h"
#include "stdlib.h"
#include "stdio.h"
​
static void my_op ( int );
​
int main() {
    sigset_t new_mask, old_mask, pending_mask;
    struct sigaction act;
    sigemptyset ( &act.sa_mask );
    act.sa_flags = SA_SIGINFO;
    act.sa_sigaction = ( void * ) my_op;
​
    if ( sigaction ( SIGRTMIN + 10, &act, NULL ) ) {
        printf ( "install signal SIGRTMIN+10 error\n" );
    }
​
    sigemptyset ( &new_mask );
    sigaddset ( &new_mask, SIGRTMIN + 10 );
​
    if ( sigprocmask ( SIG_BLOCK, &new_mask, &old_mask ) ) {
        printf ( "block signal SIGRTMIN+10 error\n" );
    }
​
    sleep ( 10 );
    printf ( "now begin to get pending mask and unblock SIGRTMIN+10\n" );
​
    if ( sigpending ( &pending_mask ) < 0 ) {
        printf ( "get pending mask error\n" );
    }
​
    if ( sigismember ( &pending_mask, SIGRTMIN + 10 ) ) {
        printf ( "signal SIGRTMIN+10 is pending\n" );
    }
​
    if ( sigprocmask ( SIG_SETMASK, &old_mask, NULL ) < 0 ) {
        printf ( "unblock signal error\n" );
    }
​
    printf ( "signal unblocked\n" );
    sleep ( 10 );
}
​
static void my_op ( int signum ) {
    printf ( "receive signal %d\n", signum );
}
```

编译该程序，并以后台方式运行。在另一终端向该进程发送信号(运行`kill -s 42 pid`，`SIGRTMIN + 10`为`42`)，查看结果可以看出几个关键函数的运行机制，信号集相关操作比较简单。
&emsp;&emsp;在上面几个实例中，使用了`printf`函数，只是作为诊断工具，`pringf`函数是不可重入的，不应在信号处理函数中使用。

---

### 司机售票员问题(signal)

&emsp;&emsp;创建子进程代表售票员，父进程代表司机，同步过程如下：

- 售票员捕捉`SIGINT`(代表开车)，发`SIGUSR1`给司机，司机打印`Let's gogogo!`。
- 售票员捕捉`SIGQUIT`(代表停车)，发`SIGUSR2`给司机，司机打印`Stop the bus!`。
- 司机捕捉`SIGTSTP`(代表车到总站)，发`SIGUSR1`给售票员，售票员打印`please get off the bus!`。

``` cpp
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "errno.h"
#include "signal.h"
#include "sys/types.h"
​
pid_t pid;
​
void driver_handler ( int signo );
void saler_handler ( int signo );
​
int main ( int argc, char *argv[] ) {
    if ( ( pid = fork() ) == -1 ) {
        perror ( "fork" );
        exit ( -1 );
    }
​
    if ( pid > 0 ) {
        signal ( SIGTSTP, driver_handler );
        signal ( SIGINT, SIG_IGN );
        signal ( SIGQUIT, SIG_IGN );
        signal ( SIGUSR1, driver_handler );
        signal ( SIGUSR2, driver_handler );
​
        while ( 1 );
    } else {
        signal ( SIGINT, saler_handler );
        signal ( SIGQUIT, saler_handler );
        signal ( SIGTSTP, SIG_IGN );
        signal ( SIGUSR1, saler_handler );
        signal ( SIGUSR2, SIG_IGN );
​
        while ( 1 );
    }
​
    return 0;
}
​
void driver_handler ( int signo ) {
    if ( signo == SIGUSR1 ) {
        printf ( "Let's gogogo!\n" );
    }
​
    if ( signo == SIGUSR2 ) {
        printf ( "Stop the bus!\n" );
    }
​
    if ( signo == SIGTSTP ) {
        kill ( pid, SIGUSR1 );
    }
}
​
void saler_handler ( int signo ) {
    pid_t ppid = getppid();
​
    if ( signo == SIGINT ) {
        kill ( ppid, SIGUSR1 );
    }
​
    if ( signo == SIGQUIT ) {
        kill ( ppid, SIGUSR2 );
    }
​
    if ( signo == SIGUSR1 ) {
        printf ( "please get off the bus!\n" );
        kill ( ppid, SIGKILL );
        exit ( 0 );
    }
}
```

---

### 双子进程signal

&emsp;&emsp;编写一段程序，使用系统调用`fork`创建两个子进程，再用系统调用`signal`让父进程捕捉键盘上来的中断信号(即`Ctrl+C`)。当捕捉到中断信号后，父进程用系统调用`kill`向两个子进程发出信号。子进程捕捉到父进程发来的信号后，分别输出下列信息后终止：

``` cpp
child process 1 is killed by parent!
child process 2 is killed by parent!
```

父进程等待两个子进程终止后，输出下列信息后终止：

``` cpp
parent process exit!
```

参考程序如下：

``` cpp
#include "stdio.h"
#include "signal.h"
#include "stdlib.h"
#include "unistd.h"
​
int wait_mask = 1;
void waiting ( void );
void stop ( int sign_no );
​
int main ( int argc, char *argv[] ) {
    int p1, p2;
    signal ( SIGINT, stop );
​
    while ( ( p1 = fork() ) == -1 );
​
    if ( p1 > 0 ) { /* 在父进程中 */
        while ( ( p2 = fork() ) == -1 );
​
        if ( p2 > 0 ) { /* 在父进程中 */
            wait_mask = 1;
            waiting();
            kill ( p1, 10 );
            kill ( p2, 12 );
            wait ( NULL );
            wait ( NULL );
            printf ( "parent process exit!\n" );
            exit ( 0 );
        } else { /* 在子进程2中 */
            wait_mask = 1;
            signal ( 12, stop );
            waiting();
            lockf ( 1, 1, 0 );
            printf ( "child process 2 is killed by parent!\n" );
            lockf ( 1, 0, 0 );
            exit ( 0 );
        }
    } else { /* 在子进程1中 */
        wait_mask = 1;
        signal ( 10, stop );
        waiting();
        lockf ( 1, 1, 0 );
        printf ( "child process 1 is killed by parent!\n" );
        lockf ( 1, 0, 0 );
        exit ( 0 );
    }
}
​
void waiting ( void ) {
    while ( wait_mask != 0 );
}
​
void stop ( int sign_no ) {
    wait_mask = 0;
}
```

---

### 双进程信号通信示例

&emsp;&emsp;`Aprocess.c`如下：

``` cpp
#include "sys/types.h"
#include "signal.h"
#include "stdio.h"
​
/* 程序执行用“./Aprocess B进程pid” */
int main ( int argc, char *argv[] ) {
    pid_t pid;
    pid = atoi ( argv[1] );
    kill ( pid, SIGINT );
    return 0;
}
```

`Bprocess.c`如下：

``` cpp
#include "signal.h"
#include "unistd.h"
#include "stdio.h"
​
/*程序执行后用“kill -n SIGINT 进程pid”来发送信号*/
void myfunc ( int s ) {
    printf ( "Prosess B receieve SIGINT\n" );
}
​
int main() {
    signal ( SIGINT, myfunc );
    pause();
    return 0;
}
```

---

### Linux信号种类

&emsp;&emsp;可以从两个不同的分类角度对信号进行分类：可靠性方面：可靠信号与不可靠信号；与时间的关系上：实时信号与非实时信号。

#### 不可靠信号

&emsp;&emsp;`Linux`信号机制基本上是从`Unix`系统中继承过来的。早期`Unix`系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此把那些建立在早期机制上的信号叫做`不可靠信号`，信号值小于`SIGRTMIN`(`Red hat 7.2`中，`SIGRTMIN`为`32`，`SIGRTMAX`为`63`)的信号都是不可靠信号。这就是“不可靠信号”的来源，它的主要问题是：

- 进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用`signal`，重新安装该信号。
- 信号可能丢失，后面将对此详细阐述。如果在进程对某个信号进行处理时，这个信号发生多次，对后到来的这类信号不排队，那么仅传送该信号一次，即发生了信号丢失。

&emsp;&emsp;因此，早期`unix`下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。`Linux`支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数(信号安装函数是在可靠机制上的实现)。因此，`Linux`下的不可靠信号问题主要指的是信号可能丢失。

#### 可靠信号

&emsp;&emsp;随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种`Unix`版本分别在这方面进行了研究，力图实现`可靠信号`。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。同时，信号的发送和安装也出现了新版本：信号发送函数`sigqueue`及信号安装函数`sigaction`。`POSIX.4`对可靠信号机制做了标准化。但是，`POSIX`只对可靠信号机制应具有的功能以及信号机制的对外接口做了标准化，对信号机制的实现没有作具体的规定。
&emsp;&emsp;信号值位于`SIGRTMIN`和`SIGRTMAX`之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。`Linux`在支持新版本的信号安装函数`sigation`以及信号发送函数`sigqueue`的同时，仍然支持早期的`signal`信号安装函数，支持信号发送函数`kill`。
&emsp;&emsp;不要有这样的误解：由`sigqueue`发送、`sigaction`安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号(信号值位于`SIGRTMIN`及`SIGRTMAX`之间)；不可靠信号是信号值小于`SIGRTMIN`的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前`linux`中的`signal`是通过`sigation`函数实现的，因此，即使通过`signal`安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由`signal`安装的实时信号支持排队，同样不会丢失。
&emsp;&emsp;对于目前`linux`的两个信号安装函数`signal`及`sigaction`来说，它们都不能把`SIGRTMIN`以前的信号变成可靠信号(都不支持排队，仍有可能丢失，仍然是不可靠信号)，而且对`SIGRTMIN`以后的信号都支持排队。这两个函数的最大区别在于，经过`sigaction`安装的信号都能传递信息给信号处理函数(对所有信号这一点都成立)，而经过`signal`安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。

#### 实时信号与非实时信号

&emsp;&emsp;早期`Unix`系统只定义了`32`种信号，`Red hat 7.2`支持`64`种信号，编号为`0`至`63`(`SIGRTMIN`为`31`，`SIGRTMAX`为`63`)，将来可能进一步增加，这需要得到内核的支持。前`32`种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的`CTRL + C`时，会产生`SIGINT`信号，对该信号的默认反应就是进程终止。后`32`个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。
&emsp;&emsp;实时信号是`POSIX`标准的一部分，可用于应用进程。非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。

---

### signal(SIGHUP, SIG_IGN)的含义

&emsp;&emsp;`signal`信号函数第一个参数表示需要处理的信号值(`SIGHUP`)，第二个参数为处理函数或者是一个表示。这里，`SIG_IGN`表示忽略`SIGHUP`那个注册的信号。
&emsp;&emsp;`SIGHUP`和控制台操作有关。当控制台被关闭时，系统会向拥有控制台`sessionID`的所有进程发送`HUP`信号，默认`HUP`信号的`action`是`exit`。如果远程登陆启动某个服务进程并在程序运行时关闭连接的话，会导致服务进程退出，所以一般服务进程都会用`nohup`工具启动或写成一个`daemon`。

---

### SIGKILL和SIGSTOP的区别

&emsp;&emsp;`SIGKILL`提供给管理员杀死进程的权利，`SIGSTOP`提供给管理员暂停进程的权利，所以这两个信号不能被忽略和重定义。`Kill`父进程后，子进程的父进程号为`1`；但是`stop`父进程后，子进程的父进程号还是该父进程。

### SIGSTOP和SIGTSTP的区别

&emsp;&emsp;`SIGSTOP`提供给管理员暂停进程的特权，所以不能忽略和重定义。当用户按下`CTRL+Z`时，向前台进程组发送`SIGTSTP`信号以暂停进程(默认动作)，该信号可以被忽略和重定义。另外用户在控制终端上输入`CTRL+S`可以暂停进程的输出，输入`CTRL+Q`可以恢复进程的输出。