---
title: 网络编程
date: 2018-12-27 14:13:24
categories: Java
---
&emsp;&emsp;`java.net`包中提供了`UDP`和`TCP`这两种常见的网络协议的支持。

### Socket编程

&emsp;&emsp;套接字使用`TCP`提供了两台计算机之间的通信机制。客户端程序创建一个套接字，并尝试连接服务器的套接字。当连接建立时，服务器会创建一个`Socket`对象。客户端和服务器现在可以通过对`Socket`对象的写入和读取来进行通信。
&emsp;&emsp;`java.net.Socket`类代表一个套接字，并且`java.net.ServerSocket`类为服务器程序提供了一种来监听客户端，并与它们建立连接的机制。
&emsp;&emsp;以下步骤在两台计算机之间使用套接字建立`TCP`连接时会出现：

- 服务器实例化一个`ServerSocket`对象，表示通过服务器上的端口通信。
- 服务器调用`ServerSocket`类的`accept`方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。
- 服务器正在等待时，一个客户端实例化一个`Socket`对象，指定服务器名称和端口号来请求连接。
- `Socket`类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个`Socket`对象能够与服务器进行通信。
- 在服务器端，`accept`方法返回服务器上一个新的`socket`引用，该`socket`连接到客户端的`socket`。

连接建立后，通过使用`I/O`流来进行通信，每一个`socket`都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。`TCP`是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送。

### ServerSocket类的方法

&emsp;&emsp;服务器应用程序通过使用`java.net.ServerSocket`类以获取一个端口，并且侦听客户端请求。
&emsp;&emsp;`ServerSocket`类有四个构造方法：

- `public ServerSocket(int port) throws IOException`：创建绑定到特定端口的服务器套接字。
- `public ServerSocket(int port, int backlog) throws IOException`：利用指定的`backlog`创建服务器套接字，并将其绑定到指定的本地端口号。
- `public ServerSocket(int port, int backlog, InetAddress address) throws IOException`：使用指定的端口、侦听`backlog`和要绑定到的本地`IP`地址创建服务器。
- `public ServerSocket() throws IOException`：创建非绑定服务器套接字。

如果`ServerSocket`构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。这里有一些`ServerSocket`类的常用方法：

- `public int getLocalPort()`：返回此套接字在其上侦听的端口。
- `public Socket accept() throws IOException`：侦听并接收到此套接字的连接。
- `public void setSoTimeout(int timeout)`：启用/禁用带有指定超时值的`SO_TIMEOUT`，以毫秒为单位。将此选项设为非零的超时值时，在与此`Socket`关联的`InputStream`上调用`read`，将只阻塞此时间长度。
- `public void bind(SocketAddress host, int backlog)`：将`ServerSocket`绑定到特定地址(`IP`地址和端口号)。

### Socket类的方法

&emsp;&emsp;`java.net.Socket`类代表客户端和服务器都用来互相沟通的套接字。客户端要通过实例化获取一个`Socket`对象，而服务器则通过`accept`方法的返回值获得一个`Socket`对象。`Socket`类有五个构造方法：

- `public Socket(String host, int port) throws UnknownHostException, IOException`：创建一个流套接字，并将其连接到指定主机上的指定端口号。
- `public Socket(InetAddress host, int port) throws IOException`：创建一个流套接字，并将其连接到指定`IP`地址的指定端口号。
- `public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException`：创建一个套接字，并将其连接到指定远程主机上的指定远程端口。
- `public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException`：创建一个套接字，并将其连接到指定远程地址上的指定远程端口。
- `public Socket()`：通过系统默认类型的`SocketImpl`创建未连接套接字。

当`Socket`构造方法返回时，并没有简单的实例化了一个`Socket`对象，它实际上会尝试连接到指定的服务器和端口。下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个`Socket`对象，所以无论客户端还是服务端都能够调用这些方法：

- `public void connect(SocketAddress host, int timeout) throws IOException`：将此套接字连接到服务器，并指定一个超时值。
- `public InetAddress getInetAddress()`：返回套接字连接的地址。
- `public int getPort()`：返回此套接字连接到的远程端口。
- `public int getLocalPort()`：返回此套接字绑定到的本地端口。
- `public SocketAddress getRemoteSocketAddress()`：返回此套接字连接的端点的地址，如果未连接则返回`null`。
- `public InputStream getInputStream() throws IOException`：返回此套接字的输入流。
- `public OutputStream getOutputStream() throws IOException`：返回此套接字的输出流。
- `public void close() throws IOException`：关闭此套接字。
- `public boolean isInputShutdown()`：返回是否关闭套接字连接的半读状态(`read-half`)。
- `public boolean isOutputShutdown()`：返回是否关闭套接字连接的半写状态(`write-half`)。

### InetAddress类的方法

&emsp;&emsp;这个类表示互联网协议(`IP`)地址，下面列出了`Socket`编程时比较有用的方法：

- `static InetAddress getByAddress(byte[] addr)`：在给定原始`IP`地址的情况下，返回`InetAddress`对象。
- `static InetAddress getByAddress(String host, byte[] addr)`：根据提供的主机名和`IP`地址创建`InetAddress`。
- `static InetAddress getByName(String host)`：在给定主机名的情况下确定主机的`IP`地址。
- `String getHostAddress()`：返回`IP`地址字符串(以文本表现形式)。
- `String getHostName()`：获取此`IP`地址的主机名。
- `static InetAddress getLocalHost()`：返回本地主机。
- `String toString()`：将此IP地址转换为`String`。

### Socket客户端实例

&emsp;&emsp;如下的`GreetingClient`是一个客户端程序，该程序通过`socket`连接到服务器并发送一个请求，然后等待一个响应：

``` java
import java.net.*;
import java.io.*;
​
public class GreetingClient {
    public static void main(String[] args) {
        String serverName = "localhost";
        int port = Integer.parseInt("6666");

        try {
            System.out.println("连接到主机：" + serverName + "，端口号：" + port);
            Socket client = new Socket(serverName, port);
            System.out.println("远程主机地址：" + client.getRemoteSocketAddress());
            OutputStream outToServer = client.getOutputStream();
            DataOutputStream out = new DataOutputStream(outToServer);
​
            out.writeUTF("Hello from " + client.getLocalSocketAddress());
            InputStream inFromServer = client.getInputStream();
            DataInputStream in = new DataInputStream(inFromServer);
            System.out.println("服务器响应：" + in.readUTF());
            client.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Socket服务端实例

&emsp;&emsp;如下的`GreetingServer`程序是一个服务器端应用程序，使用`Socket`来监听一个指定的端口：

``` java
import java.net.*;
import java.io.*;
​
public class GreetingServer extends Thread {
    private ServerSocket serverSocket;
​
    public GreetingServer(int port) throws IOException {
        serverSocket = new ServerSocket(port);
        serverSocket.setSoTimeout(10000);
    }
​
    public void run() {
        while (true) {
            try {
                System.out.println("等待远程连接，端口号为：" + serverSocket.getLocalPort() + "...");
                Socket server = serverSocket.accept();
                System.out.println("远程主机地址：" + server.getRemoteSocketAddress());
                DataInputStream in = new DataInputStream(server.getInputStream());
                System.out.println(in.readUTF());
                DataOutputStream out = new DataOutputStream(server.getOutputStream());
                out.writeUTF("谢谢连接我：" + server.getLocalSocketAddress() + "\nGoodbye!");
                server.close();
            } catch (SocketTimeoutException s) {
                System.out.println("Socket timed out!");
                break;
            } catch (IOException e) {
                e.printStackTrace();
                break;
            }
        }
    }
​
    public static void main(String[] args) {
        int port = Integer.parseInt("6666");

        try {
            Thread t = new GreetingServer(port);
            t.run();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

执行结果(两个代码一起执行)：

``` bash
连接到主机：localhost，端口号：6666
远程主机地址：localhost/127.0.0.1:6666
服务器响应：谢谢连接我：/127.0.0.1:6666
Goodbye!
```

---

### UDP通信

#### DatagramSocket类

&emsp;&emsp;此类用于表示发送和接收数据报包的套接字。

- `DatagramSocket(int port)`：创建数据报套接字，并将其绑定到本地主机上的指定端口。
- `DatagramSocket(int port, InetAddress laddr)`：创建数据报套接字，将其绑定到指定的本地地址。
- `receive(DatagramPacket p)`：从此套接字接收数据报包。
- `void send(DatagramPacket p)`：向此套接字发送数据报包。
- `bind(SocketAddress addr)`：将此`DatagramSocket`绑定到特定的地址和端口。
- `void close()`：关闭此数据报套接字。
- `void connect(InetAddress address, int port)`：连接到此套接字的远程地址。
- `void connect(SocketAddress addr)`：连接到此套接字的远程地址(`IP`地址和端口号)。
- `void disconnect()`：断开套接字的连接。
- `getInetAddress()`：返回此套接字连接的地址。
- `InetAddress getLocalAddress()`：获取套接字绑定的本地地址。

#### InetAddress类

&emsp;&emsp;`InetAddress`是一个用于表示计算机`IP`地址的类，而IP地址经常用`192.168.0.1`、`WWW.it315.org`等字符串格式表示。主要有`getByName`和`getHostAddress`方法。

#### DatagramPacket类

&emsp;&emsp;如果把`DatagramSocket`比作港口码头，那么`DatagramPacket`就是发送和接收数据的集装箱。

- `DatagramPacket(byte[] buf, int length)`：构造`DatagramPacket`，用来接收长度为`length`的包。
- `DatagramPacket(byte[] buf, int length, InetAddress address, int port)`：构造数据报文包，用来把长度为`length`的包传送到指定宿主的指定的端口号。
- `getAddress()`：返回接收或发送此数据报文的机器的IP地址。
- `getData()`：返回接收的数据或发送出的数据。
- `getLength()`：返回发送出的或接收到的数据的长度。
- `getPort()`：返回接收或发送该数据报文的远程主机端口号。

&emsp;&emsp;`UDP`客户端如下：

``` java
import java.net.*;
​
public class UdpSend {
    public static void main(String[] args) throws Exception {
        DatagramSocket ds = new DatagramSocket();
        String strInfo = "Hello World";
        byte[] send_buf = strInfo.getBytes();
        InetAddress address = InetAddress.getByName("192.168.1.108");
        int port = 9999;
        DatagramPacket packet = new DatagramPacket(send_buf, send_buf.length, address, port);
        ds.send(packet);
        ds.close();
    }
}
```

`UDP`服务器如下：

``` java
import java.net.*;
​
public class UdpRecv {
    public static void main(String[] args) throws Exception {
        DatagramSocket ds = new DatagramSocket(9999);
        byte[] buf = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buf, 1024);
        ds.receive(dp);
        String strInfo = new String(dp.getData(), 0, dp.getLength());
        strInfo += " from " + dp.getAddress().getHostAddress() + ":" + dp.getPort();
        System.out.println(strInfo);
        ds.close();
    }
}
```