---
title: 流和文件
date: 2018-12-21 21:07:12
categories: Java
---
&emsp;&emsp;`Java.io`几乎包含了所有操作输入、输出需要的类，所有这些类代表了输入源和输出目标。`Java.io`中的流支持很多种格式，比如基本类型、对象、本地化字符集等。一个流可以理解为一个数据的序列，输入流表示从一个源读取数据，输出流表示向一个目标写数据。`Java`为`I/O`提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。

### 读取控制台输入

&emsp;&emsp;`Java`的控制台输入由`System.in`完成。为了获得一个绑定到控制台的字符流，你可以把`System.in`包装在一个`BufferedReader`对象中来创建一个字符流。下面是创建`BufferedReader`的基本语法：

``` java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
```

`BufferedReader`对象创建后，我们便可以使用read方法从控制台读取一个字符，或者用`readLine`方法读取一个字符行。
&emsp;&emsp;`read`方法的语法格式如下：

``` java
int read() throws IOException
```

每次调用`read`方法，它从输入流读取一个字符并把该字符作为整数值返回。当流结束的时候返回`-1`，该方法会抛出`IOException`。
&emsp;&emsp;下面的程序示范了用`read`方法从控制台不断读取字符，直到用户输入`q`：

``` java
import java.io.*;
​
public class BRRead {
    public static void main(String args[]) throws IOException {
        char c;
        /* 使用System.in创建BufferedReader */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("输入字符, 按下“q”键退出。");
​
        do { /* 读取字符*/
            c = (char) br.read();
            System.out.println(c);
        } while (c != 'q');
    }
}
```

&emsp;&emsp;`readLine`方法的语法格式如下：

``` java
String readLine() throws IOException
```

下面的程序读取和显示字符行，直到你输入了单词`end`：

``` java
import java.io.*;
​
public class BRReadLines {
    public static void main(String args[]) throws IOException {
        /* 使用System.in创建BufferedReader */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        System.out.println("Enter lines of text.");
        System.out.println("Enter 'end' to quit.");

        do {
            str = br.readLine();
            System.out.println(str);
        } while (!str.equals("end"));
    }
}
```

### 控制台输出

&emsp;&emsp;控制台的输出由`print`和`println`完成，这些方法都由类`PrintStream`定义，`System.out`是该类对象的一个引用。`PrintStream`继承了`OutputStream`类，并且实现了方法`write`，这样`write`也可以用来往控制台写操作。`PrintStream`定义`write`的最简单格式如下，该方法将`byteval`的低八位字节写到流中：

``` java
void write(int byteval)
```

下面的例子用`write`把字符`A`和紧跟着的换行符输出到屏幕：

``` java
public class WriteDemo {
    public static void main(String args[]) {
        int b;
        b = 'A';
        System.out.write(b);
        System.out.write('\n');
    }
}
```

注意，`write`方法不经常使用，因为`print`和`println`方法用起来更为方便。

### 读写文件

#### FileInputStream

&emsp;&emsp;该流用于从文件读取数据，它的对象可以用关键字`new`来创建。有多种构造方法可用来创建对象：
&emsp;&emsp;可以使用字符串类型的文件名来创建一个输入流对象来读取文件：

``` java
InputStream f = new FileInputStream("C:/java/hello");
```

也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用`File`方法来创建一个文件对象：

``` java
File f = new File("C:/java/hello");
InputStream out = new FileInputStream(f);
```

创建了`InputStream`对象，就可以使用下面的方法来读取流或者进行其他的流操作：

- `public void close() throws IOException{}`：关闭此文件输入流并释放与此流有关的所有系统资源。该方法会抛出`IOException`异常。
- `protected void finalize() throws IOException{}`：这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其`close`方法。该方法会抛出`IOException`异常。
- `public int read(int r) throws IOException{}`：这个方法从`InputStream`对象读取指定字节的数据。返回一个整数值，即下一字节数据。如果已经到结尾，则返回`-1`。
- `public int read(byte[] r) throws IOException{}`：这个方法从输入流读取`r.length`长度的字节。返回读取的字节数。如果是文件结尾，则返回`-1`。
- `public int available() throws IOException{}`：返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。

#### FileOutputStream

&emsp;&emsp;该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。有两个构造方法可以用来创建`FileOutputStream`对象：
&emsp;&emsp;使用字符串类型的文件名来创建一个输出流对象：

``` java
OutputStream f = new FileOutputStream("C:/java/hello");
```

也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用`File`方法来创建一个文件对象：

``` java
File f = new File("C:/java/hello");
OutputStream f = new FileOutputStream(f);
```

创建`OutputStream`对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作：

- `public void close() throws IOException{}`：关闭此文件输入流并释放与此流有关的所有系统资源。该方法会抛出`IOException`异常。
- `protected void finalize() throws IOException{}`：这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其`close`方法。该方法会抛出`IOException`异常。
- `public void write(int w) throws IOException{}`：这个方法把指定的字节写到输出流中。
- `public void write(byte[] w)`：把指定数组中`w.length`长度的字节写到`OutputStream`中。

&emsp;&emsp;下面的代码演示`InputStream`和`OutputStream`的用法：

``` java
import java.io.*;
​
public class fileStreamTest {
    public static void main(String args[]) {
        try {
            byte bWrite[] = {'A', 'B', 'C', 'D', 'E'};
            OutputStream os = new FileOutputStream("test.txt");

            for (int x = 0; x < bWrite.length; x++) {
                os.write(bWrite[x]); /* writes the bytes */
            }

            os.close();
​
            InputStream is = new FileInputStream("test.txt");
            int size = is.available();
​
            for (int i = 0; i < size; i++) {
                System.out.print((char) is.read() + " ");
            }

            is.close();
        } catch (IOException e) {
            System.out.print("Exception");
        }
    }
}
```

以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：

``` java
import java.io.*;
​
public class fileStreamTest {
    public static void main(String[] args) throws IOException {
        File f = new File("a.txt");
        /* 构建FileOutputStream对象，文件不存在会自动新建 */
        FileOutputStream fop = new FileOutputStream(f);
        /* 构建OutputStreamWriter对象，参数可以指定编码，默认为操作系统默认编码 */
        OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8");
        writer.append("中文输入"); /* 写入到缓冲区 */
        writer.append("\r\n"); /* 换行 */
        writer.append("English");
        writer.close(); /* 关闭写入流，同时会把缓冲区内容写入文件 */
        fop.close(); /* 关闭输出流，释放系统资源 */
​
        FileInputStream fip = new FileInputStream(f); /* 构建FileInputStream对象 */
        /* 构建InputStreamReader对象，编码与写入相同 */
        InputStreamReader reader = new InputStreamReader(fip, "UTF-8");
        StringBuffer sb = new StringBuffer();
​
        while (reader.ready()) {
            sb.append((char) reader.read()); /* 转成char加到StringBuffer对象中 */
        }
​
        System.out.println(sb.toString());
        reader.close(); /* 关闭读取流 */
        fip.close(); /* 关闭输入流，释放系统资源 */
    }
}
```

&emsp;&emsp;`FileOutputStream`的另一个构造函数是：

``` java
public FileOutputStream(File file, boolean append) throws FileNotFoundException;
```

如果将`append`设置为`true`，则表示在文件的末尾追加内容。

``` java
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
​
public class Read {
    public static void main(String[] args) {
        try {
            /* 创建一个文件字节输出流对象 */
            FileOutputStream os = new FileOutputStream("io.txt", true); /* 追加方式 */
            String string = "hello IO Stream"; /* 写入的数据 */
            byte[] bytes = string.getBytes(); /* 转化为字节数组 */
            os.write(bytes); /* 全部写入 */
            os.close(); /* 关闭流 */
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 目录

#### 创建目录

&emsp;&emsp;`File`类中有两个方法可以用来创建文件夹：

- `mkdir`方法创建一个文件夹，成功则返回`true`，失败则返回`false`。失败表明`File`对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。
- `mkdirs`方法创建一个文件夹和它的所有父文件夹。

下面的例子在当前目录下创建`hello`文件夹：

``` java
import java.io.File;
​
public class CreateDir {
    public static void main(String args[]) {
        String dirname = "./hello";
        File d = new File(dirname);
        d.mkdirs(); /* 现在创建目录 */
    }
}
```

注意，`Java`在`UNIX`和`Windows`自动按约定分辨文件路径分隔符。如果你在`Windows`版本的`Java`中使用分隔符`/`，路径依然能够被正确解析。

#### 读取目录

&emsp;&emsp;一个目录其实就是一个`File`对象，它包含其他文件和文件夹。如果创建一个`File`对象并且它是一个目录，那么调用`isDirectory`方法会返回`true`。可以通过调用该对象上的`list`方法，来提取它包含的文件和文件夹的列表。下面的例子说明如何使用`list`方法来检查一个文件夹中包含的内容：

``` java
import java.io.File;
​
public class DirList {
    public static void main(String args[]) {
        String dirname = "./";
        File f1 = new File(dirname);

        if (f1.isDirectory()) {
            System.out.println("目录 " + dirname);
            String s[] = f1.list();

            for (int i = 0; i < s.length; i++) {
                File f = new File(dirname + "/" + s[i]);

                if (f.isDirectory()) {
                    System.out.println(s[i] + "是一个目录");
                } else {
                    System.out.println(s[i] + "是一个文件");
                }
            }
        } else {
            System.out.println(dirname + "不是一个目录");
        }
    }
}
```

执行结果：

``` bash
目录 ./
.idea是一个目录
a.txt是一个文件
hello是一个目录
lib是一个目录
out是一个目录
src是一个目录
test.txt是一个文件
untitled2.iml是一个文件
```

#### 删除目录或文件

&emsp;&emsp;删除文件可以使用`java.io.File.delete`方法。以下代码会删除一个目录，即便目录不为空：

``` java
import java.io.File;
​
public class DeleteFileDemo {
    public static void main(String args[]) {
        File folder = new File("./hello");
        deleteFolder(folder);
    }
​
    /* 删除文件及目录 */
    public static void deleteFolder(File folder) {
        File[] files = folder.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isDirectory()) {
                    deleteFolder(f);
                } else {
                    f.delete();
                }
            }
        }
        folder.delete();
    }
}
```

---

### File类

&emsp;&emsp;Java文件类以抽象的方式代表文件名和目录路径名，该类主要用于文件和目录的创建、文件的查找和文件的删除等。File对象代表磁盘中实际存在的文件和目录，可以通过以下构造方法创建一个File对象。

- 通过给定的父抽象路径名和子路径名字符串，创建一个新的File实例：

``` java
File(File parent, String child);
```

- 通过将给定路径名字符串转换成抽象路径名，创建一个新File实例：

``` java
File(String pathname);
```

- 根据parent路径名字符串和child路径名字符串，创建一个新File实例：

``` java
File(String parent, String child);
```

通过将给定的`file: URI`转换成一个抽象路径名，创建一个新的File实例：

``` java
File(URI uri);
```

&emsp;&emsp;创建File对象成功后，可以使用如下方法操作文件：

- `public String getName()`：返回由此抽象路径名表示的文件或目录的名称。
- `public String getParent()`：返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回null。
- `public File getParentFile()`：返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回null。
- `public String getPath()`：将此抽象路径名转换为一个路径名字符串。
- `public boolean isAbsolute()`：测试此抽象路径名是否为绝对路径名。
- `public String getAbsolutePath()`：返回抽象路径名的绝对路径名字符串。
- `public boolean canRead()`：测试应用程序是否可以读取此抽象路径名表示的文件。
- `public boolean canWrite()`：测试应用程序是否可以修改此抽象路径名表示的文件。
- `public boolean exists()`：测试此抽象路径名表示的文件或目录是否存在。
- `public boolean isDirectory()`：测试此抽象路径名表示的文件是否是一个目录。
- `public boolean isFile()`：测试此抽象路径名表示的文件是否是一个标准文件。
- `public long lastModified()`：返回此抽象路径名表示的文件最后一次被修改的时间。
- `public long length()`：返回由此抽象路径名表示的文件的长度。
- `public boolean createNewFile() throws IOException`：当且仅当不存在具有此抽象路径名指定名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。
- `public boolean delete()`：删除此抽象路径名表示的文件或目录。
- `public void deleteOnExit()`：在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。
- `public String[] list()`：返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。
- `public String[] list(FilenameFilter filter)`：返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。
- `public File[] listFiles()`：返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。
- `public File[] listFiles(FileFilter filter)`：返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。
- `public boolean mkdir()`：创建此抽象路径名指定的目录。
- `public boolean mkdirs()`：创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。
- `public boolean renameTo(File dest)`：重新命名此抽象路径名表示的文件。
- `public boolean setLastModified(long time)`：设置由此抽象路径名所指定的文件或目录的最后一次修改时间。
- `public boolean setReadOnly()`：标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。
- `public static File createTempFile(String prefix, String suffix, File directory) throws IOException`：在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。
- `public static File createTempFile(String prefix, String suffix) throws IOException`：在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。
- `public int compareTo(File pathname)`：按字母顺序比较两个抽象路径名。
- `public int compareTo(Object o)`：按字母顺序比较抽象路径名与给定对象。
- `public boolean equals(Object obj)`：测试此抽象路径名与给定对象是否相等。
- `public String toString()`：返回此抽象路径名的路径名字符串。

``` java
import java.io.File;
​
public class DirList {
    public static void main(String args[]) {
        String dirname = "/java";
        File f1 = new File(dirname);
        if (f1.isDirectory()) {
            System.out.println("Directory of " + dirname);
            String s[] = f1.list();
            for (int i = 0; i < s.length; i++) {
                File f = new File(dirname + "/" + s[i]);
                if (f.isDirectory()) {
                    System.out.println(s[i] + " is a directory");
                } else {
                    System.out.println(s[i] + " is a file");
                }
            }
        } else {
            System.out.println(dirname + " is not a directory");
        }
    }
}
```

执行结果：

``` bash
Directory of .
.idea is a directory
a.txt is a file
Hello1.txt is a file
lib is a directory
out is a directory
src is a directory
test.txt is a file
untitled2.iml is a file
```

---

### FileReader类

&emsp;&emsp;FileReader类从InputStreamReader类继承而来，该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。

- 在给定从中读取数据的File的情况下，创建一个新FileReader：

``` java
FileReader(File file);
```

- 在给定从中读取数据的FileDescriptor的情况下，创建一个新FileReader：

``` java
FileReader(FileDescriptor fd);
```

- 在给定从中读取数据的文件名的情况下，创建一个新FileReader：

``` java
FileReader(String fileName);
```

&emsp;&emsp;创建FIleReader对象成功后，可以使用如下方法操作文件：

- `public int read() throws IOException`：读取单个字符，返回一个int型变量代表读取到的字符。
- `public int read(char [] c, int offset, int len)`：读取字符到c数组，返回读取到字符的个数。

### FileWriter类

&emsp;&emsp;FileWriter类从OutputStreamWriter类继承而来，该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象：

- 在给出File对象的情况下构造一个FileWriter对象：

``` java
FileWriter(File file);
```

- 在给出File对象的情况下构造一个FileWriter对象，它具有指示是否挂起写入数据的boolean值：

``` java
FileWriter(File file, boolean append);
```

- 构造与某个文件描述符相关联的FileWriter对象：

``` java
FileWriter(FileDescriptor fd);
```

- 在给出文件名的情况下构造FileWriter对象，它具有指示是否挂起写入数据的boolean值：

``` java
FileWriter(String fileName, boolean append);
```

&emsp;&emsp;创建FileWriter对象成功后，可以使用如下方法操作文件：

- `public void write(int c) throws IOException`：写入单个字符c。
- `public void write(char [] c, int offset, int len)`：写入字符数组中开始为offset长度为len的某一部分。
- `public void write(String s, int offset, int len)`：写入字符串中开始为offset长度为len的某一部分。

``` java
import java.io.*;
​
public class FileRead {
    public static void main(String args[]) throws IOException {
        File file = new File("Hello1.txt");
        file.createNewFile(); /* 创建文件 */
        FileWriter writer = new FileWriter(file); /* 创建FileWriter对象 */
        writer.write("This\n is\n an\n example\n"); /* 向文件写入内容 */
        writer.flush();
        writer.close();
        FileReader fr = new FileReader(file); /* 创建FileReader对象 */
        char[] a = new char[50];
        fr.read(a); /* 读取内容值数组中 */
        for (char c : a)
            System.out.print(c); /* 一个个打印字符 */
        fr.close();
    }
}
```

执行结果：

``` bash
This
 is
 an
 example
```

---

### FileFilter筛选文件

&emsp;&emsp;创建了一个FileFilter类，此类根据文件名的扩展名是否为`.txt`来筛选文件。创建FileFilter实例之后，需要将此实例作为参数传给File的`listFiles(fileFilter)`方法，此方法会返回符合条件文件的数组：

``` java
import java.io.File;
import java.io.FileFilter;
​
public class FileUtil {
    public void myListFiles(String dir) {
        File directory = new File(dir);
​
        if (!directory.isDirectory()) {
            System.out.println("No directory provided");
            return;
        }
​
        File[] files = directory.listFiles(filefilter);
​
        for (File f : files) {
            System.out.println(f.getName());
        }
    }
​
    /* create a FileFilter and override its accept-method */
    FileFilter filefilter = new FileFilter() {
        public boolean accept(File file) {
            if (file.getName().endsWith(".txt")) { /* if the file extension is ".txt" return true, else false */
                return true;
            }
            return false;
        }
    };
​
    public static void main(String[] args) {
        FileUtil fileutil = new FileUtil();
        fileutil.myListFiles("C:\\\\python3.6");
    }
}
```

执行结果：

``` bash
LICENSE.txt
NEWS.txt
```

---

### BufferedInputStream类

&emsp;&emsp;`BufferedInputStream`是缓冲输入流，继承于`FilterInputStream`，作用是为另一个输入流添加一些功能，本质上是通过一个内部缓冲数组实现的。例如，在新建某输入流对应的`BufferedInputStream`后，当通过read读取数据时，`BufferedInputStream`会将输入流的数据分批地填入到缓冲区中，每当缓冲区的数据读完之后，输入流会再次填充数据缓冲区，直到读完数据。
&emsp;&emsp;BufferedInputStream主要的函数如下所示：

``` java
BufferedInputStream(InputStream in);
BufferedInputStream(InputStream in, int size);
synchronized int available();
void close();
synchronized void mark(int readlimit);
boolean markSupported();
synchronized int read();
synchronized int read(byte[] buffer, int offset, int byteCount);
synchronized void reset();
synchronized long skip(long byteCount);
```

代码示例如下：

``` java
import java.io.*;
​
public class BufferedInputStreamTest {
    static void readFromFile(String filename) { /* 从文件中读取文本 */
        BufferedInputStream bufferedInput = null;
        byte[] buffer = new byte[1024];
        try {
            /* 创建BufferedInputStream对象 */
            bufferedInput = new BufferedInputStream(new FileInputStream(filename));
            int bytesRead = 0;
            /* 从文件中按字节读取内容，到文件尾部时，read方法将返回“-1” */
            while ((bytesRead = bufferedInput.read(buffer)) != -1) {
                String chunk = new String(buffer, 0, bytesRead); /* 将读取的字节转为字符串对象 */
                System.out.print(chunk);
            }
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                if (bufferedInput != null)
                    bufferedInput.close(); /* 关闭BufferedInputStream */
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }
​
    public static void main(String[] args) {
        readFromFile("src/hello.txt");
    }
}
```

---

### ByteArrayOutputStream类

&emsp;&emsp;字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中。下面的构造方法创建一个32字节(默认大小)的缓冲区：

``` java
OutputStream bOut = new ByteArrayOutputStream();
```

另一个构造方法创建一个大小为n字节的缓冲区：

``` java
OutputStream bOut = new ByteArrayOutputStream(int a);
```

成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作：

- `public void reset()`：将此字节数组输出流的count字段重置为零，从而丢弃输出流中目前已累积的所有数据输出。
- `public byte[] toByteArray()`：创建一个新分配的字节数组。数组的大小相当于当前输出流的大小，内容是当前输出流的拷贝。
- `public String toString()`：将缓冲区的内容转换为字符串，根据平台的默认字符编码将字节转换成字符。
- `public void write(int w)`：将指定的字节写入此字节数组输出流。
- `public void write(byte []b, int off, int len)`：将指定字节数组中从偏移量off开始的len个字节写入此字节数组输出流。
- `public void writeTo(OutputStream outSt)`：将此字节数组输出流的全部内容写入到指定的输出流参数中。

### ByteArrayInputStream类

&emsp;&emsp;字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中。接收字节数组作为参数进行创建：

``` java
ByteArrayInputStream bArray = new ByteArrayInputStream(byte[] a);
```

另一种创建方式是接收一个字节数组，和两个整形变量off、len。off表示第一个读取的字节，len表示读取字节的长度：

``` java
ByteArrayInputStream bArray = new ByteArrayInputStream( byte[] a, int off, int len);
```

成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作：

- `public int read()`：从此输入流中读取下一个数据字节。
- `public int read(byte[] r, int off, int len)`：将最多len个数据字节从此输入流读入字节数组。
- `public int available()`：返回可不发生阻塞地从此输入流读取的字节数。
- `public void mark(int read)`：设置流中的当前标记位置。
- `public long skip(long n)`：从此输入流中跳过n个输入字节。

&emsp;&emsp;以下代码演示了ByteArrayInputStream和ByteArrayOutputStream的使用：

``` java
import java.io.*;
​
public class ByteStreamTest {
    public static void main(String args[]) throws IOException {
        ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12);
        while (bOutput.size() != 5) {
            bOutput.write(System.in.read()); /* 获取用户输入 */
        }
​
        byte b[] = bOutput.toByteArray();
        System.out.println("Print the content");
​
        for (int x = 0; x < b.length; x++) {
            System.out.print((char) b[x] + " "); /* 打印字符 */
        }
​
        System.out.println();
​
        int c;
​
        ByteArrayInputStream bInput = new ByteArrayInputStream(b);
        System.out.println("Converting characters to Upper case ");
​
        while ((c = bInput.read()) != -1) {
            System.out.println(Character.toUpperCase((char) c));
        }
​
        bInput.reset();
    }
}
```