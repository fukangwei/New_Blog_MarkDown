---
title: 包
date: 2018-12-24 14:23:07
categories: Java
---
&emsp;&emsp;为了更好地组织类，`Java`提供了包机制，用于区别类名的命名空间。包的作用如下：

- 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
- 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的。当同时调用两个不同包中相同类名的类时，应该加上包名加以区别，因此包可以避免名字冲突。
- 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

&emsp;&emsp;`Java`使用包(`package`)这种机制是为了防止命名冲突，提供搜索和定位`类`、`接口`、`枚举`和`注释`等。包语句的语法格式为：

``` java
package pkg1[.pkg2[.pkg3…]];
```

例如`Something.java`的内容如下：

``` java
package net.java.util;

public class Something {
    /* ... */
}
```

那么它的路径应该是`net/java/util/Something.java`。包的作用是把不同的`Java`程序分类保存，更方便地被其他`Java`程序调用。
&emsp;&emsp;一个包可以定义为一组相互联系的类型(类、接口、枚举和注释)，为这些类型提供访问保护和命名空间管理的功能。由于包创建了新的命名空间(`namespace`)，所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。以下是一些`Java`中的包：

- `java.lang`：打包基础的类。
- `java.io`：包含输入输出功能的函数。

开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。

### 创建包

&emsp;&emsp;创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的源文件需要包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。通常使用小写的字母来命名避免与类、接口名字的冲突。
&emsp;&emsp;让我们来看一个例子，这个例子创建了一个叫做`animals`的包，在包中加入一个接口(该源文件放在名为`animals`的文件夹下)：

``` java
package animals;

interface Animal {
    public void eat();
    public void travel();
}
```

接下来，在同一个包中加入该接口的实现：

``` java
package animals;
​
public class MammalInt implements Animal {
    public void eat() {
        System.out.println("Mammal eats");
    }
​
    public void travel() {
        System.out.println("Mammal travels");
    }
​
    public int noOfLegs() {
        return 0;
    }
​
    public static void main(String args[]) {
        MammalInt m = new MammalInt();
        m.eat();
        m.travel();
    }
}
```

执行结果如下：

``` java
Mammal eats
Mammal travels
```

### import关键字

&emsp;&emsp;为了能够使用某一个包的成员，我们需要在`Java`程序中明确导入该包，使用`import`语句可完成此功能。在`Java`源文件中，`import`语句应位于`package`语句之后(如果有`package`语句的话)，所有类的定义之前，可以没有，也可以有多条，其语法格式为：

``` java
import package1[.package2...].(classname|*);
```

如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。
&emsp;&emsp;下面的`payroll`包已经包含了`Employee`类，接下来向`payroll`包中添加一个`Boss`类。`Boss`类引用`Employee`类时，可以不用使用`payroll`前缀：

``` java
package payroll;
​
public class Boss {
    public void payEmployee(Employee e) {
        e.mailCheck();
    }
}
```

&emsp;&emsp;如果`Boss`类不在`payroll`包中又会怎样？`Boss`类必须使用下面几种方法之一来引用其他包中的类：

- 使用类全名描述：

``` java
payroll.Employee
```

用`import`关键字引入，使用通配符`*`：

``` java
import payroll.*;
```

使用`import`关键字引入`Employee`类：

``` java
import payroll.Employee;
```

### package的目录结构

&emsp;&emsp;包名必须与相应的字节码所在的目录结构相吻合。下面是管理你自己`Java`文件的一种简单方式：将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以`.java`作为扩展名。例如：

``` java
/* Car.java */
package vehicle;

public class Car {
    /* 类实现 */
}
```

接下来把源文件放在一个目录中，这个目录要对应类所在包的名字：

``` bash
...\vehicle\Car.java
```

现在正确的类名和路径将会是如下样子：

``` bash
类名   -> vehicle.Car
路径名 -> vehicle\Car.java(在Windows系统中)
```

通常一个公司使用它互联网域名的颠倒形式来作为它的包名，例如互联网域名是`runoob.com`，所有的包名都以`com.runoob`开头。包名中的每一个部分对应一个子目录。例如有一个`com.runoob.test`的包，这个包包含一个叫做`Runoob.java`的源文件，那么相应的，应该有如下面的一连串子目录：

``` bash
...\com\runoob\test\Runoob.java
```

编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上`.class`作为扩展后缀：

``` java
/* Runoob.java */
package com.runoob.test;
​
public class Runoob {
    /*...*/
}
​
class Google {
    /*...*/
}
```

现在我们用`-d`”选项来编译这个文件：

``` bash
javac -d . Runoob.java
```

然后就会像下面这样放置编译了的文件：

``` bash
...\com\runoob\test\Runoob.class
...\com\runoob\test\Google.class
```

你可以像下面这样来导入所有`...\com\runoob\test\`中定义的类、接口等：

``` java
import com.runoob.test.*;
```

编译之后的`.class`文件应该和`.java`源文件一样，它们放置的目录应该跟包的名字对应起来。但是并不要求`.class`文件的路径跟相应的`.java`的路径一样。你可以分开来安排源码和类的目录：

``` bash
<path-one>\sources\com\runoob\test\Runoob.java
<path-two>\classes\com\runoob\test\Google.class
```

这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和`Java`虚拟机(`JVM`)找到你程序中使用的所有类。
&emsp;&emsp;类目录的绝对路径叫做`class path`，设置在系统变量`CLASSPATH`中。编译器和`Java`虚拟机通过将`package`名字加到`class path`后面来构造`.class`文件的路径。假设`<path-two>\classes`是`class path`，`package`名字是`com.runoob.test`，而编译器和`JVM`会在`<path-two>\classes\com\runoob\test`中寻找`.class`文件。
&emsp;&emsp;一个`class path`可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和`JVM`查找当前目录。`JAR`文件是包含`Java`平台相关的类，所以它们的目录默认放在了`class path`中。