---
title: 方法
date: 2018-12-23 16:40:03
categories: Java
---
&emsp;&emsp;我们经常使用到`System.out.println`，那么它是什么呢？`System`是系统类，`out`是标准输出对象，`println`是一个方法。这句话的用法是调用系统类`System`中的标准输出对象`out`中的方法`println`。
&emsp;&emsp;Java方法是语句的集合，它们在一起执行一个功能。方法是解决一类问题的步骤的有序组合；方法包含于类或对象中；方法在程序中被创建，在其他地方被引用。
&emsp;&emsp;方法的优点如下：使程序变得更简短而清晰；有利于程序维护；可以提高程序开发的效率；提高了代码的重用性。
&emsp;&emsp;方法的命名规则：

- 方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符，例如`addPerson`。
- 下划线可能出现在`JUnit`测试方法名称中，用以分隔名称的逻辑组件。一个典型的模式是`test<MethodUnderTest>_<state>`，例如`testPop_emptyStack`。

### 方法的定义

&emsp;&emsp;一般情况下，定义一个方法包含以下语法：

``` java
修饰符 返回值类型 方法名 (参数类型 参数名) {
    ...
    方法体
    ...
    return 返回值;
}
```

方法包含一个方法名和一个方法体。下面是一个方法的所有部分：

- `修饰符`：修饰符，这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。
- `返回值类型`：方法可能会返回值。有些方法执行所需的操作，但没有返回值。在这种情况下，返回值类型是关键字`void`。
- `方法名`：方法的实际名称，方法名和参数表共同构成方法签名。
- `参数类型`：参数像是一个占位符。当方法被调用时，传递值给参数，这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。
- `方法体`：方法体包含具体的语句，定义该方法的功能。

代码如下：

``` java
public static int age(int birthday) {
    ...
}
```

参数可以有多个：

``` java
static float interest(float principal, int year) {
    ...
}
```

注意，在一些其它语言中，方法指的是过程和函数，一个返回非void类型返回值的方法称为`函数`，一个返回void类型返回值的方法叫做`过程`。
&emsp;&emsp;下面的方法包含参数`num1`和`num2`，它返回这两个参数的最大值：

``` java
public static int max(int num1, int num2) {
    int result;

    if (num1 > num2)
        result = num1;
    else
        result = num2;

    return result;
}
```

### 方法调用

&emsp;&emsp;Java支持两种调用方法的方式，根据方法是否返回值来选择。当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候，交还控制权给程序。下面的例子演示如何定义一个方法，以及如何调用它：

``` java
public class TestMax {
    public static void main(String[] args) { /* 主方法 */
        int i = 5;
        int j = 2;
        int k = max(i, j);
        /* 输出“5和2比较，最大值是5” */
        System.out.println(i + "和" + j + "比较，最大值是" + k);
    }
​
    /* 返回两个整数变量较大的值 */
    public static int max(int num1, int num2) {
        int result;

        if (num1 > num2)
            result = num1;
        else
            result = num2;
​
        return result;
    }
}
```

### void关键字

&emsp;&emsp;代码如下：

``` java
public class TestVoidMethod {
    public static void main(String[] args) {
        printGrade(78.5);
    }
​
    public static void printGrade(double score) {
        if (score >= 90.0) {
            System.out.println('A');
        } else if (score >= 80.0) {
            System.out.println('B');
        } else if (score >= 70.0) {
            System.out.println('C');
        } else if (score >= 60.0) {
            System.out.println('D');
        } else {
            System.out.println('F');
        }
    }
}
```

### 通过值传递参数

&emsp;&emsp;调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供：

``` java
public class TestPassByValue {
    public static void main(String[] args) {
        int num1 = 1;
        int num2 = 2;
​
        System.out.println("交换前num1的值为" + num1 + "，num2的值为" + num2);
        swap(num1, num2); /* 调用swap方法 */
        System.out.println("交换后num1的值为" + num1 + "，num2的值为" + num2);
    }
​
    /* 交换两个变量的方法 */
    public static void swap(int n1, int n2) {
        System.out.println("\t进入swap方法");
        System.out.println("\t\t交换前n1的值为" + n1 + "，n2的值为" + n2);
        /* 交换n1与n2的值 */
        int temp = n1;
        n1 = n2;
        n2 = temp;
        System.out.println("\t\t交换后n1的值为" + n1 + "，n2的值为" + n2);
    }
}
```

执行结果：

``` bash
交换前num1的值为1，num2的值为2
    进入swap方法
        交换前n1的值为1，n2的值2
        交换后n1的值为2，n2的值1
交换后num1的值为1，num2的值为2
```

传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。

### 方法的重载

&emsp;&emsp;上面使用的max方法仅仅适用于int型数据，但如果你想得到两个浮点类型数据的最大值呢？解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：

``` java
public static double max(double num1, double num2) {
    if (num1 > num2)
        return num1;
    else
        return num2;
}
```

&emsp;&emsp;如果你调用max方法时传递的是int型参数，则int型参数的max方法就会被调用；如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载。就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。Java编译器根据方法签名判断哪个方法应该被调用。
&emsp;&emsp;方法重载可以让程序更清晰易读。重载的方法必须拥有不同的参数列表，你不能仅仅依据修饰符或者返回类型的不同来重载方法。

### 变量作用域

&emsp;&emsp;变量的范围是程序中该变量可以被引用的部分。方法内定义的变量被称为局部变量，局部变量的作用范围从声明开始，直到包含它的块结束。参数实际上是一个局部变量。
&emsp;&emsp;for循环的初始化部分声明的变量，其作用范围在整个循环，但循环体内声明的变量其适用范围是从它声明到循环体结束。

### 命令行参数的使用

&emsp;&emsp;有时候你希望运行一个程序时候再传递给它消息，这要靠传递命令行参数给main函数实现。命令行参数是在执行程序时候紧跟在程序名字后面的信息。下面的程序打印所有的命令行参数：

``` java
public class CommandLine {
    public static void main(String args[]) {
        for (int i = 0; i < args.length; i++) {
            System.out.println("args[" + i + "]: " + args[i]);
        }
    }
}
```

执行结果：

``` bash
$ javac CommandLine.java
$ java CommandLine this is a command line 200 -100
args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
```

`String[] args`可以看出来它是一个数组，在命令行中运行`Test.class`文件，你可以这样写：

``` bash
java Test runoob
```

相当于给数组传入了一个`runoob`字符串。`String[] args`还有一种等价的写法`String... args`，前者为数组形式，后者为可变参数形式。

### 构造方法

&emsp;&emsp;当一个对象被创建时，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。
&emsp;&emsp;不管你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0。一旦你定义了自己的构造方法，默认构造方法就会失效：

``` java
class MyClass {
    int x;
​
    MyClass() { /* 这是构造函数 */
        x = 10;
    }
}
```

你可以像下面这样调用构造方法来初始化一个对象：

``` java
public class ConsDemo {
    public static void main(String args[]) {
        MyClass t1 = new MyClass();
        MyClass t2 = new MyClass();
        System.out.println(t1.x + " " + t2.x);
    }
}
```

### 可变参数

&emsp;&emsp;`JDK 1.5`开始，Java支持传递同类型的可变参数给一个方法。方法的可变参数的声明如下所示：

``` java
typeName... parameterName
```

在方法声明中，在指定参数类型后加一个省略号(`...`)。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，任何普通的参数必须在它之前声明：

``` java
public class VarargsDemo {
    public static void main(String args[]) {
        /* 调用可变参数的方法 */
        printMax(34, 3, 3, 2, 56.5);
        printMax(new double[]{1, 2, 3});
    }
​
    public static void printMax(double... numbers) {
        if (numbers.length == 0) {
            System.out.println("No argument passed");
            return;
        }
​
        double result = numbers[0];
​
        for (int i = 1; i < numbers.length; i++) {
            if (numbers[i] > result) {
                result = numbers[i];
            }
        }

        System.out.println("The max value is " + result);
    }
}
```

执行结果：

``` bash
The max value is 56.5
The max value is 3.0
```