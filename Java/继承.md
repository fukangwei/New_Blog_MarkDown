---
title: 继承
date: 2018-12-27 13:17:09
categories: Java
---
### 类的继承格式

&emsp;&emsp;`Java`通过`extends`关键字可以声明一个类是从另外一个类继承而来的，一般形式如下：

``` java
class 父类 {
}

class 子类 extends 父类 {
}
```

为什么需要继承？接下来我们通过实例来说明这个需求。开发动物类，其中动物分别为企鹅以及老鼠，要求如下：

- 企鹅：属性(姓名，id)，方法(吃，睡，自我介绍)
- 老鼠：属性(姓名，id)，方法(吃，睡，自我介绍)

&emsp;&emsp;企鹅类如下所示：

``` java
public class Penguin {
    private String name;
    private int id;
​
    public Penguin(String myName, int myid) {
        name = myName;
        id = myid;
    }
​
    public void eat() {
        System.out.println(name + "正在吃");
    }
​
    public void sleep() {
        System.out.println(name + "正在睡");
    }
​
    public void introduction() {
        System.out.println("大家好！我是" + id + "号" + name + ".");
    }
}
```

老鼠类如下所示：

``` java
public class Mouse {
    private String name;
    private int id;
​
    public Mouse(String myName, int myid) {
        name = myName;
        id = myid;
    }
​
    public void eat() {
        System.out.println(name + "正在吃");
    }
​
    public void sleep() {
        System.out.println(name + "正在睡");
    }
​
    public void introduction() {
        System.out.println("大家好！我是" + id + "号" + name + ".");
    }
}
```

从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)。所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成一个父类：

``` java
public class Animal {
    private String name;
    private int id;
​
    public Animal(String myName, int myid) {
        name = myName;
        id = myid;
    }
​
    public void eat() {
        System.out.println(name + "正在吃");
    }
​
    public void sleep() {
        System.out.println(name + "正在睡");
    }
​
    public void introduction() {
        System.out.println("大家好！我是" + id + "号" + name + ".");
    }
}
```

这个`Animal`类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，代码也更加简洁，提高代码的复用性(复用性主要是可以多次使用，不用多次写同样的代码)。继承之后的代码如下所示：

``` java
public class Penguin extends Animal { /* 企鹅类 */
    public Penguin(String myName, int myid) {
        super(myName, myid);
    }
}
​
public class Mouse extends Animal { /* 老鼠类 */
    public Mouse(String myName, int myid) {
        super(myName, myid);
    }
}
```

### 继承的特性

&emsp;&emsp;如下所示：

- 子类拥有父类非`private`的属性、方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- `Java`的继承是单继承，但是可以多重继承。单继承就是一个子类只能继承一个父类；多重继承就是，例如`A`类继承`B`类，`B`类继承`C`类，所以按照关系就是`C`类是`B`类的父类，`B`类是`A`类的父类，这是`Java`继承区别于`C++`继承的一个特性。
- 提高了类之间的耦合性(这是继承的缺点，耦合度高就会造成代码之间的联系紧密)。

### 继承关键字

&emsp;&emsp;继承可以使用`extends`和`implements`这两个关键字来实现，而且所有的类都是继承于`java.lang.Object`。当一个类没有继承的两个关键字，则默认继承`object`(这个类在`java.lang`包中，所以不需要`import`)祖先类。

#### extends关键字

&emsp;&emsp;在`Java`中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以`extends`只能继承一个类：

``` java
public class Animal {
    private String name;
    private int id;
​
    public Animal(String myName, String myid) {
        /* 初始化属性值 */
    }
​
    public void eat() {  /* 吃东西方法的具体实现 */
    }
​
    public void sleep() { /* 睡觉方法的具体实现 */
    }
}
​
public class Penguin extends Animal {
}
```

#### implements关键字

&emsp;&emsp;使用`implements`关键字可以变相地使`Java`具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口(接口跟接口之间采用逗号分隔)：

``` java
public interface A {
    public void eat();
    public void sleep();
}
​
public interface B {
    public void show();
}
​
public class C implements A, B {
}
```

#### super与this关键字

- `super`关键字：我们可以通过`super`关键字来实现对父类成员的访问，用来引用当前对象的父类。
- `this`关键字：指向自己的引用。

``` java
class Animal {
    void eat() {
        System.out.println("animal：eat");
    }
}
​
class Dog extends Animal {
    void eat() {
        System.out.println("dog：eat");
    }
​
    void eatTest() {
        this.eat(); /* this调用自己的方法 */
        super.eat(); /* super调用父类方法 */
    }
}
​
public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.eat();
        Dog d = new Dog();
        d.eatTest();
    }
}
```

执行结果：

``` java
animal：eat
dog：eat
animal：eat
```

#### final关键字

&emsp;&emsp;`final`关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。
&emsp;&emsp;声明类如下所示：

``` java
final class 类名 {
    /* 类体 */
}
```

声明方法如下所示：

``` java
修饰符(public/private/default/protected) final 返回值类型 方法名() {
    /* 方法体 */
}
```

实例变量也可以被定义为`final`，被定义为`final`的变量不能被修改。被声明为`final`类的方法自动地声明为`final`，但是实例变量并不是`final`。

#### 构造器

&emsp;&emsp;子类不能继承父类的构造器(构造方法或者构造函数)，如果父类的构造器带有参数，则必须在子类的构造器中显式地通过`super`关键字调用父类的构造器，并配以适当的参数列表。
&emsp;&emsp;如果父类有无参构造器，则在子类的构造器中用`super`调用父类构造器不是必须的；如果没有使用`super`关键字，系统会自动调用父类的无参构造器。

``` java
class SuperClass {
    private int n;
​
    SuperClass() {
        System.out.println("SuperClass()");
    }
​
    SuperClass(int n) {
        System.out.println("SuperClass(int n)");
        this.n = n;
    }
}
​
class SubClass extends SuperClass {
    private int n;
​
    SubClass() {
        super(300);
        System.out.println("SubClass");
    }
​
    public SubClass(int n) {
        System.out.println("SubClass(int n):" + n);
        this.n = n;
    }
}
​
public class TestSuperSub {
    public static void main(String args[]) {
        SubClass sc = new SubClass();
        SubClass sc2 = new SubClass(200);
    }
}
```

执行结果：

``` bash
SuperClass(int n)
SubClass
SuperClass()
SubClass(int n):200
```