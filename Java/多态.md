---
title: 多态
categories: Java
abbrlink: ac4294eb
date: 2019-02-08 11:00:46
---
&emsp;&emsp;多态是同一个行为具有多个不同表现形式或形态的能力。比如我们按下`F1`键这个动作，如果当前在`Word`下弹出的就是`Word`帮助，在`Windows`下弹出的就是`Windows`帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
&emsp;&emsp;多态的优点：消除类型之间的耦合关系，使代码具有可替换性、可扩充性、接口性、灵活性和简化性；可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。
&emsp;&emsp;多态存在的三个必要条件：继承；重写；父类引用指向子类对象。

``` java
Parent p = new Child();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法：

``` java
abstract class Animal {
    abstract void eat();
}
​
class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
​
    public void work() {
        System.out.println("抓老鼠");
    }
}
​
class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");
    }
​
    public void work() {
        System.out.println("看家");
    }
}
​
public class Test {
    public static void main(String[] args) {
        show(new Cat()); /* 以Cat对象调用show方法 */
        show(new Dog()); /* 以Dog对象调用show方法 */
        Animal a = new Cat(); /* 向上转型 */
        a.eat(); /* 调用的是Cat的eat */
        Cat c = (Cat) a; /* 向下转型 */
        c.work(); /* 调用的是Cat的work */
    }
​
    public static void show(Animal a) {
        a.eat();
        /* 类型判断 */
        if (a instanceof Cat) {  /* 猫做的事情 */
            Cat c = (Cat) a;
            c.work();
        } else if (a instanceof Dog) { /* 狗做的事情 */
            Dog c = (Dog) a;
            c.work();
        }
    }
}
```

执行结果：

``` java
吃鱼
抓老鼠
吃骨头
看家
吃鱼
抓老鼠
```

### 虚方法

&emsp;&emsp;当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字`super`：

``` java
public class Employee {
    private String name;
    private String address;
    private int number;
​
    public Employee(String name, String address, int number) {
        System.out.println("Employee 构造函数");
        this.name = name;
        this.address = address;
        this.number = number;
    }
​
    public void mailCheck() {
        System.out.println("邮寄支票给： " + this.name + " " + this.address);
    }
​
    public String toString() {
        return name + " " + address + " " + number;
    }
​
    public String getName() {
        return name;
    }
​
    public String getAddress() {
        return address;
    }
​
    public void setAddress(String newAddress) {
        address = newAddress;
    }
​
    public int getNumber() {
        return number;
    }
}
```

假设下面的类继承`Employee`类：

``` java
public class Salary extends Employee {
    private double salary; /* 全年工资 */
​
    public Salary(String name, String address, int number, double salary) {
        super(name, address, number);
        setSalary(salary);
    }
​
    public void mailCheck() {
        System.out.println("Salary 类的 mailCheck 方法 ");
        System.out.println("邮寄支票给：" + getName() + " ，工资为：" + salary);
    }
​
    public double getSalary() {
        return salary;
    }
​
    public void setSalary(double newSalary) {
        if (newSalary >= 0.0) {
            salary = newSalary;
        }
    }
​
    public double computePay() {
        System.out.println("计算工资，付给：" + getName());
        return salary / 52;
    }
}
```

调用代码如下：

``` java
public class VirtualDemo {
    public static void main(String[] args) {
        Salary s = new Salary("员工 A", "北京", 3, 3600.00);
        Employee e = new Salary("员工 B", "上海", 2, 2400.00);
        System.out.println("使用 Salary 的引用调用 mailCheck -- ");
        s.mailCheck();
        System.out.println("\n使用 Employee 的引用调用 mailCheck--");
        e.mailCheck();
    }
}
```

执行结果：

``` java
Employee 构造函数
Employee 构造函数
使用 Salary 的引用调用 mailCheck --
Salary 类的 mailCheck 方法
邮寄支票给：员工 A ，工资为：3600.0
​
使用 Employee 的引用调用 mailCheck--
Salary 类的 mailCheck 方法
邮寄支票给：员工 B ，工资为：2400.0
```

&emsp;&emsp;以上代码中实例化了两个`Salary`对象：一个使用`Salary`引用`s`，另一个使用`Employee`引用`e`。当调用`s.mailCheck`时，编译器在编译时会在`Salary`类中找到`mailCheck`，执行过程`JVM`就调用`Salary`类的`mailCheck`。因为`e`是`Employee`的引用，所以调用`e`的`mailCheck`方法时，编译器会去`Employee`类查找`mailCheck`方法。在编译时，编译器使用`Employee`类中的`mailCheck`方法验证该语句；但是在运行时，`Java`虚拟机调用的是`Salary`类中的`mailCheck`方法。
&emsp;&emsp;以上整个过程被称为`虚拟方法调用`，该方法被称为`虚拟方法`。`Java`中所有的方法都能以这种方式表现，因此重写的方法能在运行时调用，不管编译时源代码中引用变量是什么数据类型。
&emsp;&emsp;多态引用时，构造子类对象时的构造方法调用顺序：先调用超类的构造方法，多重超类首先调用最远超类的方法，然后再执行当前子类的构造方法。