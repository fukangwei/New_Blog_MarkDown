---
title: 数据类型
categories: Java
abbrlink: ba595a63
date: 2018-12-26 16:42:30
---
&emsp;&emsp;`Java`具有两大数据类型，即`内置数据类型`和`引用数据类型`。<!--more-->

### 内置数据类型

&emsp;&emsp;`Java`语言提供了`8`种基本类型，即`6`种数字类型(`4`个整数型，`2`个浮点型)，一种字符类型，还有一种布尔型。

#### byte

&emsp;&emsp;`byte`数据类型是`8`位、有符号的，以二进制补码表示的整数。最小值是`-128`，最大值是`127`，默认值是`0`。
&emsp;&emsp;`byte`类型用在大型数组中以节约空间，因为`byte`变量占用的空间只有`int`类型的四分之一：

``` java
byte a = 100;
byte b = -50:
```

#### short

&emsp;&emsp;`short`数据类型是`16`位、有符号的，以二进制补码表示的整数。最小值是`-32768`，最大值是`32767`，默认值是`0`。
&emsp;&emsp;`short`数据类型也可以像`byte`那样节省空间，一个`short`变量是`int`型变量所占空间的二分之一：

``` java
short s = 1000;
short r = -20000;
```

#### int

&emsp;&emsp;`int`数据类型是`32`位、有符号的，以二进制补码表示的整数。最小值是`-2,147,483,648`，最大值是`2,147,483,647`，默认值是`0`。一般的整型变量默认为`int`类型：

``` java
int a = 100000;
int b = -200000;
```

#### long

&emsp;&emsp;`long`数据类型是`64`位、有符号的，以二进制补码表示的整数。最小值是`-9,223,372,036,854,775,808`，最大值是`9,223,372,036,854,775,807`，默认值是`0L`。`L`理论上不区分大小写，但是若写成`l`容易与数字`1`混淆，所以最好大写。这种类型主要使用在需要比较大整数的系统上：

``` java
long a = 100000L;
long b = -200000L;
```

`Java`里使用`long`类型的数据一定要在数值后面加上`L`，否则将作为整型解析：

``` java
long g = (long)9223372036854775807;
long h = (long)-9223372036854775808;
/* 或者 */
long g = 9223372036854775807;
long h = -9223372036854775808;
```

会出现以下报错信息：

``` bash
Exception in thread "main" java.lang.Error: Unresolved compilation problems:
The literal 9223372036854775807 of type int is out of range
The literal 9223372036854775808 of type int is out of range
```

解决方法在数值后面加上`L`：

``` java
long value = 9223372036854775807L;
```

#### float

&emsp;&emsp;`float`数据类型是单精度、`32`位、符合`IEEE 754`标准的浮点数，默认值是`0.0f`，浮点数不能用来表示精确的值(例如货币)。`float`用在大型浮点数组时，可节省内存空间：

``` java
float f1 = 234.5f;
```

#### double

&emsp;&emsp;`double`数据类型是双精度、`64`位、符合`IEEE 754`标准的浮点数，默认值是`0.0d`，浮点数的默认类型为`double`类型。`double`类型同样不能表示精确的值(例如货币)：

``` java
double d1 = 123.4;
```

#### boolean

&emsp;&emsp;`boolean`数据类型表示一位的信息，只有两个取值(`true`和`false`)，默认值是`false`。这种类型只作为一种标志来记录`true/false`情况：

``` java
boolean one = true;
```

#### char

&emsp;&emsp;`char`类型是一个单一的`16`位`Unicode`字符，最小值是`\u0000`(即为`0`)，最大值是`\uffff`(即为`65,535`)。`char`数据类型可以储存任何字符：

``` java
char letter = 'A';
```

对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了：

``` java
public class PrimitiveTypeTest {
    public static void main(String[] args) {
        /* byte */
        System.out.println("基本类型：byte二进制位数：" + Byte.SIZE);
        System.out.println("包装类：java.lang.Byte");
        System.out.println("最小值：Byte.MIN_VALUE = " + Byte.MIN_VALUE);
        System.out.println("最大值：Byte.MAX_VALUE = " + Byte.MAX_VALUE);
        System.out.println();
​
        /* short */
        System.out.println("基本类型：short二进制位数：" + Short.SIZE);
        System.out.println("包装类：java.lang.Short");
        System.out.println("最小值：Short.MIN_VALUE = " + Short.MIN_VALUE);
        System.out.println("最大值：Short.MAX_VALUE = " + Short.MAX_VALUE);
        System.out.println();
​
        /* int */
        System.out.println("基本类型：int二进制位数：" + Integer.SIZE);
        System.out.println("包装类：java.lang.Integer");
        System.out.println("最小值：Integer.MIN_VALUE = " + Integer.MIN_VALUE);
        System.out.println("最大值：Integer.MAX_VALUE = " + Integer.MAX_VALUE);
        System.out.println();
​
        /* long */
        System.out.println("基本类型：long二进制位数：" + Long.SIZE);
        System.out.println("包装类：java.lang.Long");
        System.out.println("最小值：Long.MIN_VALUE = " + Long.MIN_VALUE);
        System.out.println("最大值：Long.MAX_VALUE = " + Long.MAX_VALUE);
        System.out.println();
​
        /* float */
        System.out.println("基本类型：float二进制位数：" + Float.SIZE);
        System.out.println("包装类：java.lang.Float");
        System.out.println("最小值：Float.MIN_VALUE = " + Float.MIN_VALUE);
        System.out.println("最大值：Float.MAX_VALUE = " + Float.MAX_VALUE);
        System.out.println();
​
        /* double */
        System.out.println("基本类型：double二进制位数：" + Double.SIZE);
        System.out.println("包装类：java.lang.Double");
        System.out.println("最小值：Double.MIN_VALUE = " + Double.MIN_VALUE);
        System.out.println("最大值：Double.MAX_VALUE = " + Double.MAX_VALUE);
        System.out.println();
​
        /* char */
        System.out.println("基本类型：char二进制位数：" + Character.SIZE);
        System.out.println("包装类：java.lang.Character");
        /* 以数值形式而不是字符形式将“Character.MIN_VALUE”输出到控制台 */
        System.out.println("最小值：Character.MIN_VALUE = " + (int) Character.MIN_VALUE);
        /* 以数值形式而不是字符形式将“Character.MAX_VALUE”输出到控制台 */
        System.out.println("最大值：Character.MAX_VALUE = " + (int) Character.MAX_VALUE);
    }
}
```

执行结果：

``` bash
基本类型：byte二进制位数：8
包装类：java.lang.Byte
最小值：Byte.MIN_VALUE = -128
最大值：Byte.MAX_VALUE = 127
​
基本类型：short二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE = -32768
最大值：Short.MAX_VALUE = 32767
​
基本类型：int二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE = -2147483648
最大值：Integer.MAX_VALUE = 2147483647
​
基本类型：long二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE = -9223372036854775808
最大值：Long.MAX_VALUE = 9223372036854775807
​
基本类型：float二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE = 1.4E-45
最大值：Float.MAX_VALUE = 3.4028235E38
​
基本类型：double二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE = 4.9E-324
最大值：Double.MAX_VALUE = 1.7976931348623157E308
​
基本类型：char二进制位数：16
包装类：java.lang.Character
最小值：Character.MIN_VALUE = 0
最大值：Character.MAX_VALUE = 65535
```

&emsp;&emsp;`Float`和`Double`的最小值和最大值都是以科学记数法的形式输出的，结尾的`E+数字`表示`E`之前的数字要乘以`10`的多少次方。比如`3.14E3`就是`3.14 * 10^3 = 3140`，`3.14E-3`就是`3.14 * 10^(-3) = 0.00314`。实际上，`Java`中还存在另外一种基本类型`void`，它也有对应的包装类`java.lang.Void`，不过我们无法直接对它们进行操作。

### 引用类型

&emsp;&emsp;在`Java`中，引用类型的变量非常类似于`C/C++`的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如`Employee`、`Puppy`等。变量一旦声明后，类型就不能被改变了。
&emsp;&emsp;对象、数组都是引用数据类型；所有引用类型的默认值都是`null`；一个引用变量可以用来引用任何与之兼容的类型：

``` java
Site site = new Site("Runoob");
```

引用类型是一个对象类型，它的值是指向内存空间的引用(就是地址)，所指向的内存中保存着变量所表示的一个值或一组值。普通的内置类型如下：

``` java
int a;
a = 250; /* 声明变量a的同时，系统给a分配了空间 */
```

引用类型就不是了，只给变量分配了引用空间，数据空间没有分配，因为不知道数据是什么。错误的例子：

``` java
MyDate today;
today.day = 4; /* 发生错误，因为today对象的数据空间未分配 */
```

引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问：

``` java
MyDate today; /* 为变量分配一个保存引用的空间 */
today = new MyDate(); /* 这句话是2步，首先执行“new MyDate()”，给today变量开辟数据空间，然后再执行赋值操作 */
```

引用变量赋值：

``` java
MyDate a, b; /* 在内存开辟两个引用空间 */
a = new MyDate(); /* 开辟MyDate对象的数据空间，并把该空间的首地址赋给a */
b = a; /* 将a存储空间中的地址写到b的存储空间中 */
```

#### Java常量

&emsp;&emsp;常量在程序运行时是不能被修改的。在`Java`中使用`final`关键字来修饰常量，声明方式和变量类似：

``` java
final double PI = 3.1415927;
```

虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。
&emsp;&emsp;字面常量可以赋给任何内置类型的变量：

``` java
byte a = 68;
char a = 'A';
```

`byte`、`int`、`long`和`short`都可以用十进制、十六进制以及八进制的方式来表示。当使用常量的时候，前缀`0`表示八进制，而前缀`0x`代表十六进制：

``` java
int decimal = 100;
int octal = 0144;
int hexa = 0x64;
```

和其他语言一样，`Java`的字符串常量也是包含在两个引号之间的字符序列：

``` java
"Hello World"
"two\nlines"
"\"This is in quotes\""
```

字符串常量和字符常量都可以包含任何`Unicode`字符：

``` java
char a = '\u0001';
String a = "\u0001";
```

Java支持一些特殊的转义字符序列：

符号     | 字符含义
---------|--------
`\n`     | 换行(`0x0a`)
`\r`     | 回车(`0x0d`)
`\f`     | 换页符(`0x0c`)
`\b`     | 退格(`0x08`)
`\0`     | 空字符(`0x20`)
`\s`     | 字符串
`\t`     | 制表符
`\"`     | 双引号
`\'`     | 单引号
`\\`     | 反斜杠
`\ddd`   | 八进制字符(`ddd`)
`\uxxxx` | 十六进制`Unicode`字符(`xxxx`)

#### 自动类型转换

&emsp;&emsp;整型、实型(常量)、字符型数据可以混合运算。在运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级：

``` bash
低 --------------------------------------> 高
byte/short/char -> int -> long -> float -> double
```

数据类型转换必须满足如下规则：

- 不能对`boolean`类型进行类型转换。
- 不能把对象类型转换成不相关类的对象。
- 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
- 转换过程中可能导致溢出或损失精度：

``` java
int i = 128;
byte b = (byte)i;
```

因为`byte`类型是`8`位，最大值为`127`，所以当`int`强制转换为`byte`类型时，值`128`就会导致溢出。

- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入：

``` java
(int)23.7 == 23;
(int)-45.89f == -45;
```

&emsp;&emsp;必须满足转换前的数据类型的位数要低于转换后的数据类型，例如`short`数据类型的位数为`16`位，就可以自动转换位数为`32`的`int`类型。同样，`float`数据类型的位数为`32`，可以自动转换为`64`位的`double`类型：

``` java
public class ZiDongLeiZhuan {
    public static void main(String[] args) {
        char c1 = 'a'; /* 定义一个char类型 */
        int i1 = c1; /* char自动类型转换为int */
        System.out.println("char自动类型转换为int后的值等于" + i1);
        char c2 = 'A'; /* 定义一个char类型 */
        int i2 = c2 + 1; /* char类型和int类型计算 */
        System.out.println("char类型和int计算后的值等于" + i2);
    }
}
```

执行结果：

``` bash
char自动类型转换为int后的值等于97
char类型和int计算后的值等于66
```

`c1`的值为字符`a`，对应的`int`类型值为`97`，`A`对应值为`65`，所以`i2 = 65 + 1 = 66`。

#### 强制类型转换

&emsp;&emsp;强制类型转换需要的条件是，转换的数据类型必须是兼容的：

``` java
public class QiangZhiZhuanHuan {
    public static void main(String[] args) {
        int i1 = 123;
        byte b = (byte) i1; /* 强制类型转换为byte */
        System.out.println("int强制类型转换为byte后的值等于" + b);
    }
}
```

执行结果：

``` bash
int强制类型转换为byte后的值等于123
```