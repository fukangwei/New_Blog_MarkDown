---
title: 并发编程
date: 2018-12-21 10:27:25
categories: Java
---

&emsp;&emsp;在Java的Object类中，有三个final的方法允许线程之间进行资源对象锁的通信，它们分别是`wait`、`notify`和`notifyAll`。调用这些方法的当前线程必须拥有此对象监视器，否则将会报`java.lang.IllegalMonitorStateException exception`异常。

### wait

&emsp;&emsp;Object的wait方法有三个重载方法，其中一个方法wait是无限期等待，直到其它线程调用`notify`或`notifyAll`方法唤醒当前的线程；另外两个方法`wait(long timeout)`和`wait(long timeout, int nanos)`允许传入当前线程在被唤醒之前需要等待的时间，timeout为毫秒数，nanos为纳秒数。

### notify

&emsp;&emsp;notify方法只唤醒一个等待(对象的)线程，并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。

### notifyAll

&emsp;&emsp;notifyAll会唤醒所有等待线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。这些方法可以使用于`生产者-消费者`问题，消费者是在队列中等待对象的线程，生产者是在队列中释放对象并通知其他线程的线程。

### 代码实例

&emsp;&emsp;让我们来看一个多线程作用于同一个对象的例子，使用wait、notify和notifyAll方法。

#### Message

&emsp;&emsp;`Message.java`如下所示：

``` java
public class Message {
    private String msg;
​
    public Message(String str) {
        this.msg = str;
    }
​
    public String getMsg() {
        return msg;
    }
​
    public void setMsg(String str) {
        this.msg = str;
    }
}
```

#### Waiter

&emsp;&emsp;Waiter类等待其它的线程调用notify方法，以唤醒线程完成处理。注意，等待线程必须通过加synchronized同步锁拥有Message对象的监视器：

``` java
public class Waiter implements Runnable {
    private Message msg;
​
    public Waiter(Message m) {
        this.msg = m;
    }
​
    @Override
    public void run() {
        String name = Thread.currentThread().getName();
        synchronized (msg) {
            try {
                System.out.println(name + " waiting to get notified at time : " + System.currentTimeMillis());
                msg.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name + " waiter thread got notified at time : " + System.currentTimeMillis());
            // process the message now
            System.out.println(name + " processed : " + msg.getMsg());
        }
    }
}
```

#### Notifier

&emsp;&emsp;Notifier类处理Message对象，并调用notify方法唤醒等待Message对象的线程。注意，synchronized代码块被用于持有Message对象的监视器：

``` java
public class Notifier implements Runnable {
    private Message msg;
​
    public Notifier(Message msg) {
        this.msg = msg;
    }
​
    @Override
    public void run() {
        String name = Thread.currentThread().getName();
        System.out.println(name + " started");
        try {
            Thread.sleep(1000);
            synchronized (msg) {
                msg.setMsg(name + " Notifier work done");
                msg.notify();
                // msg.notifyAll();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

#### WaitNotifyTest

&emsp;&emsp;这是一个测试类，用于创建多个等待线程和一个通知线程，并启动这些线程：

``` java
public class WaitNotifyTest {
    public static void main(String[] args) {
        Message msg = new Message("process it");
        Waiter waiter = new Waiter(msg);
        new Thread(waiter, "waiter").start();
​
        Waiter waiter1 = new Waiter(msg);
        new Thread(waiter1, "waiter1").start();
​
        Notifier notifier = new Notifier(msg);
        new Thread(notifier, "notifier").start();
        System.out.println("All the threads are started");
    }
}
```

当我们调用以上的代码时，可以看到以下的输出，但并没有结束，因为有两个线程等待同一个Message对象。但notify方法只能唤醒一个线程，另一个线程仍然在等待被唤醒：

``` bash
All the threads are started
notifier started
waiter waiting to get notified at time : 1531476057338
waiter1 waiting to get notified at time : 1531476057405
waiter waiter thread got notified at time : 1531476058392
waiter processed : notifier Notifier work done
```

如果我们注释掉Notifier类中的notify方法的调用，并打开notifyAll方法的调用，将会有以下的输出信息：

``` bash
All the threads are started
notifier started
waiter waiting to get notified at time : 1531476189874
waiter1 waiting to get notified at time : 1531476189943
waiter waiter thread got notified at time : 1531476190945
waiter processed : notifier Notifier work done
waiter1 waiter thread got notified at time : 1531476190965
waiter1 processed : notifier Notifier work done
```