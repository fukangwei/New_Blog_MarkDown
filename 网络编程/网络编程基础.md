---
title: 网络编程基础
date: 2021-06-27 13:46:31
categories: 网络编程
---
### 网络模型

<img src="./网络编程基础/网络模型.png">

### TCP/IP协议族

&emsp;&emsp;`TCP/IP`实际上一个协同工作的通信家族，为网络数据通信提供通路。为讨论方便可`TCP/IP`协议组大体上分为三部分：

- `Internet`协议(`IP`)。
- 传输控制协议(`TCP`)和用户数据报协议(`UDP`)。
- 处于`TCP`和`UDP`之上的一组应用协议，它们包括`TELNET`、文件传送协议(`FTP`)、域名服务(`DNS`)和简单邮件传送程序(`SMTP`)等。

### 网络层

&emsp;&emsp;第一部分称为`网络层`。主要包括`Internet`协议(`IP`)、网际控制报文协议(`ICMP`)和地址解析协议(`ARP`)。

- `Internet`协议(`IP`)：该协议被设计成互联分组交换通信网，以形成一个网际通信环境。它负责在源主机和目的地主机之间传输来自其较高层软件的，称为`数据报文`的数据块，它在源和目的地之间提供非连接型传递服务。
- 网际控制报文协议(`ICMP`)：它实际上不是`IP`层部分，但直接同`IP`层一起工作，报告网络上的某些出错情况。允许网际路由器传输差错信息或测试报文。
- 地址解析协议(`ARP`)：`ARP`实际上不是网络层部分，它处于`IP`和数据链路层之间，它是在`32`位`IP`地址和`48`位物理地址之间执行翻译的协议。

### 传输层协议

&emsp;&emsp;第二部分是传输层协议，包括传输控制协议和用户数据报文协议。

- 传输控制协议(`TCP`)：该协议对建立网络上用户进程之间的对话负责，它确保进程之间的可靠通信，所提供的功能如下：监听输入对话建立请求、请求另一网络站点对话、可靠的发送和接收数据和适度的关闭对话。
- 用户数据报文协议(`UDP`)：`UDP`提供不可靠的非连接型传输层服务，它允许在源和目的地之间传送数据，而不必在传送数据之前建立对话。它主要用于那些非连接型的应用程序，如视频点播。

### 应用协议

&emsp;&emsp;这部分主要包括`Telnet`、文件传送协议(`FTP`和`TFTP`)，简单文件传送协议(`SMTP`)和域名服务(`DNS`)等协议。

### IP协议

&emsp;&emsp;`IP`主要有以下四个主要功能：数据传送、寻址、路由选择和数据报文的分段。
&emsp;&emsp;`IP`的主要目的是为数据`输入/输出`网络提供基本算法，为高层协议提供无连接的传送服务。这意味着在`IP`将数据递交给接收站点以前不在传输站点和接收站点之间建立对话。它只是封装和传递数据，但不向发送者或接收者报告包的状态，不处理所遇到的故障。

### TCP协议

&emsp;&emsp;`TCP`是重要的传输层协议，目的是允许数据同网络上的其他节点进行可靠的交换。它能提供端口编号的译码，以识别主机的应用程序，而且完成数据的可靠传输。`TCP`协议具有严格的内装差错检验算法确保数据的完整性。`TCP`是面向字节的顺序协议，这意味着包内的每个字节被分配一个顺序编号，并分配给每包一个顺序编号。

### UDP协议

&emsp;&emsp;`UDP`也是传输层协议，它是无连接的，不可靠的传输服务。当接收数据时它不向发送方提供确认信息，它不提供输入包的顺序，如果出现丢失包或重份包的情况，也不会向发送方发出差错报文。由于它执行功能时具有较低的开销，因而执行速度比`TCP`快。

### Socket

&emsp;&emsp;`Linux`中的网络编程通过`Socket`接口实现，`Socket`是一种文件描述符。套接字`socket`有三种类型：

- 流式套接字(`SOCK_STREAM`)：流式的套接字可以提供可靠的、面向连接的通讯流。它使用了`TCP`协议。`TCP`保证了数据传输的正确性和顺序性。
- 数据报套接字(`SOCK_DGRAM`)：数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错，它使用数据报协议`UDP`。
- 原始套接字：原始套接字允许对低层协议如`IP`或`ICMP`直接访问，主要用于新的网络协议的测试等。

### 地址转换

&emsp;&emsp;`IP`地址通常由数字加点(`192.168.0.1`)的形式表示，而在`struct in_addr`中使用的是`IP`地址是由`32`位的整数表示的。为了进行转换，我们可以使用下面两个函数：

``` cpp
int inet_aton ( const char *cp, struct in_addr *inp );
char *inet_ntoa ( struct in_addr in );
```

函数里面的`a`代表`ascii`，`n`代表`network`。第一个函数表示将`a.b.c.d`形式的`IP`转换为`32`位的`IP`，存储在`inp`指针里面。第二个是将`32`位`IP`转换为`a.b.c.d`的格式。

### 字节序转换

&emsp;&emsp;不同类型的`CPU`对变量的字节存储顺序可能不同：有的系统是高位在前，低位在后，而有的系统是低位在前，高位在后，而网络传输的数据顺序是一定要统一的。所以当内部字节存储顺序和网络字节顺序不同时，就一定要进行转换。
&emsp;&emsp;网络字节顺序是`TCP/IP`中规定好的一种数据表示格式，它与具体的`CPU`类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用`big endian`排序方式。

- `htons`：把`unsigned short`类型从主机序转换到网络序。
- `htonl`：把`unsigned long`类型从主机序转换到网络序。
- `ntohs`：把`unsigned short`类型从网络序转换到主机序。
- `ntohl`：把`unsigned long`类型从网络序转换到主机序。

### 操作函数

&emsp;&emsp;进行`Socket`编程的常用函数有：

- `socket`：创建一个`socket`。
- `bind`：用于绑定`IP`地址和端口号到`socket`。
- `connect`：该函数用于绑定之后的`client`端，与服务器建立连接。
- `listen`：设置能处理的最大连接要求，`Listen`并未开始接收连线，只是设置`socket`为`listen`模式。
- `accept`：用来接受`socket`连接。
- `send`：发送数据。
- `recv`：接收数据。

### 基于TCP的服务器

1. 创建一个`socket`，用函数`socket`。
2. 绑定`IP`地址、端口等信息到`socket`上，用函数`bind`。
3. 设置允许的最大连接数，用函数`listen`。
4. 接收客户端上来的连接，用函数`accept`。
5. 收发数据，用函数`send`和`recv`，或者`read`和`write`。
6. 关闭网络连接。