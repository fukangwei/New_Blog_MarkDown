---
title: 8086汇编代码
date: 2018-12-17 10:05:54
categories: Intel汇编
---
### 显示字符串

&emsp;&emsp;代码`1`如下：

``` c
DATA SEGMENT
    STR DB "hello,world! $"
DATA ENDS
​
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX

    LEA DX, STR
    MOV AH, 9
    INT 21h

    MOV AH, 4CH
    INT 21H
CODE ENDS
END START
```

代码`2`如下：

``` c
ASSUME CS:CODE, DS:DATA

DATA SEGMENT
    DB "hello,world!"
DATA ENDS

CODE SEGMENT

START:
    MOV AX, DATA
    MOV DS, AX
    MOV SI, 0 ; 设置“ds:si”指向字符串

    MOV AX, 0B800H
    MOV ES, AX
    MOV DI, 12 * 160 + 36 * 2 ; 设置“ds:si”指向显存空间的中间位置

    MOV CX, 12 ; 设置cx为字符串长度
S:  MOV AL, [SI],
    MOV ES:[DI], AL
    INC SI
    ADD DI, 2
    LOOP S
​
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START
```

### 显示ASCII码表(256个)

&emsp;&emsp;代码如下：

``` c
assume cs:codesg

codesg segment
    ; 设置寄存器初值
    mov dx, 0000H
    mov dl, 10H   ; 从ASCII码为10H的字符开始显示
    mov cx, 000FH ; 设置外循环的次数15，即要显示的行数
    mov ax, 0000H

r:
    mov ah, 02H   ; 设置显示方式
    push cx       ; 保存外循环次数的计数
    mov cx, 0010H ; 设置内循环次数16，即一行16个字符

c:
    int 21H     ; 显示ASCII值为[dl]的字符
    push dx     ; 保存dx的值
    mov dl, 00H ; 输出空格
    int 21H

    pop dx ; 恢复dx的值，并加1，产生下一个ASCII字符
    inc dx
    loop c
    ; 已经进行完了一次内循环
    pop cx  ; 恢复外循环次数的计数
    push dx ; 保存dx的值

    mov dl, 0dH ; 输出回车换行
    int 21H
    mov dl, 0aH
    int 21H

    pop dx ; 恢复dx的值

    loop r
    ; 外循环结束，程序的功能完成
    mov ax, 4c00H
    int 21H
codesg ends
end
```

### 累加和

&emsp;&emsp;代码如下：

``` c
DATA SEGMENT
    STR DB "result is $"
DATA ENDS
​
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX,DATA
    MOV DS,AX
​
    LEA DX, STR
    MOV AH, 9
    INT 21h ; 到这里可以显示字符串“result is ”
​
    XOR AX, AX
    MOV BX, 0001H
    MOV CX, 100
​
AGAIN:
    ADD AX, BX
    INC BX
    LOOP AGAIN
​
    MOV DX, 0 ; 注意除法运算
    MOV BX, 1000
    DIV BX
    ADD AX, 30H
    PUSH DX
    MOV DX, AX
    MOV AH, 2
    INT 21H
​
    POP DX
    MOV AX, DX
    MOV DX, 0
    MOV BX, 100
    DIV BX
    ADD AX, 30H
    PUSH DX
    MOV DX, AX
    MOV AH, 2
    INT 21H
​
    POP DX
    MOV AX, DX
    MOV DX, 0
    MOV BX, 10
    DIV BX
    ADD AX, 30H
    PUSH DX
    MOV DX, AX
    MOV AH, 2
    INT 21H
​
    POP DX
    MOV AX, DX  
    ADD AX, 30H
    MOV DX, AX
    MOV AH, 2
    INT 21H
    MOV AH, 4CH
    INT 21H ; 这两句是返回dos
CODE ENDS
​
END START
```

### 计算2的12次方

&emsp;&emsp;代码如下：

``` c
assume cs:code

code segment
    mov ax, 2
    mov cx, 11

s:
    add ax, ax
    loop s

    mov ax, 4c00h
    int 21h
code ends
end
```

### 数据复制

&emsp;&emsp;代码`1`如下(将内存`ffff:0`至`ffff:b`中的数据复制到`0:200`至`0:20b`)：

``` c
assume cs:code

code segment
    mov bx, 0  ; “(bx) = 0”，偏移地址从0开始
    mov cx, 12 ; “(cx) = 12”，循环12次

s:  mov ax, 0ffffh
    mov ds, ax   ; (ds) = 0ffffh
    mov dl, [bx] ; (dl) = ((ds) * 16 + (bx))，将“ffff:bx”中的数值送入dl

    mov ax, 0020h
    mov ds, ax   ; “(ds) = 0020h”
    mov [bx], dl ; “((ds) * 16 + (bx)) = (dl)”，将dl中的数值送入“0020:bx”

    inc bx ; (bx) = (bx) + 1
    loop s

    mov ax, 4c00h
    int 21h

code ends

end
```

代码`2`如下：

``` c
assume cs:code

code segment
    mov ax, 0ffffh
    mov ds, ax ;(ds) = 0ffffh

    mov ax, 0020h
    mov es, ax ;(es) = 0020h

    mov bx, 0  ; (bx) = 0，此时“ds:bx”指向“ffff:0”，“es:bx”指向“0020:0”
    mov cx, 12 ; (cx) = 12，循环12次

s:  mov dl, [bx]    ; (dl) = ((ds) * 16 + (bx))，将“ffff:bx”中的数值送入dl
    mov es:[bx], dl ; ((es) * 16 + (bx)) = (dl)，将dl中的数值送入“0020:bx”

    inc bx ;(bx) = (bx) + 1
    loop s

    mov ax, 4c00h
    int 21h

code ends

end
```

### 改写字符串中的字母

&emsp;&emsp;字符串大小写转换：

``` c
assume cs:code, ds:data

data segment
    db 'BaSiC'
    db 'iNfOrMaTion'
data ends

code segment
start:
    mov ax, data
    mov ds, ax ; 设置ds指向data段
    mov bx, 0  ; 设置“(bx) = 0”，“ds:bx”指向“BaSiC”的第一个字母
    mov cx, 5  ; 设置循环次数5，因为“BaSiC”有5个字母

s:  mov al, [bx]      ; 将ASCII码从“ds:bx”所指向的单元中取出
    and al, 11011111B ; 将al中的ASCII码的第5位置0，变为大写字母
    mov [bx], al      ; 将转变后的ASCII码写回原单元
    inc bx            ; (bx)加1，“ds:bx”指向下一个字母
    loop s

    mov bx, 5  ; 设置“(bx) = 5”，“ds:bx”指向“iNfOrMaTion”的第一个字母
    mov cx, 11 ; 设置循环次数11，因为“iNfOrMaTion”有11个字母

s0: mov al, [bx]
    or al, 00100000B ; 将al中的ASCII码的第5位置1，变为小写字母
    mov [bx], al
    inc bx
    loop s0

    mov ax, 4c00h
    int 21h

code ends

end start
```

&emsp;&emsp;将data段中每个单词的头一个字母改为大写字母：

``` c
assume cs:code, ds:data

data segment
    db '1. file         ' ; 每行16个字符
    db '2. edit         '
    db '3. search       '
    db '4. view         '
    db '5. options      '
    db '6. help         '
data ends

code segment
start:
    mov ax, data
    mov ds, ax
    mov bx, 0
​
    mov cx, 6
s:  mov al, [bx+3]
    and al, 11011111b
    mov [bx+3], al
    add bx, 16
    loop s

    mov ax, 4c00h
    int 21h
code ends
​
end start
```

&emsp;&emsp;将`data`段中每个单词改为大写字母：

``` c
assume cs:code, ds:data, ss:stack

data segment
    db 'ibm             ' ; 每行16个字符
    db 'dec             '
    db 'dos             '
    db 'vax             '
data ends

stack segment ; 定义一个段，用来做栈段，容量为16字节
    dw 0, 0, 0, 0, 0, 0, 0, 0
stack ends

code segment
start:  
    mov ax, stack
    mov ss, ax
    mov sp, 16
    mov ax, data
    mov ds, ax
    mov bx, 0

    mov cx, 4

s0: push cx ; 将外层循环的cx值压栈
    mov si, 0
    mov cx, 3 ; cx设置为内层循环的次数

s:  mov al, [bx+si]
    and al, 11011111b
    mov [bx+si], al
    inc si
    loop s

    add  bx, 16
    pop  cx ; 从栈顶弹出原cx的值，恢复cx
    loop s0 ; 外层循环的loop指令将cx中的计数值减1

    mov ax, 4c00h
    int 21h
code ends

end start
```

&emsp;&emsp;将`data`段中的字符串全部转化为大写(解决寄存器冲突)：

``` c
assume cs:code, ds:data

data segment
    db 'word', 0
    db 'unix', 0
    db 'wind', 0
    db 'good', 0
data ends

code segment

start:
    mov ax, data
    mov ds, ax
    mov bx, 0

    mov cx, 4
s:  mov si, bx
    call capital
    add bx, 5
    loop s

    mov ax, 4c00h
    int 21h

capital:
    push cx
    push si

change:
    mov cl, [si]
    mov ch, 0
    jcxz ok
    and byte ptr [si], 11011111b
    inc si
    jmp short change

ok: pop si
    pop cx
    ret

code ends

end start
```

### 数据逆序存放

&emsp;&emsp;代码`1`如下(利用栈)：

``` c
assume cs:code
code segment
    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
    dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ; 用dw定义16个字型数据，在程序加载后，
    ; 将取得16个字的内存空间，存放这16个数据。
    ; 在后面的程序中将这段空间当做栈来使用。

start: mov ax, cs
       mov ss, ax
       mov sp, 30h ; 将设置栈顶“ss:sp”指向“cs:30”
       mov bx, 0
       mov cx, 8
s:
    push cs:[bx]
    add bx, 2
    loop s ; 以上将代码段0至15单元中的8个字型数据依次入栈

    mov bx, 0
    mov cx, 8
s0:
    pop cs:[bx]
    add bx, 2
    loop s0 ; 以上依次出栈8个字型数据到代码段0至15单元中

    mov ax, 4c00h
    int 21h
code ends

end start ; 指明程序的入口在start处
```

代码`2`如下(利用栈)：

``` c
assume cs:code, ds:data, ss:stack

data segment
    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h
data ends

stack segment
    dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
stack ends

code segment

start:
    mov ax, stack
    mov ss, ax
    mov sp, 20h ; 将设置栈顶“ss:sp”指向“cs:20”

    mov ax, data
    mov ds, ax ; ds指向data段
    mov bx, 0  ; “ds:bx”指向data段中的第一个单元

    mov cx, 8
s:  push cs:[bx]
    add bx, 2
    loop s ; 以上将代码段0至15单元中的8个字型数据依次入栈
    mov bx, 0
    mov cx, 8

s0: pop cs:[bx]
    add bx, 2
    loop s0 ; 以上依次出栈8个字型数据到代码段0至15单元中

    mov ax, 4c00h
    int 21h
code ends

end start
```

### 彩色显示

&emsp;&emsp;代码如下所示(在屏幕的5行12列显示3个红底高亮闪烁绿色的`a`)：

``` c
assume cs:code

code segment
start:
    mov ah, 2  ; 置光标
    mov bh, 0  ; 第0页
    mov dh, 5  ; dh中放行号
    mov dl, 12 ; dl中放列号
    int 10h

    mov ah, 9         ; 在光标上显示字符
    mov al, 'a'       ; 字符
    mov bl, 11001010b ; 颜色属性
    mov bh, 0         ; 第0页
    mov cx, 3         ; 字符重复个数
    int 10h

    mov ax, 4c00h
    int 21h
code ends

end start
```

### 中断7ch例程

&emsp;&emsp;代码如下所示(求word型数据的平方)：

``` c
assume cs:code

code segment

start:
    mov ax, cs
    mov ds, ax
    mov si, offset sqr ; 设置“ds:si”指向源地址

    mov ax, 0
    mov es, ax
    mov di, 200h ; 设置“es:di”指向目的地址
    mov cx, offset sqrend - offset sqr ; 设置cx为传输长度
    cld ; 设置传输方向为正
    rep movsb

    mov ax, 0
    mov es, ax
    mov word ptr es:[7ch * 4], 200h
    mov word ptr es:[7ch * 4 + 2], 0

    mov ax, 4c00h
    int 21h
sqr:  
    mul ax
    iret
sqrend: nop

code ends

end start
```

### 串传送指令

&emsp;&emsp;将data段中的第一个字符串复制到它后面的空间中：

``` c
data segment
    db 'Welcome to masm!'
    db 16 dup (0)
data ends

mov ax, data
moc ds, ax
mov si, 0  ; “ds:si”指向“data:0”
mov es, ax
mov di, 16 ; “es:di”指向“data:0010”
mov cx, 16 ; “(cx) = 16”，rep循环16次
cld        ; 设置“df = 0”，正向传送
rep movsb
```

将F000段中的最后16个字符复制到data段中：

``` c
data segment
    db 16 dup (0)
data ends

mov ax, 0f000h
moc ds, ax
mov si, 0ffffh ; “ds:si”指向“f000:ffff”
mov ax, data
mov es, ax
mov di, 15 ; “es:di”指向“data:000F”
mov cx, 16 ; “(cx) = 16”，rep循环16次
std        ; 设置“df = 1”，逆向传送
rep movsb
```

### offset的用法

&emsp;&emsp;程序在运行中将start处的一条指令复制到s0处：

``` c
assume cs:code

code segment
start:
    mov ax, bx ; “mov ax, bx”的机器码占两个字节
    mov si, offset start
    mov di, offset s0

    mov ax, cs:[si]
    mov cs:[di], ax

s0: nop ; nop的机器码占一个字节
    nop

    mov ax, 4c00h
    int 21h
code ends

end start
```

### 条件转移指令

&emsp;&emsp;data段中的8个字节如下所示：

``` c
data segment
    db 8, 11, 8, 1, 8, 5, 63, 38
data ends
```

统计data段中数值为8的字节的个数，用ax保存统计结果：

``` c
    mov ax, data
    mov ds, ax
    mov bx, 0 ; “ds:bx”指向第一个字节
    mov ax, 0 ; 初始化累加器

    mov cx, 8
s:  cmp byte ptr [bx], 8 ; 和8进行比较
    jne next             ; 如果不相等则转到next，继续循环
    inc ax               ; 如果相等就将计数值加1

next: inc bx
      loop s
```

统计data段中数值大于8的字节的个数，用ax保存统计结果：

``` c
    mov ax, data
    mov ds, ax
    mov bx, 0 ; “ds:bx”指向第一个字节
    mov ax, 0 ; 初始化累加器

    mov cx, 8
s:  cmp byte ptr [bx], 8 ; 和8进行比较
    jna next             ; 如果不大于8则转到next，继续循环
    inc ax               ; 如果大于8就将计数值加1

next: inc bx
      loop s
```

统计data段中数值小于8的字节的个数，用ax保存统计结果：

``` c
    mov ax, data
    mov ds, ax
    mov bx, 0 ; “ds:bx”指向第一个字节
    mov ax, 0 ; 初始化累加器

    mov cx, 8
s:  cmp byte ptr [bx], 8 ; 和8进行比较
    jnb next             ; 如果不小于8则转到next，继续循环
    inc ax               ; 如果小于8就将计数值加1

next: inc bx
      loop s
```