---
title: 多进程
date: 2019-02-08 15:44:46
tags:
---
&emsp;&emsp;`Node.js`是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核`cpu`的系统上创建多个子进程，从而提高性能。每个子进程总是带有三个流对象：`child.stdin`、`child.stdout`和`child.stderr`，它们可能会共享父进程的`stdio`流，或者也可以是独立的被导流的流对象。
&emsp;&emsp;`Node.js`提供了`child_process`模块来创建子进程，方法有：

- `exec`：`child_process.exec`，使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。
- `spawn`：`child_process.spawn`，使用指定的命令行参数创建新进程。
- `fork`：`child_process.fork`是`spawn`的特殊形式，用于在子进程中运行的模块，如`fork('./son.js')`相当于`spawn('node', ['./son.js'])`。与`spawn`方法不同的是，`fork`会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。

### exec方法

&emsp;&emsp;`child_process.exec`使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回：

``` javascript
child_process.exec(command[, options], callback)
```

参数`command`是字符串，就是将要运行的命令，参数使用空格隔开；`options`是对象：

- `cwd`：字符串，子进程的当前工作目录。
- `env`：对象，环境变量键值对。
- `encoding`：字符串，字符编码，默认是`utf8`。
- `shell`：字符串，执行命令的`Shell`。默认情况下，在`UNIX`中为`/bin/sh`，在`Windows`中为`cmd.exe`。
- `timeout`：数字，超时时间，默认为`0`。
- `maxBuffer`：数字，在`stdout`或`stderr`中允许存在的最大缓冲，如果超出，那么子进程将会被杀死 ，默认为`200 * 1024`。
- `killSignal`：字符串，结束信号，默认为`SIGTERM`。
- `uid`：数字，设置用户进程的`ID`。
- `gid`：数字，设置进程组的`ID`。

`callback`是回调函数，包含三个参数，即`error`、`stdout`和`stderr`。
&emsp;&emsp;创建`support.js`和`master.js`。`support.js`代码如下：

``` javascript
console.log("进程" + process.argv[2] + "执行");
```

`master.js`代码如下：

``` javascript
const fs = require('fs');
const child_process = require('child_process');
​
for (var i = 0; i < 3; i++) {
    var workerProcess = child_process.exec('node support.js ' + i, function (error, stdout, stderr) {
        if (error) {
            console.log(error.stack);
            console.log('Error code: ' + error.code);
            console.log('Signal received: ' + error.signal);
        }
        console.log('stdout: ' + stdout);
        console.log('stderr: ' + stderr);
    });
​
    workerProcess.on('exit', function (code) {
        console.log('子进程已退出，退出码' + code);
    });
}
```

执行结果：

``` javascript
子进程已退出，退出码0
stdout: 进程0执行
​
stderr:
子进程已退出，退出码0
stdout: 进程2执行
​
stderr:
子进程已退出，退出码0
stdout: 进程1执行
​
stderr:
```

### spawn方法

&emsp;&emsp;`child_process.spawn`使用指定的命令行参数创建新进程：

``` javascript
child_process.spawn(command[, args][, options])
```

参数`command`是将要运行的命令；`args`是字符串参数数组；`options`是对象：

- `cwd`：字符串，子进程的当前工作目录
- `env`：对象，环境变量键值对。
- `detached`：布尔值，这个子进程是否将变成进程组的领导。
- `uid`：数字，设置用户进程的`ID`。
- `gid`：数字，设置进程组的`ID`。

`spawn`方法返回流(`stdout`和`stderr`)，在进程返回大量数据时使用。进程一旦开始执行时，`spawn`就接收响应。
&emsp;&emsp;创建`support.js`和`master.js`。`support.js`代码如下：

``` javascript
console.log("进程" + process.argv[2] + "执行");
```

`master.js`代码如下：

``` javascript
const fs = require('fs');
const child_process = require('child_process');
​
for (var i = 0; i < 3; i++) {
    var workerProcess = child_process.spawn('node', ['support.js', i]);
​
    workerProcess.stdout.on('data', function (data) {
        console.log('stdout: ' + data);
    });
​
    workerProcess.stderr.on('data', function (data) {
        console.log('stderr: ' + data);
    });
​
    workerProcess.on('close', function (code) {
        console.log('子进程已退出，退出码' + code);
    });
}
```

执行结果：

``` javascript
stdout: 进程0执行
​
子进程已退出，退出码0
stdout: 进程1执行
​
子进程已退出，退出码0
stdout: 进程2执行
​
子进程已退出，退出码0
```

### fork方法

&emsp;&emsp;`child_process.fork`是`spawn`方法的特殊形式，用于创建进程：

``` javascript
child_process.fork(modulePath[, args][, options])
```

参数`modulePath`是字符串，它是将要在子进程中运行的模块；`args`是`Array`，字符串参数数组；`options`是对象：

- `cwd`：字符串，子进程的当前工作目录。
- `env`：对象，环境变量键值对。
- `execPath`：字符串，创建子进程的可执行文件。
- `execArgv`：数组，子进程的可执行文件的字符串参数数组，默认为`process.execArgv`。
- `silent`：布尔值，如果为`true`，子进程的`stdin`、`stdout`和`stderr`将会被关联至父进程；否则，它们将会从父进程中继承，默认为`false`。
- `uid`：数字，设置用户进程的`ID`。
- `gid`：数字，设置进程组的`ID`。

返回的对象除了拥有`ChildProcess`实例的所有方法，还有一个内建的通信信道。
&emsp;&emsp;创建`support.js`和`master.js`。`support.js`代码如下：

``` javascript
console.log("进程" + process.argv[2] + "执行");
```

`master.js`代码如下：

``` javascript
const fs = require('fs');
const child_process = require('child_process');
​
for (var i = 0; i < 3; i++) {
    var worker_process = child_process.fork("support.js", [i]);
​
    worker_process.on('close', function (code) {
        console.log('子进程已退出，退出码' + code);
    });
}
```

执行结果：

``` javascript
进程0执行
子进程已退出，退出码0
进程1执行
子进程已退出，退出码0
进程2执行
子进程已退出，退出码0
```