---
title: 静态库和动态库
categories: Linux应用笔记
date: 2019-02-02 19:13:28
---
### Linux下静态库生成和使用

#### 静态库概念

&emsp;&emsp;库是预编译的目标文件(`object files`)的集合，它们可以被链接进程序。静态库以后缀为`.a`的特殊的存档(`archive file`)存储。<!--more-->
&emsp;&emsp;标准系统库可在目录`/usr/lib`与`/lib`中找到，比如类`Unix`系统的`C`语言数字库一般存储为文件`/usr/lib/libm.a`，该库中函数的原型声明在头文件`/usr/include/math.h`中。
&emsp;&emsp;`C`标准库本身存储为`/usr/lib/libc.a`，它包含标准指定的函数，比如`printf`。对每一个`C`程序来说，`libc.a`都默认被链接。

#### 生成和使用静态库

&emsp;&emsp;静态库由程序`ar`生成，其优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间(在编译大型程序的时候，需要花费很长的时间)。静态库的另一个优点是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。
&emsp;&emsp;通过一个实例来了解如何生成静态库和使用静态库，首先生成静态库：在`test`文件夹下有三个文件，即`main.c`、`tiger.c`和`tiger.h`。
&emsp;&emsp;`main.c`如下：

``` cpp
#include <stdio.h>
#include "tiger.h"

int main ( void ) {
    printf ( "sum = %d\n", add ( 3, 5 ) );
    return 0;
}
```

`tiger.h`如下：

``` cpp
#ifndef __TIGER__
#define __TIGER__

int add ( int a, int b );

#endif
```

`tiger.c`如下：

``` cpp
int add ( int a, int b ) {
    return a + b;
}
```

&emsp;&emsp;创建静态库的最基本步骤是先生成目标文件`tiger.o`：

``` bash
gcc -o tiger.o -c tiger.c
```

然后生成静态库`libadd.a`：

``` bash
ar -rcs libadd.a tiger.o
```

&emsp;&emsp;其次使用静态库，使用`gcc`命令带上库文件就可以了：

``` bash
gcc -o main main.c libadd.a
```

也可以使用命令`-l库名`进行，库名是不包含库函数库和扩展名的字符串：

``` bash
gcc -o main main.c -ladd
```

上面的命令执行完后，系统返回如下错误：

``` bash
/usr/bin/ld: cannot find -ladd
collect2: error: ld returned 1 exit status
```

上面的命令将在系统默认的路径来查找`add`函数库，并把它链接到要生成的目标程序上。系统提示没有找到库文件`add`，这是由于`add`库函数没有在系统默认的查找路径下，我们需要认为指定库函数的路径，例如库文件和当前编译文件在同一目录下：

``` bash
gcc -o main main.c -L ./ -ladd
```

系统就能正常生成可执行文件。在使用`-l`选项时，`-o`选项的目的名要在`-l`链接的库名之前，否则`gcc`会认为`-l`是生成的目标而出错。

### Linux下动态库生成和使用

#### 动态库的基本概念

&emsp;&emsp;动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。
&emsp;&emsp;动态链接库的名称有别名(`soname`)、真名(`realname`)和链接名(`linker name`)。别名由一个前缀`lib`，然后是库的名字，再加上一个后缀`.so`构成。真名是动态链接库真实名称，一般总是在别名的基础加上一个小版本号，发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。
&emsp;&emsp;在动态链接库安装的时候，总是复制文件到某个目录下，然后用一个软连接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。

#### 生成和使用动态库

&emsp;&emsp;看一个实例来了解如何自己生成静态库和使用静态库。在`test`文件夹下有三个文件，即`main.c`、`add.c`、`sub.c`和`tiger.h`。
&emsp;&emsp;`main.c`如下：

``` cpp
#include <stdio.h>
#include "tiger.h"

int main ( void ) {
    printf ( "sum = %d\n", add ( 5, 3 ) );
    printf ( "sub = %d\n", sub ( 5, 3 ) );
    return 0;
}
```

`tiger.h`如下：

``` cpp
#ifndef __TIGER__
#define __TIGER__

int add ( int a, int b );
int sub ( int a, int b );

#endif
```

`add.c`如下：

``` cpp
int add ( int a, int b ) {
    return a + b;
}
```

`sub.c`如下：

``` cpp
int sub ( int a, int b ) {
    return a - b;
}
```

&emsp;&emsp;首先生成目标文件，但是此时要加编译器选项`-fpic`和链接器选项`-shared`：

``` bash
gcc -fpic -c add.c
gcc -fpic -c sub.c
```

生成中间文件`add.o`和`sub.o`。其次生成动态库：

``` bash
gcc -shared -o libtiger.so add.o sub.o
```

生成动态库`libtiger.so`，我们以后使用动态库和`main.c`程序生成可执行程序。以上两部也可以合成一步搞定：

``` bash
gcc -fpic -shared add.c sub.c -o libtiger.so
```

&emsp;&emsp;在编译程序时，使用动态链接库和静态库是一致的，使用`-l库名`的方式，在生成可执行文件的时候会链接库文件。使用如下命令：

``` bash
gcc -o main main.c -L ./ -ltiger
```

`-L`指定动态链接库的路劲，`-ldtiger`链接库函数`tiger`。`-ltiger`是动态库的调用规则，`Linux`系统下的动态库命名方式是`lib*.so`，而在链接时表示为`-l*`，`*`是自己命名的库名。但是程序会提示如下错误：

``` bash
error while loading shared libraries: libtiger.so: cannot open shared object file: No such file or direct
```

这是因为程序运行时没有找到动态链接库造成的。程序编译时，链接动态库和运行时使用动态链接库的概念是不同的。在运行时，程序链接的动态链接库需要在系统目录下才行。
&emsp;&emsp;使用以下方法可以解决此问题：

- 在`Linux`下最方便的解决方案是拷贝`libtiger.so`到绝对目录`/lib`下，就可以生成可执行程序了。
- 将动态链接库的目录放到程序搜索路径中，可以将库的路径加到环境变量`LD_LIBRARY_PATH`中实现：

``` bash
export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH
```

执行此命令后也可以生成可执行程序。